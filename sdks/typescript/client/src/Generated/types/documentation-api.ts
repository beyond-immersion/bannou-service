/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/documentation/view/{slug}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * View documentation page in browser
     * @description Browser-facing endpoint for viewing documentation.
     *     Routed via NGINX, not exposed to WebSocket clients.
     *     Returns HTML-rendered documentation page.
     */
    get: operations['viewDocumentBySlug'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/raw/{slug}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get raw markdown content
     * @description Browser-facing endpoint for retrieving raw markdown content.
     *     Routed via NGINX, not exposed to WebSocket clients.
     *     Returns raw markdown with text/markdown content type.
     */
    get: operations['rawDocumentBySlug'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Natural language documentation search
     * @description Search documentation using natural language queries.
     *     Returns the most relevant documents with voice-friendly summaries.
     */
    post: operations['queryDocumentation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get specific document by ID or slug
     * @description Retrieve a specific document by its unique identifier or slug.
     *     Returns full content with metadata.
     */
    post: operations['getDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Full-text keyword search
     * @description Search documentation using exact keyword matching.
     *     Faster than semantic search but less flexible.
     */
    post: operations['searchDocumentation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List documents by category
     * @description List all documents in a specific category or all categories.
     *     Supports pagination for large result sets.
     */
    post: operations['listDocuments'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/suggest': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get related topics and follow-up suggestions
     * @description Given a topic or document ID, returns related topics the user
     *     might want to explore. Useful for conversational AI flow.
     */
    post: operations['suggestRelatedTopics'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create new documentation entry */
    post: operations['createDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update existing documentation entry */
    post: operations['updateDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Soft-delete documentation entry to trashcan
     * @description Moves document to trashcan for recovery within TTL period.
     *     Documents are automatically cleaned up after TrashcanTtlDays.
     */
    post: operations['deleteDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/recover': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Recover document from trashcan
     * @description Restores a soft-deleted document from the trashcan.
     *     Must be called before the trashcan TTL expires.
     */
    post: operations['recoverDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/bulk-update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bulk update document metadata
     * @description Apply category, tag, or metadata changes to multiple documents at once.
     *     Each document is processed independently - partial success is possible.
     */
    post: operations['bulkUpdateDocuments'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/bulk-delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bulk soft-delete documents to trashcan
     * @description Move multiple documents to trashcan at once.
     *     Each document is processed independently - partial success is possible.
     */
    post: operations['bulkDeleteDocuments'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/import': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bulk import documentation from structured source
     * @description Import multiple documents. Each document processed independently.
     *     Partial success is possible - failures reported per document.
     */
    post: operations['importDocumentation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/trashcan': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List documents in the trashcan
     * @description List all soft-deleted documents within the namespace's trashcan.
     *     Documents remain recoverable until TTL expires or purge is called.
     */
    post: operations['listTrashcan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/purge': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Permanently delete trashcan items
     * @description Permanently delete specified documents from trashcan, or purge all.
     *     This operation is irreversible - documents cannot be recovered after purge.
     */
    post: operations['purgeTrashcan'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get namespace documentation statistics
     * @description Retrieve usage statistics and metadata for a documentation namespace.
     *     Useful for monitoring, capacity planning, and administrative dashboards.
     */
    post: operations['getNamespaceStats'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/bind': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bind a git repository to a documentation namespace
     * @description Bind a git repository URL to a documentation namespace.
     *     The namespace will be exclusively managed by the repository - manual edits will be blocked.
     *     Triggers initial sync after binding.
     */
    post: operations['bindRepository'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/unbind': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove repository binding from namespace
     * @description Remove repository binding from a namespace, making it manually editable again.
     *     Optionally delete all documents imported from the repository.
     */
    post: operations['unbindRepository'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/sync': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Manually trigger repository sync
     * @description Manually trigger synchronization of a bound repository.
     *     If force=true, performs full re-sync regardless of commit hash.
     */
    post: operations['syncRepository'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get repository binding status
     * @description Get current status of a repository binding including sync state and statistics.
     */
    post: operations['getRepositoryStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all repository bindings
     * @description List all repository bindings with optional filtering by status.
     */
    post: operations['listRepositoryBindings'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update repository binding configuration
     * @description Update sync settings, file patterns, category mappings, or archive configuration.
     */
    post: operations['updateRepositoryBinding'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create documentation archive
     * @description Create a .bannou bundle archive of all documents in a namespace.
     *     Archives are stored via Asset Service.
     */
    post: operations['createDocumentationArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List documentation archives
     * @description List all archives for a namespace.
     */
    post: operations['listDocumentationArchives'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/restore': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restore documentation from archive
     * @description Restore documents from a .bannou bundle archive.
     *     Replaces all documents in the namespace with archived content.
     */
    post: operations['restoreDocumentationArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documentation/repo/archive/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete documentation archive
     * @description Delete an archive from Asset Service storage.
     */
    post: operations['deleteDocumentationArchive'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * @description Fixed categories for type-safe filtering
     * @enum {string}
     */
    DocumentCategory:
      | 'getting-started'
      | 'api-reference'
      | 'architecture'
      | 'deployment'
      | 'troubleshooting'
      | 'tutorials'
      | 'game-systems'
      | 'world-lore'
      | 'npc-ai'
      | 'other';
    /**
     * @description How deep to traverse related document links:
     *     - none: No related documents included
     *     - direct: Only directly linked documents (depth 1)
     *     - extended: Related documents + their related documents (depth 2)
     * @default direct
     * @enum {string}
     */
    RelatedDepth: 'none' | 'direct' | 'extended';
    /**
     * @description Fields that can be searched within documents
     * @enum {string}
     */
    SearchField: 'title' | 'content' | 'tags' | 'summary';
    /**
     * @description Fields available for sorting document lists
     * @default updated_at
     * @enum {string}
     */
    ListSortField: 'created_at' | 'updated_at' | 'title';
    /**
     * @description Source type for generating related topic suggestions
     * @enum {string}
     */
    SuggestionSource: 'document_id' | 'slug' | 'topic' | 'category';
    /** @description Request to search documentation using natural language queries */
    QueryDocumentationRequest: {
      /** @description Documentation namespace to search within */
      namespace: string;
      /** @description Natural language query to search for */
      query: string;
      /**
       * Format: uuid
       * @description Optional session ID for conversational context
       */
      sessionId?: string;
      /** @description Filter results to a specific category */
      category?: components['schemas']['DocumentCategory'];
      /**
       * @description Maximum number of results to return
       * @default 5
       */
      maxResults: number;
      /**
       * @description Whether to include full document content in results
       * @default false
       */
      includeContent: boolean;
      /**
       * @description Maximum length of summaries in characters
       * @default 300
       */
      maxSummaryLength: number;
      /**
       * Format: float
       * @description Minimum relevance score threshold for results
       * @default 0.3
       */
      minRelevanceScore: number;
    };
    /** @description Response containing search results and voice-friendly summaries */
    QueryDocumentationResponse: {
      /** @description The namespace that was searched */
      namespace: string;
      /** @description The original query string */
      query: string;
      /** @description List of matching documents */
      results: components['schemas']['DocumentResult'][];
      /** @description Total number of matching documents */
      totalResults?: number;
      /** @description Concise spoken summary for voice AI */
      voiceSummary?: string;
      /** @description Suggested follow-up queries */
      suggestedFollowups?: string[];
      /** @description User-friendly message when no results found */
      noResultsMessage?: string;
    };
    /** @description Request to retrieve a specific document by ID or slug */
    GetDocumentRequest: {
      /** @description Documentation namespace containing the document */
      namespace: string;
      /**
       * Format: uuid
       * @description Unique identifier of the document to retrieve (null if using slug)
       */
      documentId?: string | null;
      /** @description URL-friendly slug of the document to retrieve (null if using documentId) */
      slug?: string | null;
      /**
       * Format: uuid
       * @description Optional session ID for tracking document views (null if not tracking)
       */
      sessionId?: string | null;
      /** @description How deep to fetch related documents (null for no related documents) */
      includeRelated?: components['schemas']['RelatedDepth'];
      /**
       * @description Whether to include full document content
       * @default false
       */
      includeContent: boolean;
      /**
       * @description Whether to render markdown content as HTML
       * @default false
       */
      renderHtml: boolean;
    };
    /** @description Response containing the requested document and optional related documents */
    GetDocumentResponse: {
      /** @description The requested document */
      document: components['schemas']['Document'];
      /** @description List of related documents based on includeRelated depth */
      relatedDocuments?: components['schemas']['DocumentSummary'][];
      /**
       * @description Format of the content field in the response
       * @enum {string}
       */
      contentFormat?: 'markdown' | 'html' | 'none';
    };
    /** @description Request to search documentation using keyword matching */
    SearchDocumentationRequest: {
      /** @description Documentation namespace to search within */
      namespace: string;
      /** @description Keyword or phrase to search for */
      searchTerm: string;
      /**
       * Format: uuid
       * @description Optional session ID for tracking searches (null if not tracking)
       */
      sessionId?: string | null;
      /** @description Filter results to a specific category (null for all categories) */
      category?: components['schemas']['DocumentCategory'];
      /**
       * @description Maximum number of results to return
       * @default 10
       */
      maxResults: number;
      /** @description Fields to search within (null for default fields) */
      searchIn?: components['schemas']['SearchField'][] | null;
      /**
       * @description How to sort the search results
       * @default relevance
       * @enum {string}
       */
      sortBy: 'relevance' | 'recency' | 'alphabetical';
      /**
       * @description Whether to include full document content in results
       * @default false
       */
      includeContent: boolean;
    };
    /** @description Response containing keyword search results */
    SearchDocumentationResponse: {
      /** @description The namespace that was searched */
      namespace: string;
      /** @description List of matching documents */
      results: components['schemas']['DocumentResult'][];
      /** @description Total number of matching documents */
      totalResults?: number;
      /** @description The original search term */
      searchTerm?: string;
    };
    /** @description Request to list documents with optional filtering and pagination */
    ListDocumentsRequest: {
      /** @description Documentation namespace to list documents from */
      namespace: string;
      /** @description Filter to a specific category */
      category?: components['schemas']['DocumentCategory'];
      /** @description Filter by tags (null to skip tag filtering) */
      tags?: string[] | null;
      /**
       * @description Whether documents must match all tags or any tag
       * @default all
       * @enum {string}
       */
      tagsMatch: 'all' | 'any';
      /**
       * Format: date-time
       * @description Filter to documents created after this timestamp
       */
      createdAfter?: string;
      /**
       * Format: date-time
       * @description Filter to documents created before this timestamp
       */
      createdBefore?: string;
      /**
       * Format: date-time
       * @description Filter to documents updated after this timestamp
       */
      updatedAfter?: string;
      /**
       * Format: date-time
       * @description Filter to documents updated before this timestamp
       */
      updatedBefore?: string;
      /**
       * @description Return only document titles without summaries
       * @default false
       */
      titlesOnly: boolean;
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of documents per page
       * @default 20
       */
      pageSize: number;
      /** @description Field to sort results by */
      sortBy?: components['schemas']['ListSortField'];
      /**
       * @description Sort order direction
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    /** @description Response containing a paginated list of documents */
    ListDocumentsResponse: {
      /** @description The namespace that was listed */
      namespace: string;
      /** @description List of documents in the namespace */
      documents: components['schemas']['DocumentSummary'][];
      /** @description Total number of documents matching filters */
      totalCount?: number;
      /** @description Current page number */
      page?: number;
      /** @description Number of documents per page */
      pageSize?: number;
      /** @description Total number of pages available */
      totalPages?: number;
    };
    /** @description Request to get related topic suggestions based on a source */
    SuggestRelatedRequest: {
      /** @description Documentation namespace for suggestions */
      namespace: string;
      /** @description Type of source to base suggestions on */
      suggestionSource: components['schemas']['SuggestionSource'];
      /** @description The value for the suggestion source (document ID, slug, topic, or category) */
      sourceValue?: string;
      /**
       * Format: uuid
       * @description Optional session ID for personalized suggestions
       */
      sessionId?: string;
      /**
       * @description Maximum number of suggestions to return
       * @default 5
       */
      maxSuggestions: number;
      /**
       * @description Exclude documents viewed in current session
       * @default true
       */
      excludeRecentlyViewed: boolean;
    };
    /** @description Response containing suggested related topics for conversational flow */
    SuggestRelatedResponse: {
      /** @description The namespace suggestions are from */
      namespace: string;
      /** @description List of suggested related topics */
      suggestions: components['schemas']['TopicSuggestion'][];
      /** @description Voice-friendly prompt for presenting suggestions */
      voicePrompt?: string;
      /** @description Whether suggestions were influenced by session history */
      sessionInfluenced?: boolean;
    };
    /** @description A suggested related topic with relevance context */
    TopicSuggestion: {
      /**
       * Format: uuid
       * @description Unique identifier of the suggested document
       */
      documentId: string;
      /** @description URL-friendly slug of the suggested document */
      slug?: string;
      /** @description Title of the suggested document */
      title: string;
      /** @description Category of the suggested document */
      category?: components['schemas']['DocumentCategory'];
      /** @description Explanation of why this document is relevant */
      relevanceReason?: string;
    };
    /** @description Request to create a new documentation entry */
    CreateDocumentRequest: {
      /** @description Documentation namespace to create document in */
      namespace: string;
      /** @description URL-friendly unique identifier for the document */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category for organizing the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Markdown content (max 500KB) */
      content: string;
      /** @description Brief text summary of the document (null if not provided) */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI (null if not provided) */
      voiceSummary?: string | null;
      /** @description Tags for filtering and search (null to skip tagging) */
      tags?: string[] | null;
      /** @description IDs of related documents to link (null to skip linking) */
      relatedDocuments?: string[] | null;
      /** @description Custom metadata key-value pairs (null if not needed) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response confirming document creation with assigned identifiers */
    CreateDocumentResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the created document
       */
      documentId: string;
      /** @description URL-friendly slug of the created document */
      slug: string;
      /**
       * Format: date-time
       * @description Timestamp when the document was created
       */
      createdAt?: string;
    };
    /** @description Request to update an existing document's fields */
    UpdateDocumentRequest: {
      /** @description Documentation namespace containing the document */
      namespace: string;
      /**
       * Format: uuid
       * @description Unique identifier of the document to update
       */
      documentId: string;
      /** @description New URL-friendly slug for the document (null to keep unchanged) */
      slug?: string | null;
      /** @description New display title for the document (null to keep unchanged) */
      title?: string | null;
      /** @description New category for the document (null to keep unchanged) */
      category?: components['schemas']['DocumentCategory'];
      /** @description New markdown content for the document (null to keep unchanged) */
      content?: string | null;
      /** @description New text summary for the document (null to keep unchanged) */
      summary?: string | null;
      /** @description New voice-optimized summary for the document (null to keep unchanged) */
      voiceSummary?: string | null;
      /** @description New set of tags for the document (null to keep unchanged) */
      tags?: string[] | null;
      /** @description New set of related document IDs (null to keep unchanged) */
      relatedDocuments?: string[] | null;
      /** @description New custom metadata key-value pairs (null to keep unchanged) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response confirming document update with timestamp */
    UpdateDocumentResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the updated document
       */
      documentId: string;
      /**
       * Format: date-time
       * @description Timestamp when the document was updated
       */
      updatedAt: string;
    };
    /** @description Request to soft-delete a document to the trashcan */
    DeleteDocumentRequest: {
      /** @description Documentation namespace containing the document */
      namespace: string;
      /**
       * Format: uuid
       * @description Unique identifier of the document to delete (null if using slug)
       */
      documentId?: string | null;
      /** @description URL-friendly slug of the document to delete (null if using documentId) */
      slug?: string | null;
    };
    /** @description Response confirming document deletion with recovery deadline */
    DeleteDocumentResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the deleted document
       */
      documentId: string;
      /**
       * Format: date-time
       * @description Timestamp when the document was deleted
       */
      deletedAt: string;
      /**
       * Format: date-time
       * @description Deadline for recovering the document from trashcan
       */
      recoverableUntil: string;
    };
    /** @description Request to recover a deleted document from the trashcan */
    RecoverDocumentRequest: {
      /** @description Documentation namespace containing the trashcan */
      namespace: string;
      /**
       * Format: uuid
       * @description Unique identifier of the document to recover
       */
      documentId: string;
    };
    /** @description Response confirming document recovery with timestamp */
    RecoverDocumentResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the recovered document
       */
      documentId: string;
      /**
       * Format: date-time
       * @description Timestamp when the document was recovered
       */
      recoveredAt: string;
    };
    /** @description Request to update multiple documents at once */
    BulkUpdateRequest: {
      /** @description Documentation namespace containing the documents */
      namespace: string;
      /** @description List of document IDs to update */
      documentIds: string[];
      /** @description New category to apply to all documents */
      category?: components['schemas']['DocumentCategory'];
      /** @description Tags to add to all documents (null to skip adding) */
      addTags?: string[] | null;
      /** @description Tags to remove from all documents (null to skip removing) */
      removeTags?: string[] | null;
    };
    /** @description Response reporting bulk update results with success and failure details */
    BulkUpdateResponse: {
      /** @description IDs of documents successfully updated */
      succeeded: string[];
      /** @description Details of documents that failed to update */
      failed: components['schemas']['BulkOperationFailure'][];
    };
    /** @description Request to delete multiple documents at once */
    BulkDeleteRequest: {
      /** @description Documentation namespace containing the documents */
      namespace: string;
      /** @description List of document IDs to delete */
      documentIds: string[];
    };
    /** @description Response reporting bulk deletion results with success and failure details */
    BulkDeleteResponse: {
      /** @description IDs of documents successfully deleted */
      succeeded: string[];
      /** @description Details of documents that failed to delete */
      failed: components['schemas']['BulkOperationFailure'][];
    };
    /** @description Details of a single document that failed in a bulk operation */
    BulkOperationFailure: {
      /**
       * Format: uuid
       * @description ID of the document that failed
       */
      documentId: string;
      /** @description Error message explaining the failure */
      error: string;
    };
    /** @description Request to import multiple documents into a namespace */
    ImportDocumentationRequest: {
      /** @description Documentation namespace to import into */
      namespace: string;
      /** @description List of documents to import */
      documents: components['schemas']['ImportDocument'][];
      /**
       * @description How to handle documents with existing slugs
       * @default skip
       * @enum {string}
       */
      onConflict: 'skip' | 'update' | 'fail';
    };
    /** @description A single document to import with required fields */
    ImportDocument: {
      /** @description URL-friendly unique identifier for the document */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category for organizing the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Markdown content of the document */
      content: string;
      /** @description Brief text summary of the document (null if not provided) */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI (null if not provided) */
      voiceSummary?: string | null;
      /** @description Tags for filtering and search (null to skip tagging) */
      tags?: string[] | null;
      /** @description Custom metadata key-value pairs (null if not needed) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response reporting import results with counts and failure details */
    ImportDocumentationResponse: {
      /** @description The namespace documents were imported into */
      namespace: string;
      /** @description Number of new documents created */
      created: number;
      /** @description Number of existing documents updated */
      updated: number;
      /** @description Number of documents skipped due to conflicts */
      skipped: number;
      /** @description Details of documents that failed to import */
      failed: components['schemas']['ImportFailure'][];
    };
    /** @description Details of a document that failed to import */
    ImportFailure: {
      /** @description Slug of the document that failed to import */
      slug: string;
      /** @description Error message explaining the failure */
      error: string;
    };
    /** @description Request to list deleted documents in the trashcan */
    ListTrashcanRequest: {
      /** @description Documentation namespace to list trashcan from */
      namespace: string;
      /**
       * @description Page number for pagination
       * @default 1
       */
      page: number;
      /**
       * @description Number of items per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Response containing deleted documents awaiting permanent deletion */
    ListTrashcanResponse: {
      /** @description The namespace the trashcan belongs to */
      namespace: string;
      /** @description List of deleted documents in trashcan */
      items: components['schemas']['TrashcanItem'][];
      /** @description Total number of items in trashcan */
      totalCount?: number;
    };
    /** @description A deleted document in the trashcan with expiration information */
    TrashcanItem: {
      /**
       * Format: uuid
       * @description Unique identifier of the deleted document
       */
      documentId: string;
      /** @description URL-friendly slug of the deleted document */
      slug?: string;
      /** @description Title of the deleted document */
      title: string;
      /** @description Category of the deleted document */
      category?: components['schemas']['DocumentCategory'];
      /**
       * Format: date-time
       * @description Timestamp when the document was deleted
       */
      deletedAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the document will be permanently deleted
       */
      expiresAt: string;
    };
    /** @description Request to permanently delete documents from the trashcan */
    PurgeTrashcanRequest: {
      /** @description Documentation namespace to purge trashcan from */
      namespace: string;
      /** @description If empty, purges all trashcan items */
      documentIds?: string[];
    };
    /** @description Response confirming permanent deletion of trashcan items */
    PurgeTrashcanResponse: {
      /** @description Number of documents permanently deleted */
      purgedCount: number;
    };
    /** @description Request to get statistics for a documentation namespace */
    GetNamespaceStatsRequest: {
      /** @description Documentation namespace to get statistics for */
      namespace: string;
    };
    /** @description Response containing namespace statistics and document counts */
    NamespaceStatsResponse: {
      /** @description The namespace statistics are for */
      namespace: string;
      /** @description Total number of documents in the namespace */
      documentCount: number;
      /** @description Document count per category */
      categoryCounts?: {
        [key: string]: number;
      };
      /** @description Number of documents in the trashcan */
      trashcanCount?: number;
      /** @description Total size of all document content in bytes */
      totalContentSizeBytes?: number;
      /**
       * Format: date-time
       * @description Timestamp of most recent document update
       */
      lastUpdated?: string;
    };
    /** @description Complete document with all metadata and content */
    Document: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description Namespace the document belongs to */
      namespace: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category for organizing the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Full markdown content of the document */
      content?: string;
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Tags for filtering and search */
      tags?: string[];
      /** @description IDs of related documents */
      relatedDocuments?: string[];
      /** @description Custom metadata key-value pairs */
      metadata?: {
        [key: string]: unknown;
      };
      /**
       * Format: date-time
       * @description Timestamp when the document was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the document was last updated
       */
      updatedAt: string;
    };
    /** @description Lightweight document representation for listings and references */
    DocumentSummary: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category of the document */
      category: components['schemas']['DocumentCategory'];
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Tags associated with the document */
      tags?: string[];
    };
    /** @description Search result with relevance scoring and match highlights */
    DocumentResult: {
      /**
       * Format: uuid
       * @description Unique identifier of the document
       */
      documentId: string;
      /** @description URL-friendly unique identifier */
      slug: string;
      /** @description Display title of the document */
      title: string;
      /** @description Category of the document */
      category?: components['schemas']['DocumentCategory'];
      /** @description Brief text summary of the document */
      summary?: string | null;
      /** @description Concise summary optimized for voice AI */
      voiceSummary?: string | null;
      /** @description Full document content if requested */
      content?: string | null;
      /**
       * Format: float
       * @description Relevance score from 0.0 to 1.0
       */
      relevanceScore: number;
      /** @description Text snippets showing where matches occurred */
      matchHighlights?: string[];
    };
    /**
     * @description Status of a repository binding
     * @enum {string}
     */
    BindingStatus: 'pending' | 'syncing' | 'synced' | 'error' | 'disabled';
    /**
     * @description Result status of a sync operation
     * @enum {string}
     */
    SyncStatus: 'success' | 'partial' | 'failed';
    /**
     * @description What triggered the sync operation
     * @enum {string}
     */
    SyncTrigger: 'manual' | 'scheduled';
    /** @description Request to bind a Git repository for automatic documentation sync */
    BindRepositoryRequest: {
      /**
       * @description Owner of this binding. NOT a session ID.
       *     For user-initiated bindings: the accountId (UUID format).
       *     For service-initiated bindings: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Documentation namespace to bind */
      namespace: string;
      /** @description Git clone URL (HTTPS for public repos) */
      repositoryUrl: string;
      /**
       * @description Branch to sync from
       * @default main
       */
      branch: string;
      /**
       * @description How often to sync (5 min to 24 hours)
       * @default 60
       */
      syncIntervalMinutes: number;
      /**
       * @description Glob patterns for files to include
       * @default [
       *       "**\/*.md"
       *     ]
       */
      filePatterns: string[];
      /**
       * @description Glob patterns for files to exclude
       * @default [
       *       ".git/**",
       *       ".obsidian/**",
       *       "node_modules/**"
       *     ]
       */
      excludePatterns: string[];
      /** @description Map directory prefixes to categories */
      categoryMapping?: {
        [key: string]: string;
      };
      /** @description Default category for documents without mapping */
      defaultCategory?: components['schemas']['DocumentCategory'];
      /**
       * @description Enable archive functionality
       * @default false
       */
      archiveEnabled: boolean;
      /**
       * @description Create archive after each sync
       * @default false
       */
      archiveOnSync: boolean;
    };
    /** @description Response confirming repository binding creation */
    BindRepositoryResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the repository binding
       */
      bindingId: string;
      /** @description Namespace the repository is bound to */
      namespace: string;
      /** @description URL of the bound repository */
      repositoryUrl?: string;
      /** @description Branch being synced */
      branch?: string;
      /** @description Current status of the binding */
      status: components['schemas']['BindingStatus'];
      /**
       * Format: date-time
       * @description Timestamp when the binding was created
       */
      createdAt?: string;
    };
    /** @description Request to remove a repository binding from a namespace */
    UnbindRepositoryRequest: {
      /** @description Documentation namespace to unbind */
      namespace: string;
      /**
       * @description Also delete all documents from the namespace
       * @default false
       */
      deleteDocuments: boolean;
    };
    /** @description Response confirming repository unbinding with cleanup details */
    UnbindRepositoryResponse: {
      /** @description Namespace that was unbound */
      namespace: string;
      /** @description Number of documents deleted (0 if deleteDocuments was false) */
      documentsDeleted: number;
    };
    /** @description Request to trigger a manual repository sync */
    SyncRepositoryRequest: {
      /** @description Documentation namespace to sync */
      namespace: string;
      /**
       * @description Force full re-sync even if commit hash unchanged
       * @default false
       */
      force: boolean;
    };
    /** @description Response containing sync operation results and statistics */
    SyncRepositoryResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of this sync operation
       */
      syncId: string;
      /** @description Result status of the sync */
      status: components['schemas']['SyncStatus'];
      /** @description Git commit hash that was synced (null if sync failed or repo is empty) */
      commitHash?: string | null;
      /** @description Number of new documents created */
      documentsCreated?: number;
      /** @description Number of existing documents updated */
      documentsUpdated?: number;
      /** @description Number of documents deleted */
      documentsDeleted?: number;
      /** @description Number of documents that failed to process */
      documentsFailed?: number;
      /** @description Time taken for sync in milliseconds */
      durationMs?: number;
      /** @description Error message if sync failed */
      errorMessage?: string | null;
    };
    /** @description Request to get current repository binding and sync status */
    RepositoryStatusRequest: {
      /** @description Documentation namespace to get status for */
      namespace: string;
    };
    /** @description Response containing binding configuration and recent sync information */
    RepositoryStatusResponse: {
      /** @description Current binding configuration and status */
      binding?: components['schemas']['RepositoryBindingInfo'];
      /** @description Information about the most recent sync */
      lastSync?: components['schemas']['SyncInfo'];
    };
    /** @description Detailed repository binding configuration and status */
    RepositoryBindingInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the repository binding
       */
      bindingId: string;
      /** @description Namespace the repository is bound to */
      namespace: string;
      /** @description URL of the bound repository */
      repositoryUrl: string;
      /** @description Branch being synced */
      branch?: string;
      /** @description Current status of the binding */
      status: components['schemas']['BindingStatus'];
      /** @description Whether automatic sync is enabled */
      syncEnabled?: boolean;
      /** @description Sync interval in minutes */
      syncIntervalMinutes?: number;
      /** @description Number of documents from this repository */
      documentCount?: number;
      /**
       * Format: date-time
       * @description Timestamp when the binding was created
       */
      createdAt?: string;
      /**
       * @description Owner of this binding. NOT a session ID.
       *     Contains either an accountId (UUID format) for user-initiated bindings
       *     or a service name for service-initiated bindings.
       */
      owner?: string;
    };
    /** @description Information about a repository sync operation */
    SyncInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the sync operation
       */
      syncId?: string;
      /** @description Result status of the sync */
      status?: components['schemas']['SyncStatus'];
      /** @description What triggered the sync */
      triggeredBy?: components['schemas']['SyncTrigger'];
      /**
       * Format: date-time
       * @description Timestamp when sync started
       */
      startedAt?: string;
      /**
       * Format: date-time
       * @description Timestamp when sync completed
       */
      completedAt?: string;
      /** @description Git commit hash that was synced (null if sync failed or repo is empty) */
      commitHash?: string | null;
      /** @description Total documents processed in sync */
      documentsProcessed?: number;
    };
    /** @description Request to list all repository bindings with optional filtering */
    ListRepositoryBindingsRequest: {
      /** @description Filter by binding status */
      status?: components['schemas']['BindingStatus'];
      /**
       * @description Maximum number of bindings to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of bindings to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a list of repository bindings */
    ListRepositoryBindingsResponse: {
      /** @description List of repository bindings */
      bindings: components['schemas']['RepositoryBindingInfo'][];
      /** @description Total number of bindings matching filter */
      total: number;
    };
    /** @description Request to update repository binding configuration */
    UpdateRepositoryBindingRequest: {
      /** @description Documentation namespace of the binding to update */
      namespace: string;
      /** @description Enable or disable automatic syncing */
      syncEnabled?: boolean;
      /** @description New sync interval in minutes */
      syncIntervalMinutes?: number;
      /** @description New glob patterns for files to include (null to keep unchanged) */
      filePatterns?: string[] | null;
      /** @description New glob patterns for files to exclude (null to keep unchanged) */
      excludePatterns?: string[] | null;
      /** @description New directory-to-category mapping (null to keep unchanged) */
      categoryMapping?: {
        [key: string]: string;
      } | null;
      /** @description New default category for unmapped documents */
      defaultCategory?: components['schemas']['DocumentCategory'];
      /** @description Enable or disable archive functionality */
      archiveEnabled?: boolean;
      /** @description Enable or disable archiving after each sync */
      archiveOnSync?: boolean;
    };
    /** @description Response containing the updated binding configuration */
    UpdateRepositoryBindingResponse: {
      /** @description Updated binding configuration */
      binding: components['schemas']['RepositoryBindingInfo'];
    };
    /** @description Request to create a point-in-time snapshot of namespace documentation */
    CreateArchiveRequest: {
      /**
       * @description Owner of this archive. NOT a session ID.
       *     For user-initiated archives: the accountId (UUID format).
       *     For service-initiated archives: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Documentation namespace to archive */
      namespace: string;
      /** @description Optional description for the archive */
      description?: string;
    };
    /** @description Response containing the created archive details */
    CreateArchiveResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the created archive
       */
      archiveId: string;
      /** @description Namespace that was archived */
      namespace: string;
      /**
       * Format: uuid
       * @description Asset ID in Asset Service
       */
      bundleAssetId?: string;
      /** @description Number of documents in the archive */
      documentCount?: number;
      /** @description Total size of the archive in bytes */
      sizeBytes?: number;
      /**
       * Format: date-time
       * @description Timestamp when the archive was created
       */
      createdAt?: string;
      /** @description Git commit hash if namespace is bound */
      commitHash?: string | null;
    };
    /** @description Request to list available archives for a namespace */
    ListArchivesRequest: {
      /** @description Documentation namespace to list archives for */
      namespace: string;
      /**
       * @description Maximum number of archives to return
       * @default 20
       */
      limit: number;
      /**
       * @description Number of archives to skip
       * @default 0
       */
      offset: number;
    };
    /** @description Response containing a paginated list of archives */
    ListArchivesResponse: {
      /** @description List of archives for the namespace */
      archives: components['schemas']['ArchiveInfo'][];
      /** @description Total number of archives */
      total: number;
    };
    /** @description Archive metadata including size and document count */
    ArchiveInfo: {
      /**
       * Format: uuid
       * @description Unique identifier of the archive
       */
      archiveId: string;
      /** @description Namespace the archive belongs to */
      namespace: string;
      /**
       * Format: uuid
       * @description Asset ID in Asset Service
       */
      bundleAssetId?: string;
      /** @description Description of the archive */
      description?: string | null;
      /** @description Number of documents in the archive */
      documentCount?: number;
      /** @description Total size of the archive in bytes */
      sizeBytes?: number;
      /** @description Git commit hash if namespace was bound at archive time */
      commitHash?: string | null;
      /**
       * Format: date-time
       * @description Timestamp when the archive was created
       */
      createdAt: string;
      /**
       * @description Owner of this archive. NOT a session ID.
       *     Contains either an accountId (UUID format) for user-initiated archives
       *     or a service name for service-initiated archives.
       */
      owner?: string;
    };
    /** @description Request to restore documents from an archive */
    RestoreArchiveRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the archive to restore
       */
      archiveId: string;
      /** @description If not provided, restores to original namespace */
      targetNamespace?: string;
    };
    /** @description Response containing restore operation results */
    RestoreArchiveResponse: {
      /** @description Namespace documents were restored to */
      namespace: string;
      /** @description Number of documents restored from archive */
      documentsRestored: number;
      /** @description Number of existing documents deleted before restore */
      previousDocumentsDeleted?: number;
    };
    /** @description Request to permanently delete an archive */
    DeleteArchiveRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the archive to delete
       */
      archiveId: string;
    };
    /** @description Response confirming archive deletion */
    DeleteArchiveResponse: {
      /** @description Whether the archive was successfully deleted */
      deleted: boolean;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  viewDocumentBySlug: {
    parameters: {
      query?: {
        /** @description Documentation namespace (defaults to bannou) */
        ns?: string;
      };
      header?: never;
      path: {
        /** @description Document slug within namespace */
        slug: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description HTML documentation page (returns ContentResult) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Document not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  rawDocumentBySlug: {
    parameters: {
      query?: {
        /** @description Documentation namespace (defaults to bannou) */
        ns?: string;
      };
      header?: never;
      path: {
        /** @description Document slug within namespace */
        slug: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Raw markdown content */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/markdown': string;
        };
      };
      /** @description Document not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryDocumentation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryDocumentationRequest'];
      };
    };
    responses: {
      /** @description Search results with voice-friendly summaries */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryDocumentationResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetDocumentRequest'];
      };
    };
    responses: {
      /** @description Document content */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetDocumentResponse'];
        };
      };
      /** @description Document not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchDocumentation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SearchDocumentationRequest'];
      };
    };
    responses: {
      /** @description Matching documents */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SearchDocumentationResponse'];
        };
      };
    };
  };
  listDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDocumentsRequest'];
      };
    };
    responses: {
      /** @description Document list */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListDocumentsResponse'];
        };
      };
    };
  };
  suggestRelatedTopics: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SuggestRelatedRequest'];
      };
    };
    responses: {
      /** @description Related topics */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SuggestRelatedResponse'];
        };
      };
    };
  };
  createDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateDocumentRequest'];
      };
    };
    responses: {
      /** @description Document created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateDocumentResponse'];
        };
      };
      /** @description Document with same slug already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateDocumentRequest'];
      };
    };
    responses: {
      /** @description Document updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateDocumentResponse'];
        };
      };
      /** @description Document not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteDocumentRequest'];
      };
    };
    responses: {
      /** @description Document moved to trashcan */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteDocumentResponse'];
        };
      };
      /** @description Document not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  recoverDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RecoverDocumentRequest'];
      };
    };
    responses: {
      /** @description Document recovered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RecoverDocumentResponse'];
        };
      };
      /** @description Trashcan entry not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Conflict with existing document */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  bulkUpdateDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkUpdateRequest'];
      };
    };
    responses: {
      /** @description Bulk update results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkUpdateResponse'];
        };
      };
    };
  };
  bulkDeleteDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkDeleteRequest'];
      };
    };
    responses: {
      /** @description Bulk delete results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkDeleteResponse'];
        };
      };
    };
  };
  importDocumentation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ImportDocumentationRequest'];
      };
    };
    responses: {
      /** @description Import results (may include partial failures) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ImportDocumentationResponse'];
        };
      };
    };
  };
  listTrashcan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListTrashcanRequest'];
      };
    };
    responses: {
      /** @description Trashcan contents */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListTrashcanResponse'];
        };
      };
    };
  };
  purgeTrashcan: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PurgeTrashcanRequest'];
      };
    };
    responses: {
      /** @description Purge results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PurgeTrashcanResponse'];
        };
      };
    };
  };
  getNamespaceStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetNamespaceStatsRequest'];
      };
    };
    responses: {
      /** @description Namespace statistics */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['NamespaceStatsResponse'];
        };
      };
    };
  };
  bindRepository: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BindRepositoryRequest'];
      };
    };
    responses: {
      /** @description Repository binding created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BindRepositoryResponse'];
        };
      };
      /** @description Invalid request (malformed URL, invalid branch) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Namespace already bound to a repository */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  unbindRepository: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnbindRepositoryRequest'];
      };
    };
    responses: {
      /** @description Repository binding removed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UnbindRepositoryResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  syncRepository: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SyncRepositoryRequest'];
      };
    };
    responses: {
      /** @description Sync completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SyncRepositoryResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Sync already in progress */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRepositoryStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RepositoryStatusRequest'];
      };
    };
    responses: {
      /** @description Repository binding status */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RepositoryStatusResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRepositoryBindings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRepositoryBindingsRequest'];
      };
    };
    responses: {
      /** @description List of repository bindings */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListRepositoryBindingsResponse'];
        };
      };
    };
  };
  updateRepositoryBinding: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateRepositoryBindingRequest'];
      };
    };
    responses: {
      /** @description Repository binding updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateRepositoryBindingResponse'];
        };
      };
      /** @description No binding found for namespace */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createDocumentationArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateArchiveResponse'];
        };
      };
      /** @description Namespace not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listDocumentationArchives: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListArchivesRequest'];
      };
    };
    responses: {
      /** @description List of archives */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListArchivesResponse'];
        };
      };
    };
  };
  restoreDocumentationArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RestoreArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive restored */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RestoreArchiveResponse'];
        };
      };
      /** @description Archive not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteDocumentationArchive: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteArchiveRequest'];
      };
    };
    responses: {
      /** @description Archive deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteArchiveResponse'];
        };
      };
      /** @description Archive not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
