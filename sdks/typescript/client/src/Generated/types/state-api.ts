/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/state/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get state value by key */
    post: operations['getState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/state/save': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Save state value */
    post: operations['saveState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/state/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Delete state value */
    post: operations['deleteState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/state/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Query state (MySQL JSON queries or Redis with search enabled) */
    post: operations['queryState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/state/bulk-get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Bulk get multiple keys */
    post: operations['bulkGetState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/state/list-stores': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** List configured state stores */
    post: operations['listStores'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to retrieve a single state value by key from a state store */
    GetStateRequest: {
      /** @description Name of the state store */
      storeName: string;
      /** @description Key to retrieve */
      key: string;
    };
    /** @description Response containing a retrieved state value with its metadata and ETag */
    GetStateResponse: {
      /** @description The stored value (null if not found) */
      value?: Record<string, never> | null;
      /** @description ETag for optimistic concurrency */
      etag?: string | null;
      /** @description Metadata about the state entry including timestamps and version */
      metadata?: components['schemas']['StateMetadata'];
    };
    /** @description Request to save a state value to a state store with optional TTL and consistency settings */
    SaveStateRequest: {
      /** @description Name of the state store */
      storeName: string;
      /** @description Key to save */
      key: string;
      /** @description Value to store */
      value: Record<string, never>;
      /** @description Optional settings for the save operation including TTL and consistency */
      options?: components['schemas']['StateOptions'];
    };
    /** @description Response from a save operation containing the new ETag */
    SaveStateResponse: {
      /** @description New ETag after save */
      etag?: string;
    };
    /** @description Request to delete a state value by key from a state store */
    DeleteStateRequest: {
      /** @description Name of the state store */
      storeName: string;
      /** @description Key to delete */
      key: string;
    };
    /** @description Response from a delete operation indicating whether the key was removed */
    DeleteStateResponse: {
      /** @description Whether the key was deleted (false if not found) */
      deleted?: boolean;
    };
    /** @description Configuration options for state save operations including TTL, consistency level, and optimistic concurrency */
    StateOptions: {
      /** @description TTL in seconds (Redis only) */
      ttl?: number | null;
      /**
       * @description Consistency level
       * @default strong
       * @enum {string}
       */
      consistency: 'strong' | 'eventual';
      /** @description Optimistic concurrency check - save fails if ETag mismatch */
      etag?: string | null;
    };
    /** @description Metadata associated with a state entry including creation time, last update time, and version */
    StateMetadata: {
      /**
       * Format: date-time
       * @description When the state was created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When the state was last updated
       */
      updatedAt?: string | null;
      /** @description Version number for optimistic concurrency */
      version?: number;
    };
    /** @description Request to query state entries with filtering, sorting, and pagination support for MySQL and Redis backends */
    QueryStateRequest: {
      /** @description Name of the state store (MySQL or Redis with search enabled) */
      storeName: string;
      /**
       * @description Query conditions for MySQL JSON queries. Multiple conditions are combined with AND.
       *     For Redis search, use indexName and query properties instead.
       */
      conditions?: components['schemas']['QueryCondition'][] | null;
      /**
       * @description Redis search index name. Defaults to "{storeName}-idx".
       *     Only used for Redis stores with search enabled.
       */
      indexName?: string | null;
      /**
       * @description RedisSearch query string (e.g., "@name:John", "@age:[18 +inf]", "*").
       *     Defaults to "*" (match all). Only used for Redis stores with search enabled.
       */
      query?: string | null;
      /** @description Sort order (first field only is used) (null for default ordering) */
      sort?: components['schemas']['SortField'][] | null;
      /**
       * @description Page number (0-indexed)
       * @default 0
       */
      page: number;
      /**
       * @description Items per page (max 1000)
       * @default 100
       */
      pageSize: number;
    };
    /** @description Specifies a field and direction for sorting query results */
    SortField: {
      /** @description Field name to sort by (JSON path for MySQL, field name for Redis) */
      field?: string;
      /**
       * @description Sort direction
       * @default asc
       * @enum {string}
       */
      order: 'asc' | 'desc';
    };
    /** @description A single query condition for MySQL JSON queries */
    QueryCondition: {
      /** @description JSON path to query (e.g., "$.name", "$.address.city", "$.tags[0]") */
      path: string;
      /** @description Comparison operator to use for the condition */
      operator?: components['schemas']['QueryOperator'];
      /** @description Value to compare against. Not required for exists/notExists operators. */
      value?: unknown;
    };
    /**
     * @description Comparison operator for query conditions
     * @default equals
     * @enum {string}
     */
    QueryOperator:
      | 'equals'
      | 'notEquals'
      | 'greaterThan'
      | 'greaterThanOrEqual'
      | 'lessThan'
      | 'lessThanOrEqual'
      | 'contains'
      | 'startsWith'
      | 'endsWith'
      | 'in'
      | 'exists'
      | 'notExists'
      | 'fullText';
    /** @description Response containing paginated query results with total count information */
    QueryStateResponse: {
      /** @description Query results */
      results?: Record<string, never>[];
      /** @description Total matching items (for pagination) */
      totalCount?: number;
      /** @description Current page number */
      page?: number;
      /** @description Items per page */
      pageSize?: number;
    };
    /** @description Request to retrieve multiple state values by key in a single operation */
    BulkGetStateRequest: {
      /** @description Name of the state store */
      storeName: string;
      /** @description Keys to retrieve */
      keys: string[];
    };
    /** @description Response containing the results of a bulk get operation for multiple keys */
    BulkGetStateResponse: {
      /** @description Results for each key */
      items?: components['schemas']['BulkStateItem'][];
    };
    /** @description A single item result from a bulk get operation including the key, value, ETag, and found status */
    BulkStateItem: {
      /** @description The key */
      key?: string;
      /** @description The value (null if not found) */
      value?: Record<string, never> | null;
      /** @description ETag for this item */
      etag?: string | null;
      /** @description Whether the key was found */
      found?: boolean;
    };
    /** @description Optional filters for store listing (empty object returns all) */
    ListStoresRequest: {
      /**
       * @description Filter stores by backend type
       * @enum {string|null}
       */
      backendFilter?: 'redis' | 'mysql' | null;
      /**
       * @description Include key counts (may be slow for large stores)
       * @default false
       */
      includeStats: boolean;
    };
    /** @description Response containing the list of configured state stores */
    ListStoresResponse: {
      /** @description List of configured stores */
      stores?: components['schemas']['StoreInfo'][];
    };
    /** @description Information about a configured state store including its name, backend type, and optional key count */
    StoreInfo: {
      /** @description Store name */
      name?: string;
      /**
       * @description Backend type
       * @enum {string}
       */
      backend?: 'redis' | 'mysql';
      /** @description Number of keys (only if includeStats=true) */
      keyCount?: number | null;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  getState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetStateRequest'];
      };
    };
    responses: {
      /** @description State value retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetStateResponse'];
        };
      };
      /** @description Key not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  saveState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveStateRequest'];
      };
    };
    responses: {
      /** @description State saved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveStateResponse'];
        };
      };
    };
  };
  deleteState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteStateRequest'];
      };
    };
    responses: {
      /** @description State deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteStateResponse'];
        };
      };
    };
  };
  queryState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryStateRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryStateResponse'];
        };
      };
      /** @description Query not supported (Redis store without search enabled) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Store not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  bulkGetState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkGetStateRequest'];
      };
    };
    responses: {
      /** @description Bulk results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkGetStateResponse'];
        };
      };
    };
  };
  listStores: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['ListStoresRequest'];
      };
    };
    responses: {
      /** @description List of stores */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListStoresResponse'];
        };
      };
    };
  };
}
