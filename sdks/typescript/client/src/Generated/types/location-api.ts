/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/location/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get location by ID */
    post: operations['getLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-by-code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get location by code and realm
     * @description Retrieve a location using its unique code within a specific realm
     */
    post: operations['getLocationByCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List locations with filtering
     * @description Retrieve locations with optional realm, parent, and type filtering
     */
    post: operations['listLocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-by-realm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all locations in a realm (primary query pattern)
     * @description Returns all locations within a specific realm, optionally filtered by
     *     location type and parent. This is the primary access pattern for
     *     realm-scoped location queries.
     */
    post: operations['listLocationsByRealm'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-by-parent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get child locations for a parent location
     * @description Retrieve all locations that have the specified location as their parent.
     *     Useful for getting all cities in a region, all buildings in a city, etc.
     */
    post: operations['listLocationsByParent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/list-root': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get root locations in a realm
     * @description Returns all top-level locations in a realm (locations with no parent).
     *     These are typically regions or major areas within the realm.
     */
    post: operations['listRootLocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-ancestors': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all ancestors of a location
     * @description Returns the full ancestry chain from the specified location up to the
     *     root location (parentLocationId=null). For example, for a specific building
     *     might return [district, city, region].
     */
    post: operations['getLocationAncestors'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/get-descendants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all descendants of a location
     * @description Returns all locations that are descendants of the specified location
     *     (direct children, grandchildren, etc.). Useful for finding all places
     *     within a region or city.
     */
    post: operations['getLocationDescendants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create new location */
    post: operations['createLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update location */
    post: operations['updateLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/set-parent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Set or change the parent of a location
     * @description Update a location's parent, moving it in the hierarchy.
     *     Validates that:
     *     - New parent exists and is in the same realm
     *     - No circular reference would be created
     *     - Updates depth for location and all descendants
     */
    post: operations['setLocationParent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/remove-parent': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove parent from a location (make it a root location)
     * @description Remove the parent of a location, making it a top-level root location
     *     within its realm. Updates depth for location and all descendants.
     */
    post: operations['removeLocationParent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete location
     * @description Hard delete a location. This will fail if the location:
     *     - Has child locations (must delete or reparent children first)
     *     - Is still referenced by other entities
     *     For safe removal, first deprecate the location, remove all children,
     *     then delete.
     */
    post: operations['deleteLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/deprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deprecate a location
     * @description Soft-delete a location by marking it as deprecated.
     *     Deprecated locations:
     *     - Remain queryable for historical data
     *     - Cannot be used for placing new entities
     *     - Can be hard-deleted after all references are removed
     */
    post: operations['deprecateLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/undeprecate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restore a deprecated location
     * @description Remove the deprecated status from a location, making it
     *     available for entity placement again.
     */
    post: operations['undeprecateLocation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/exists': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Check if location exists and is active
     * @description Fast validation endpoint for other services to check location validity.
     *     Returns true if location exists and is not deprecated, false otherwise.
     */
    post: operations['locationExists'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/location/seed': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Seed locations from configuration
     * @description Idempotent operation to seed locations from provided data.
     *     Creates locations that don't exist, optionally updates existing locations.
     *     Processes locations in dependency order (parents before children).
     *     Typically called at service startup with YAML-defined location hierarchies.
     */
    post: operations['seedLocations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * @description Type classification for locations
     * @enum {string}
     */
    LocationType:
      | 'CONTINENT'
      | 'REGION'
      | 'CITY'
      | 'DISTRICT'
      | 'BUILDING'
      | 'ROOM'
      | 'LANDMARK'
      | 'WILDERNESS'
      | 'DUNGEON'
      | 'OTHER';
    /** @description Request to retrieve a location by its unique identifier */
    GetLocationRequest: {
      /**
       * Format: uuid
       * @description Unique identifier of the location
       */
      locationId: string;
    };
    /** @description Request to retrieve a location by its code within a specific realm */
    GetLocationByCodeRequest: {
      /** @description Unique code for the location within the realm */
      code: string;
      /**
       * Format: uuid
       * @description Realm ID to scope the code lookup
       */
      realmId: string;
    };
    /** @description Request to list locations within a realm with optional type and deprecation filtering */
    ListLocationsRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query (required - locations are partitioned by realm)
       */
      realmId: string;
      /** @description Filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all locations within a specific realm with optional filtering */
    ListLocationsByRealmRequest: {
      /**
       * Format: uuid
       * @description Realm ID to query
       */
      realmId: string;
      /** @description Optional type filter */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all child locations of a specified parent location */
    ListLocationsByParentRequest: {
      /**
       * Format: uuid
       * @description ID of the parent location
       */
      parentLocationId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to list all top-level locations (without parents) in a realm */
    ListRootLocationsRequest: {
      /**
       * Format: uuid
       * @description Realm ID to get root locations for
       */
      realmId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to retrieve the full ancestry chain of a location up to the root */
    GetLocationAncestorsRequest: {
      /**
       * Format: uuid
       * @description The location to get ancestors for
       */
      locationId: string;
    };
    /** @description Request to retrieve all descendants of a location (children, grandchildren, etc.) */
    GetLocationDescendantsRequest: {
      /**
       * Format: uuid
       * @description The location to get descendants for
       */
      locationId: string;
      /** @description Optional filter by location type */
      locationType?: components['schemas']['LocationType'] | null;
      /** @description Maximum depth of descendants to return (null = all) */
      maxDepth?: number | null;
      /**
       * @description Whether to include deprecated locations in the response
       * @default false
       */
      includeDeprecated: boolean;
      /**
       * @description Page number for pagination (1-indexed)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to create a new location within a realm */
    CreateLocationRequest: {
      /** @description Unique code for the location within the realm */
      code: string;
      /** @description Display name for the location */
      name: string;
      /** @description Description of the location */
      description?: string | null;
      /**
       * Format: uuid
       * @description Realm this location belongs to
       */
      realmId: string;
      /** @description Type classification for this location */
      locationType: components['schemas']['LocationType'];
      /**
       * Format: uuid
       * @description Parent location ID for hierarchy (null for root locations)
       */
      parentLocationId?: string | null;
      /** @description Additional metadata for the location (JSON) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update an existing location's properties */
    UpdateLocationRequest: {
      /**
       * Format: uuid
       * @description ID of the location to update
       */
      locationId: string;
      /** @description Display name for the location */
      name?: string | null;
      /** @description Description of the location */
      description?: string | null;
      /** @description Type of location */
      locationType?: components['schemas']['LocationType'] | null;
      /** @description Additional metadata */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to set or change a location's parent in the hierarchy */
    SetLocationParentRequest: {
      /**
       * Format: uuid
       * @description ID of the location to update
       */
      locationId: string;
      /**
       * Format: uuid
       * @description ID of the new parent location (must be in same realm)
       */
      parentLocationId: string;
    };
    /** @description Request to remove a location's parent, making it a root location */
    RemoveLocationParentRequest: {
      /**
       * Format: uuid
       * @description ID of the location to make a root location
       */
      locationId: string;
    };
    /** @description Request to permanently delete a location from the system */
    DeleteLocationRequest: {
      /**
       * Format: uuid
       * @description ID of the location to delete
       */
      locationId: string;
    };
    /** @description Request to soft-delete a location by marking it as deprecated */
    DeprecateLocationRequest: {
      /**
       * Format: uuid
       * @description ID of the location to deprecate
       */
      locationId: string;
      /** @description Optional reason for deprecation (for audit purposes) */
      reason?: string | null;
    };
    /** @description Request to restore a deprecated location back to active status */
    UndeprecateLocationRequest: {
      /**
       * Format: uuid
       * @description ID of the location to restore
       */
      locationId: string;
    };
    /** @description Request to check if a location exists and is active */
    LocationExistsRequest: {
      /**
       * Format: uuid
       * @description ID of the location to validate
       */
      locationId: string;
    };
    /** @description Response indicating whether a location exists and its active status */
    LocationExistsResponse: {
      /** @description Whether the location exists */
      exists: boolean;
      /** @description Whether the location is active (false if deprecated or not found) */
      isActive: boolean;
      /**
       * Format: uuid
       * @description The location ID if found
       */
      locationId?: string | null;
      /**
       * Format: uuid
       * @description The realm ID if location found
       */
      realmId?: string | null;
    };
    /** @description Request to seed multiple locations from configuration data */
    SeedLocationsRequest: {
      /** @description List of locations to seed (processed in dependency order) */
      locations: components['schemas']['SeedLocation'][];
      /**
       * @description Whether to update locations that already exist
       * @default false
       */
      updateExisting: boolean;
    };
    /** @description Location data for seeding operations, using codes instead of IDs for references */
    SeedLocation: {
      /** @description Unique code for the location within realm */
      code: string;
      /** @description Display name */
      name: string;
      /** @description Description */
      description?: string | null;
      /** @description Code of the realm (resolved during seeding) */
      realmCode: string;
      /** @description Type classification for this location */
      locationType: components['schemas']['LocationType'];
      /** @description Code of the parent location (resolved during seeding) */
      parentLocationCode?: string | null;
      /** @description Additional metadata for the location (JSON) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Complete location data returned from API operations */
    LocationResponse: {
      /**
       * Format: uuid
       * @description Unique identifier for the location
       */
      locationId: string;
      /**
       * Format: uuid
       * @description Realm this location belongs to
       */
      realmId: string;
      /** @description Unique code for the location within its realm */
      code: string;
      /** @description Display name of the location */
      name: string;
      /** @description Optional description of the location */
      description?: string | null;
      /** @description Type classification of the location */
      locationType: components['schemas']['LocationType'];
      /**
       * Format: uuid
       * @description Parent location ID (null for root locations)
       */
      parentLocationId?: string | null;
      /** @description Depth in hierarchy (0 for root locations) */
      depth: number;
      /** @description Whether this location is deprecated and cannot be used */
      isDeprecated: boolean;
      /**
       * Format: date-time
       * @description Timestamp when this location was deprecated
       */
      deprecatedAt?: string | null;
      /** @description Optional reason for deprecation */
      deprecationReason?: string | null;
      /** @description Additional metadata for the location (JSON) */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description Timestamp when the location was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the location was last updated
       */
      updatedAt: string;
    };
    /** @description Paginated list of locations with metadata for navigation */
    LocationListResponse: {
      /** @description List of locations matching the query */
      locations: components['schemas']['LocationResponse'][];
      /** @description Total number of locations matching the query (across all pages) */
      totalCount: number;
      /** @description Current page number (1-indexed) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more pages after the current page */
      hasNextPage?: boolean;
      /** @description Whether there are pages before the current page */
      hasPreviousPage?: boolean;
    };
    /** @description Summary of a seed operation including counts of created, updated, and skipped locations */
    SeedLocationsResponse: {
      /** @description Number of new locations created */
      created: number;
      /** @description Number of existing locations updated */
      updated: number;
      /** @description Number of locations skipped (already exist, updateExisting=false) */
      skipped: number;
      /** @description List of error messages for locations that failed to seed */
      errors: string[];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  getLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationRequest'];
      };
    };
    responses: {
      /** @description Location retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocationByCode: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationByCodeRequest'];
      };
    };
    responses: {
      /** @description Location retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listLocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsRequest'];
      };
    };
    responses: {
      /** @description Locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  listLocationsByRealm: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsByRealmRequest'];
      };
    };
    responses: {
      /** @description Locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  listLocationsByParent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListLocationsByParentRequest'];
      };
    };
    responses: {
      /** @description Child locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Parent location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRootLocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRootLocationsRequest'];
      };
    };
    responses: {
      /** @description Root locations retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
    };
  };
  getLocationAncestors: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationAncestorsRequest'];
      };
    };
    responses: {
      /** @description Ancestors retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getLocationDescendants: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetLocationDescendantsRequest'];
      };
    };
    responses: {
      /** @description Descendants retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationListResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateLocationRequest'];
      };
    };
    responses: {
      /** @description Location created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Invalid location data or parent realm mismatch */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Location with this code already exists in this realm */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateLocationRequest'];
      };
    };
    responses: {
      /** @description Location updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Invalid update data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  setLocationParent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SetLocationParentRequest'];
      };
    };
    responses: {
      /** @description Parent updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Invalid parent (different realm or circular reference) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Location or parent not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  removeLocationParent: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RemoveLocationParentRequest'];
      };
    };
    responses: {
      /** @description Parent removed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteLocationRequest'];
      };
    };
    responses: {
      /** @description Location deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete - location has children or is in use */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deprecateLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeprecateLocationRequest'];
      };
    };
    responses: {
      /** @description Location deprecated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Location is already deprecated */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  undeprecateLocation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UndeprecateLocationRequest'];
      };
    };
    responses: {
      /** @description Location restored successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location is not deprecated */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Location not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  locationExists: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LocationExistsRequest'];
      };
    };
    responses: {
      /** @description Validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationExistsResponse'];
        };
      };
    };
  };
  seedLocations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SeedLocationsRequest'];
      };
    };
    responses: {
      /** @description Seed operation completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SeedLocationsResponse'];
        };
      };
      /** @description Invalid seed data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
