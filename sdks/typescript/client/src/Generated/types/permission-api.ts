/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/permission/capabilities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get available API methods for session
     * @description Returns compiled list of methods available to this session
     */
    post: operations['getCapabilities'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/permission/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate specific API access for session
     * @description Fast O(1) validation using Redis lookup
     */
    post: operations['validateApiAccess'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/permission/register-service': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register or update service permission matrix
     * @description Updates Redis with ServiceID -> State -> Role -> Methods structure
     */
    post: operations['registerServicePermissions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/permission/update-session-state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update session state for specific service
     * @description Updates SessionID -> ServiceID -> State and recompiles permissions
     */
    post: operations['updateSessionState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/permission/update-session-role': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update session role (affects all services)
     * @description Updates SessionID -> Role and recompiles all service permissions
     */
    post: operations['updateSessionRole'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/permission/clear-session-state': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Clear session state for specific service
     * @description Removes state for a specific service from the session and recompiles permissions.
     *     If states list is provided, only clears if current state matches one of the values.
     *     If states list is empty or not provided, clears the state unconditionally.
     */
    post: operations['clearSessionState'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/permission/get-session-info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get complete session information
     * @description Returns current states, role, and compiled permissions
     */
    post: operations['getSessionInfo'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/permission/services/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all registered services
     * @description Returns list of all services that have registered their permissions.
     *     This endpoint is used by testers to wait for service readiness - a service
     *     appearing in this list means it has completed startup and registered its
     *     API permissions, indicating it's ready to handle requests.
     *
     *     For service-to-service calls (via mesh), this endpoint is unrestricted.
     *     For client calls through WebSocket/Connect, only admin users can access it.
     */
    post: operations['getRegisteredServices'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to list registered services (empty body allowed for listing all) */
    ListServicesRequest: {
      /** @description Optional filter by service ID prefix */
      serviceIdFilter?: string | null;
    };
    /** @description Request to retrieve available API methods for a session */
    CapabilityRequest: {
      /**
       * Format: uuid
       * @description Session ID for lookup in Redis
       */
      sessionId: string;
      /** @description Optional filter for specific services (null for all services) */
      serviceIds?: string[] | null;
    };
    /** @description Response containing the compiled permissions for a session */
    CapabilityResponse: {
      /**
       * Format: uuid
       * @description Session ID that was queried
       */
      sessionId: string;
      /** @description Map of ServiceID -> List of available methods */
      permissions: {
        [key: string]: string[];
      };
      /**
       * Format: date-time
       * @description When these permissions were compiled
       */
      generatedAt?: string;
    };
    /** @description Request to validate whether a session has access to a specific API method */
    ValidationRequest: {
      /**
       * Format: uuid
       * @description Session ID to validate access for
       */
      sessionId: string;
      /** @description Target service ID */
      serviceId: string;
      /** @description Method name being accessed */
      method: string;
    };
    /** @description Response indicating whether access to a specific API method is permitted */
    ValidationResponse: {
      /** @description Whether access is permitted */
      allowed: boolean;
      /**
       * Format: uuid
       * @description Session ID that was validated
       */
      sessionId: string;
      /** @description Reason for denial (if applicable) */
      reason?: string;
    };
    /** @description Complete permission matrix for a service defining state-role-method access rules */
    ServicePermissionMatrix: {
      /** @description Unique service identifier */
      serviceId: string;
      /** @description Human-readable service name (null to use serviceId) */
      serviceName?: string | null;
      /** @description Map of State -> Role -> Methods structure */
      permissions: {
        [key: string]: components['schemas']['StatePermissions'];
      };
      /** @description Service API version for change tracking */
      version?: string;
    };
    /**
     * @description Map of Role -> List of Methods for this state
     * @example {
     *       "user": [
     *         "ListGameSessions",
     *         "GetGameSession"
     *       ],
     *       "admin": [
     *         "ListGameSessions",
     *         "GetGameSession",
     *         "CreateGameSession"
     *       ]
     *     }
     */
    StatePermissions: {
      [key: string]: string[];
    };
    /** @description Response from registering or updating a service permission matrix */
    RegistrationResponse: {
      /** @description Service ID that was registered */
      serviceId: string;
      /** @description Success or error message */
      message?: string;
      /** @description Whether registration was successful */
      registered?: boolean;
      /** @description Number of sessions that had permissions recompiled */
      affectedSessions: number;
      /**
       * Format: date-time
       * @description Timestamp when permissions were recompiled
       */
      recompiledAt?: string;
    };
    /** @description Request to update a session's state for a specific service */
    SessionStateUpdate: {
      /**
       * Format: uuid
       * @description Session ID to update state for
       */
      sessionId: string;
      /** @description Service whose state is changing for this session */
      serviceId: string;
      /** @description New state value (lobby, in_game, etc.) */
      newState: string;
      /** @description Previous state value (null for initial state) */
      previousState?: string | null;
      /** @description Optional context data (null if none) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to update a session's role affecting permissions across all services */
    SessionRoleUpdate: {
      /**
       * Format: uuid
       * @description Session ID to update role for
       */
      sessionId: string;
      /** @description New role (user, admin, etc.) */
      newRole: string;
      /** @description Previous role (null for initial role) */
      previousRole?: string | null;
    };
    /** @description Request to clear a session's state for a specific service or all services */
    ClearSessionStateRequest: {
      /**
       * Format: uuid
       * @description Session ID to clear state from
       */
      sessionId: string;
      /** @description Service whose state should be cleared (null to clear all services) */
      serviceId?: string | null;
      /**
       * @description Optional list of state values to match. If provided, only clears if
       *     current state matches one of these values. If empty or not provided,
       *     clears the state unconditionally.
       */
      states?: string[] | null;
    };
    /** @description Response from updating a session's state or role with recompiled permissions */
    SessionUpdateResponse: {
      /**
       * Format: uuid
       * @description Session ID that was updated
       */
      sessionId: string;
      /** @description Success or error message */
      message?: string;
      /** @description Whether compiled permissions actually changed */
      permissionsChanged: boolean;
      /** @description Updated ServiceID -> Methods if permissions changed */
      newPermissions?: {
        [key: string]: string[];
      };
      /**
       * Format: date-time
       * @description Timestamp when the session was updated
       */
      updatedAt?: string;
    };
    /** @description Request to retrieve complete information about a session */
    SessionInfoRequest: {
      /**
       * Format: uuid
       * @description Session ID to retrieve information for
       */
      sessionId: string;
    };
    /** @description Complete session information including role, states, and compiled permissions */
    SessionInfo: {
      /**
       * Format: uuid
       * @description Session ID being queried
       */
      sessionId: string;
      /** @description Current session role */
      role: string;
      /** @description Map of ServiceID -> Current State */
      states: {
        [key: string]: string;
      };
      /** @description Map of ServiceID -> List of available methods */
      permissions: {
        [key: string]: string[];
      };
      /** @description Map of ServiceID -> List of available methods */
      compiledPermissions?: {
        [key: string]: string[];
      };
      /** @description Permission version number */
      version?: number;
      /**
       * Format: date-time
       * @description When permissions were last recompiled
       */
      lastUpdated?: string;
    };
    /** @description Response containing list of all services that have registered their permissions */
    RegisteredServicesResponse: {
      /** @description List of all registered services */
      services: components['schemas']['RegisteredServiceInfo'][];
      /**
       * Format: date-time
       * @description When this response was generated
       */
      timestamp: string;
    };
    /** @description Information about a registered service including its ID, version, and endpoint count */
    RegisteredServiceInfo: {
      /** @description Unique service identifier */
      serviceId: string;
      /** @description Human-readable service name */
      serviceName?: string;
      /** @description Service API version */
      version?: string;
      /**
       * Format: date-time
       * @description When the service registered its permissions
       */
      registeredAt: string;
      /** @description Number of API endpoints registered by this service */
      endpointCount: number;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  getCapabilities: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CapabilityRequest'];
      };
    };
    responses: {
      /** @description Session capabilities retrieved from Redis */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CapabilityResponse'];
        };
      };
    };
  };
  validateApiAccess: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidationRequest'];
      };
    };
    responses: {
      /** @description Permission validation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ValidationResponse'];
        };
      };
    };
  };
  registerServicePermissions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ServicePermissionMatrix'];
      };
    };
    responses: {
      /** @description Service permissions registered and sessions recompiled */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegistrationResponse'];
        };
      };
    };
  };
  updateSessionState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SessionStateUpdate'];
      };
    };
    responses: {
      /** @description Session state updated and permissions recompiled */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SessionUpdateResponse'];
        };
      };
    };
  };
  updateSessionRole: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SessionRoleUpdate'];
      };
    };
    responses: {
      /** @description Session role updated and all permissions recompiled */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SessionUpdateResponse'];
        };
      };
    };
  };
  clearSessionState: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ClearSessionStateRequest'];
      };
    };
    responses: {
      /** @description Session state cleared and permissions recompiled */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SessionUpdateResponse'];
        };
      };
    };
  };
  getSessionInfo: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SessionInfoRequest'];
      };
    };
    responses: {
      /** @description Complete session information */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SessionInfo'];
        };
      };
    };
  };
  getRegisteredServices: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListServicesRequest'];
      };
    };
    responses: {
      /** @description List of registered services */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisteredServicesResponse'];
        };
      };
    };
  };
}
