/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/assets/upload/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request upload URL for a new asset
     * @description Generate a pre-signed URL for uploading a new asset directly to storage.
     *     For large files (>50MB), returns multipart upload configuration.
     */
    post: operations['requestUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/upload/complete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Mark upload as complete, trigger processing
     * @description Called after the client has uploaded the file to the pre-signed URL.
     *     Triggers the asset processing pipeline (texture conversion, model validation, etc.)
     *     and emits completion events via WebSocket.
     */
    post: operations['completeUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get asset metadata and download URL
     * @description Retrieve asset metadata and generate a pre-signed download URL.
     *     Specify version to download a specific version, or omit for latest.
     */
    post: operations['getAsset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete an asset
     * @description Delete an asset from storage. If versionId is specified, only that version is deleted.
     *     If versionId is omitted, all versions are deleted.
     */
    post: operations['deleteAsset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/list-versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all versions of an asset
     * @description Retrieve version history for an asset with pagination.
     *     Includes version IDs, creation timestamps, and archive status.
     */
    post: operations['listAssetVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Search assets by tags, type, or realm
     * @description Search assets using various filters with pagination.
     *     All filters are optional and combine with AND logic.
     */
    post: operations['searchAssets'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create asset bundle from multiple assets
     * @description Create a .bannou bundle containing multiple assets.
     *     For large bundles, processing is delegated to the processing pool.
     *     Completion notification sent via WebSocket event.
     */
    post: operations['createBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get bundle manifest and download URL
     * @description Retrieve bundle metadata and generate a pre-signed download URL.
     *     Supports both native .bannou format and ZIP conversion (cached).
     */
    post: operations['getBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/upload/request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request upload URL for a pre-made bundle
     * @description Upload a pre-built bundle (.bannou or .zip format).
     *     After upload, the bundle undergoes validation before registration.
     */
    post: operations['requestBundleUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/metabundle/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create metabundle from source bundles
     * @description Compose a metabundle by extracting and repackaging assets from multiple
     *     source bundles. The resulting metabundle is a complete physical copy with
     *     provenance metadata tracking the source bundles.
     *
     *     Assets are deduplicated by content hash. If the same asset ID exists in
     *     multiple source bundles with different content hashes, the request fails
     *     with conflict details.
     */
    post: operations['createMetabundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/job/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get async metabundle job status
     * @description Poll the status of an async metabundle creation job.
     *     Use the jobId returned from createMetabundle when status was 'queued'.
     *
     *     Clients can either poll this endpoint or wait for the
     *     MetabundleCreationCompleteEvent via WebSocket for completion notification.
     */
    post: operations['getJobStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/job/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel an async metabundle job
     * @description Cancel a pending or processing metabundle creation job.
     *     Jobs that are already completed (ready or failed) cannot be cancelled.
     *
     *     Successfully cancelled jobs will emit a MetabundleCreationCompleteEvent
     *     with status 'cancelled' via WebSocket.
     */
    post: operations['cancelJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/resolve': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Compute optimal bundles for requested assets
     * @description Given a list of asset IDs, compute the optimal set of bundles to download
     *     to obtain all requested assets with minimal transfers.
     *
     *     The algorithm uses greedy set-cover optimization:
     *     1. Find all bundles containing requested assets
     *     2. Select bundles that cover the most uncovered assets
     *     3. Prefer metabundles when coverage is equal (tie-breaker)
     *     4. Include standalone assets for any remaining unresolved IDs
     *
     *     Returns pre-signed download URLs for all selected bundles and assets.
     */
    post: operations['resolveBundles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/query/by-asset': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Find all bundles containing a specific asset
     * @description Query the reverse index to find all bundles (source and metabundle)
     *     that contain a specific asset ID. Useful for understanding asset
     *     distribution and debugging resolution issues.
     */
    post: operations['queryBundlesByAsset'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update bundle metadata
     * @description Update metadata for an existing bundle (name, description, tags).
     *     Does not modify bundle contents - for that, create a new bundle.
     *
     *     Increments the bundle version and records the change in version history.
     *     Only the bundle owner or admin can update.
     */
    post: operations['updateBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Soft-delete a bundle
     * @description Soft-delete a bundle, marking it as deleted but retaining data
     *     for the configured retention period (default 30 days).
     *
     *     Deleted bundles are excluded from resolution and queries by default.
     *     Use permanent=true for immediate, unrecoverable deletion (admin only).
     *
     *     Only the bundle owner or admin can delete.
     */
    post: operations['deleteBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/restore': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Restore a soft-deleted bundle
     * @description Restore a bundle that was soft-deleted, making it active again.
     *     Can only restore bundles within their retention period.
     *
     *     Only the bundle owner or admin can restore.
     */
    post: operations['restoreBundle'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query bundles with advanced filters
     * @description Query bundles with flexible filtering options including:
     *     - Tag matching (exact, exists, not exists)
     *     - Status filtering (active, deleted)
     *     - Date range filtering
     *     - Name search (contains)
     *     - Owner filtering
     *     - Realm and bundle type filtering
     *
     *     Supports pagination and sorting.
     */
    post: operations['queryBundles'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bundles/list-versions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List version history for a bundle
     * @description Get the version history for a bundle, showing all metadata changes
     *     over time. Each version record includes:
     *     - Version number
     *     - When the change was made
     *     - Who made the change
     *     - What changed
     *     - Optional reason for the change
     *
     *     The current version's full metadata snapshot is always included.
     */
    post: operations['listBundleVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/assets/bulk-get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Batch asset metadata lookup
     * @description Retrieve metadata for multiple assets in a single request.
     *     Optionally includes pre-signed download URLs.
     *     Maximum 100 asset IDs per request.
     */
    post: operations['bulkGetAssets'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * @description Type classification for assets
     * @enum {string}
     */
    AssetType: 'texture' | 'model' | 'audio' | 'behavior' | 'bundle' | 'prefab' | 'other';
    /**
     * @description Game realm the asset belongs to
     * @enum {string}
     */
    Realm: 'omega' | 'arcadia' | 'fantasia' | 'shared';
    /**
     * @description Asset processing pipeline status
     * @enum {string}
     */
    ProcessingStatus: 'pending' | 'processing' | 'complete' | 'failed';
    /**
     * @description Compression algorithm for bundles
     * @enum {string}
     */
    CompressionType: 'lz4' | 'lzma' | 'none';
    /**
     * @description Bundle file format
     * @enum {string}
     */
    BundleFormat: 'bannou' | 'zip';
    /**
     * @description Bundle category:
     *     - source: Original bundle (uploaded or server-created from assets)
     *     - metabundle: Composed from other bundles server-side
     * @enum {string}
     */
    BundleType: 'source' | 'metabundle';
    /** @description Request to initiate an asset upload and receive a pre-signed URL */
    UploadRequest: {
      /**
       * @description Owner of this asset operation. NOT a session ID.
       *     For user-initiated uploads: the accountId (UUID format).
       *     For service-initiated uploads: the service name (e.g., "behavior", "orchestrator").
       */
      owner: string;
      /** @description Original filename with extension */
      filename: string;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description MIME content type (e.g., image/png, model/gltf-binary) */
      contentType: string;
      /** @description Optional metadata for asset categorization */
      metadata?: components['schemas']['AssetMetadataInput'];
    };
    /** @description Response containing pre-signed URL and configuration for uploading an asset */
    UploadResponse: {
      /**
       * Format: uuid
       * @description Unique upload session identifier
       */
      uploadId: string;
      /**
       * Format: uri
       * @description Pre-signed URL for uploading the file
       */
      uploadUrl: string;
      /**
       * Format: date-time
       * @description When the upload URL expires
       */
      expiresAt: string;
      /** @description Configuration for multipart uploads if file size requires it */
      multipart?: components['schemas']['MultipartConfig'];
      /** @description Headers the client must include when uploading to the pre-signed URL */
      requiredHeaders?: {
        [key: string]: string;
      };
    };
    /** @description Request to finalize an upload and trigger asset processing */
    CompleteUploadRequest: {
      /**
       * Format: uuid
       * @description Upload session ID from requestUpload
       */
      uploadId: string;
      /** @description For multipart uploads - ETags of completed parts (null for single-file uploads) */
      parts?: components['schemas']['CompletedPart'][] | null;
    };
    /** @description Information about a completed part in a multipart upload */
    CompletedPart: {
      /** @description Part number (1-based) */
      partNumber: number;
      /** @description ETag returned from part upload */
      etag: string;
    };
    /** @description Configuration for multipart uploads of large files */
    MultipartConfig: {
      /** @description Whether multipart upload is required for this file size */
      required?: boolean;
      /** @description Size of each part in bytes */
      partSize?: number;
      /** @description Maximum number of parts */
      maxParts?: number;
      /** @description Pre-signed URLs for each part of the multipart upload */
      uploadUrls?: components['schemas']['PartUploadInfo'][] | null;
    };
    /** @description Upload information for a single part in a multipart upload */
    PartUploadInfo: {
      /** @description Part number (1-based) */
      partNumber: number;
      /**
       * Format: uri
       * @description Pre-signed URL for uploading this part
       */
      uploadUrl: string;
      /**
       * Format: int64
       * @description Minimum size for this part
       */
      minSize?: number;
      /**
       * Format: int64
       * @description Maximum size for this part
       */
      maxSize?: number;
    };
    /** @description User-provided metadata for asset categorization */
    AssetMetadataInput: {
      /** @description Type classification for the asset */
      assetType?: components['schemas']['AssetType'];
      /** @description Game realm the asset belongs to */
      realm?: components['schemas']['Realm'];
      /** @description Searchable tags for the asset */
      tags?: string[];
    };
    /** @description Complete asset metadata including system-generated fields */
    AssetMetadata: {
      /** @description Unique asset identifier */
      assetId: string;
      /** @description SHA256 hash of file contents */
      contentHash: string;
      /** @description Original filename */
      filename: string;
      /** @description MIME content type */
      contentType: string;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description Type classification for the asset */
      assetType: components['schemas']['AssetType'];
      /** @description Game realm the asset belongs to */
      realm: components['schemas']['Realm'];
      /** @description Searchable tags for the asset */
      tags: string[];
      /** @description Current status of asset processing pipeline */
      processingStatus: components['schemas']['ProcessingStatus'];
      /**
       * @description Whether the asset is in cold/archival storage
       * @default false
       */
      isArchived: boolean;
      /**
       * Format: date-time
       * @description Timestamp when the asset was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Timestamp when the asset was last updated
       */
      updatedAt: string;
    };
    /** @description Request to retrieve asset metadata and download URL */
    GetAssetRequest: {
      /** @description Asset identifier */
      assetId: string;
      /**
       * @description Version ID or 'latest'
       * @default latest
       */
      version: string;
    };
    /** @description Asset metadata with optional pre-signed download URL */
    AssetWithDownloadUrl: {
      /** @description Unique asset identifier */
      assetId: string;
      /** @description Version identifier for this specific asset version */
      versionId: string;
      /**
       * Format: uri
       * @description Pre-signed download URL (only populated when requested)
       */
      downloadUrl?: string | null;
      /**
       * Format: date-time
       * @description When the download URL expires (only populated when requested)
       */
      expiresAt?: string | null;
      /**
       * Format: int64
       * @description File size in bytes
       */
      size: number;
      /** @description SHA256 hash of file contents */
      contentHash: string;
      /** @description MIME content type */
      contentType: string;
      /** @description Complete asset metadata */
      metadata: components['schemas']['AssetMetadata'];
    };
    /** @description Request to delete an asset from storage */
    DeleteAssetRequest: {
      /** @description Asset identifier to delete */
      assetId: string;
      /** @description Specific version to delete. If omitted, all versions are deleted. */
      versionId?: string | null;
    };
    /** @description Response confirming asset deletion */
    DeleteAssetResponse: {
      /** @description Deleted asset identifier */
      assetId: string;
      /** @description Number of versions deleted */
      versionsDeleted: number;
    };
    /** @description Request to list all versions of an asset with pagination */
    ListVersionsRequest: {
      /** @description Asset identifier to list versions for */
      assetId: string;
      /**
       * @description Maximum number of versions to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of versions to skip for pagination
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated list of asset versions */
    AssetVersionList: {
      /** @description Asset identifier */
      assetId: string;
      /** @description List of asset versions */
      versions: components['schemas']['AssetVersion'][];
      /** @description Total number of versions available */
      total: number;
      /** @description Maximum number of versions returned per page */
      limit: number;
      /** @description Number of versions skipped */
      offset: number;
    };
    /** @description Metadata for a specific version of an asset */
    AssetVersion: {
      /** @description Unique version identifier */
      versionId: string;
      /**
       * Format: date-time
       * @description Timestamp when this version was created
       */
      createdAt: string;
      /**
       * Format: int64
       * @description File size in bytes for this version
       */
      size: number;
      /** @description Whether this version is in cold storage */
      isArchived: boolean;
    };
    /** @description Search criteria for filtering assets with pagination */
    AssetSearchRequest: {
      /** @description Filter by tags (assets must have all specified tags) (null to skip tag filtering) */
      tags?: string[] | null;
      /** @description Filter by asset type */
      assetType: components['schemas']['AssetType'];
      /** @description Filter by game realm */
      realm: components['schemas']['Realm'];
      /** @description MIME content type filter (null to skip content type filtering) */
      contentType?: string | null;
      /**
       * @description Maximum number of results to return
       * @default 50
       */
      limit: number;
      /**
       * @description Number of results to skip for pagination
       * @default 0
       */
      offset: number;
    };
    /** @description Paginated results from an asset search query */
    AssetSearchResult: {
      /** @description List of matching assets */
      assets: components['schemas']['AssetMetadata'][];
      /** @description Total number of matching assets */
      total: number;
      /** @description Maximum number of results returned per page */
      limit: number;
      /** @description Number of results skipped */
      offset: number;
    };
    /** @description Request to create a new asset bundle from multiple assets */
    CreateBundleRequest: {
      /**
       * @description Owner of this bundle. NOT a session ID.
       *     For user-initiated bundles: the accountId (UUID format).
       *     For service-initiated bundles: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Unique bundle identifier */
      bundleId: string;
      /**
       * @description Bundle version string
       * @default 1.0.0
       */
      version: string;
      /**
       * @description Game realm this bundle belongs to.
       *     Defaults to 'shared' if not specified.
       */
      realm?: components['schemas']['Realm'] | null;
      /** @description List of asset IDs to include in the bundle */
      assetIds: string[];
      /** @description Compression algorithm to use for the bundle */
      compression?: components['schemas']['CompressionType'];
      /** @description Custom metadata for the bundle (null if none) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Response with bundle creation status and estimated size */
    CreateBundleResponse: {
      /** @description Unique bundle identifier */
      bundleId: string;
      /**
       * @description Bundle creation status
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed';
      /**
       * Format: int64
       * @description Estimated bundle size in bytes
       */
      estimatedSize: number;
    };
    /** @description Request to retrieve bundle metadata and download URL */
    GetBundleRequest: {
      /** @description Bundle identifier to retrieve */
      bundleId: string;
      /** @description Desired download format (bannou or zip) */
      format?: components['schemas']['BundleFormat'];
    };
    /** @description Bundle metadata combined with a pre-signed download URL */
    BundleWithDownloadUrl: {
      /** @description Unique bundle identifier */
      bundleId: string;
      /** @description Bundle version string */
      version: string;
      /**
       * Format: uri
       * @description Pre-signed URL for downloading the bundle
       */
      downloadUrl: string;
      /** @description Format of the downloadable bundle */
      format: components['schemas']['BundleFormat'];
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Number of assets contained in the bundle */
      assetCount: number;
      /** @description True if ZIP format was served from conversion cache */
      fromCache: boolean;
    };
    /** @description Request to upload a pre-built asset bundle file */
    BundleUploadRequest: {
      /**
       * @description Owner of this bundle upload. NOT a session ID.
       *     For user-initiated uploads: the accountId (UUID format).
       *     For service-initiated uploads: the service name (e.g., "orchestrator").
       */
      owner: string;
      /** @description Must end with .bannou or .zip */
      filename: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Optional preview of bundle manifest for validation */
      manifestPreview?: components['schemas']['BundleManifestPreview'] | null;
    };
    /** @description Preview of bundle manifest for validation */
    BundleManifestPreview: {
      /** @description Bundle identifier from the manifest */
      bundleId: string;
      /** @description Bundle version from the manifest */
      version: string;
      /** @description Number of assets declared in the manifest */
      assetCount: number;
    };
    /** @description Provenance reference to a source bundle used in metabundle creation */
    SourceBundleReference: {
      /** @description Source bundle identifier */
      bundleId: string;
      /** @description Version of source bundle at composition time */
      version: string;
      /** @description Asset IDs contributed from this source bundle */
      assetIds: string[];
      /** @description Hash of source bundle at composition time (for integrity verification) */
      contentHash: string;
    };
    /** @description Describes a conflict when the same asset ID has different content hashes */
    AssetConflict: {
      /** @description The conflicting asset identifier */
      assetId: string;
      /** @description Bundles with conflicting versions of this asset */
      conflictingBundles: components['schemas']['ConflictingBundleEntry'][];
    };
    /** @description A bundle entry in an asset conflict */
    ConflictingBundleEntry: {
      /** @description Bundle containing this version */
      bundleId: string;
      /** @description Content hash of asset in this bundle */
      contentHash: string;
    };
    /**
     * @description Request to create a metabundle from source bundles and/or standalone assets.
     *     At least one of sourceBundleIds or standaloneAssetIds must be provided.
     *     This enables packaging behaviors/scripts with 3D assets as a complete unit.
     */
    CreateMetabundleRequest: {
      /** @description Unique identifier for the new metabundle */
      metabundleId: string;
      /**
       * @description Source bundle IDs to pull assets from. Can cherry-pick specific
       *     assets using assetFilter, or include all if assetFilter is null.
       */
      sourceBundleIds?: string[] | null;
      /**
       * @description Individual asset IDs (not in bundles) to include directly.
       *     Useful for including behaviors, scripts, or metadata files
       *     alongside bundled 3D assets.
       */
      standaloneAssetIds?: string[] | null;
      /**
       * @description Metabundle version string
       * @default 1.0.0
       */
      version: string;
      /**
       * @description Owner of this metabundle. NOT a session ID.
       *     For user-initiated: the accountId (UUID format).
       *     For service-initiated: the service name.
       */
      owner: string;
      /** @description Game realm for this metabundle */
      realm: components['schemas']['Realm'];
      /** @description Human-readable description */
      description?: string | null;
      /**
       * @description Optional subset of asset IDs to include FROM SOURCE BUNDLES.
       *     If null, all assets from source bundles are included.
       *     Standalone assets are always included regardless of this filter.
       */
      assetFilter?: string[] | null;
      /** @description Custom metadata for the metabundle */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Response from metabundle creation.
     *     For synchronous creation (small jobs): status=ready with downloadUrl.
     *     For async creation (large jobs): status=queued with jobId for polling.
     */
    CreateMetabundleResponse: {
      /** @description Metabundle identifier */
      metabundleId: string;
      /**
       * Format: uuid
       * @description Job ID for async processing. Only present when status is 'queued' or 'processing'.
       *     Use /bundles/job/status to poll for completion, or wait for
       *     MetabundleCreationCompleteEvent via WebSocket.
       */
      jobId?: string | null;
      /**
       * @description Creation status.
       *     - queued: Job accepted for async processing (poll with jobId)
       *     - processing: Job is actively running
       *     - ready: Metabundle created and available for download
       *     - failed: Creation failed (see conflicts for details)
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed';
      /**
       * Format: uri
       * @description Pre-signed download URL (only present when status is 'ready')
       */
      downloadUrl?: string | null;
      /** @description Number of assets in the metabundle */
      assetCount: number;
      /** @description Number of standalone assets included directly (not from bundles) */
      standaloneAssetCount?: number | null;
      /**
       * Format: int64
       * @description Total size in bytes
       */
      sizeBytes: number;
      /** @description Provenance data for the metabundle */
      sourceBundles?: components['schemas']['SourceBundleReference'][];
      /** @description Present if creation failed due to asset conflicts */
      conflicts?: components['schemas']['AssetConflict'][] | null;
    };
    /** @description Request to get the status of an async metabundle creation job */
    GetJobStatusRequest: {
      /**
       * Format: uuid
       * @description Job ID from the createMetabundle response
       */
      jobId: string;
    };
    /**
     * @description Status of an async metabundle creation job.
     *     When status is 'ready', the response includes the full metabundle details.
     */
    GetJobStatusResponse: {
      /**
       * Format: uuid
       * @description Job identifier
       */
      jobId: string;
      /** @description Metabundle identifier being created */
      metabundleId: string;
      /**
       * @description Current job status.
       *     - queued: Waiting for processing resources
       *     - processing: Actively being processed
       *     - ready: Completed successfully
       *     - failed: Creation failed
       *     - cancelled: Job was cancelled
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed' | 'cancelled';
      /** @description Progress percentage (0-100) when status is 'processing' */
      progress?: number | null;
      /**
       * Format: uri
       * @description Pre-signed download URL (only when status is 'ready')
       */
      downloadUrl?: string | null;
      /** @description Number of assets in metabundle (when ready) */
      assetCount?: number | null;
      /** @description Number of standalone assets included (when ready) */
      standaloneAssetCount?: number | null;
      /**
       * Format: int64
       * @description Total size in bytes (when ready)
       */
      sizeBytes?: number | null;
      /** @description Provenance data (when ready) */
      sourceBundles?: components['schemas']['SourceBundleReference'][] | null;
      /** @description Error code (when status is 'failed') */
      errorCode?: string | null;
      /** @description Human-readable error description (when status is 'failed') */
      errorMessage?: string | null;
      /**
       * Format: date-time
       * @description When the job was created
       */
      createdAt?: string | null;
      /**
       * Format: date-time
       * @description When the job was last updated
       */
      updatedAt?: string | null;
      /**
       * Format: int64
       * @description Total processing time in milliseconds (when complete)
       */
      processingTimeMs?: number | null;
    };
    /** @description Request to cancel an async metabundle creation job */
    CancelJobRequest: {
      /**
       * Format: uuid
       * @description Job ID from the createMetabundle response
       */
      jobId: string;
    };
    /** @description Result of job cancellation attempt */
    CancelJobResponse: {
      /**
       * Format: uuid
       * @description Job identifier
       */
      jobId: string;
      /** @description Whether the job was successfully cancelled */
      cancelled: boolean;
      /**
       * @description Current job status after cancellation attempt
       * @enum {string}
       */
      status: 'queued' | 'processing' | 'ready' | 'failed' | 'cancelled';
      /** @description Additional context about the cancellation result */
      message?: string | null;
    };
    /** @description Request to resolve optimal bundle downloads for requested assets */
    ResolveBundlesRequest: {
      /** @description Platform asset IDs to resolve */
      assetIds: string[];
      /** @description Game realm to search within */
      realm: components['schemas']['Realm'];
      /**
       * @description Prefer metabundles when coverage is equal
       * @default true
       */
      preferMetabundles: boolean;
      /**
       * @description Include standalone assets not in any bundle
       * @default true
       */
      includeStandalone: boolean;
      /** @description Maximum number of bundles to return (optimization limit) */
      maxBundles?: number | null;
    };
    /** @description Optimal bundle set for requested assets */
    ResolveBundlesResponse: {
      /** @description Bundles to download */
      bundles: components['schemas']['ResolvedBundle'][];
      /** @description Individual assets to download */
      standaloneAssets: components['schemas']['ResolvedAsset'][];
      /** @description Coverage statistics */
      coverage: components['schemas']['CoverageAnalysis'];
      /** @description Asset IDs that couldn't be found (null if all resolved) */
      unresolved?: string[] | null;
    };
    /** @description A bundle selected for download in resolution */
    ResolvedBundle: {
      /** @description Bundle identifier */
      bundleId: string;
      /** @description Whether source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle version */
      version?: string | null;
      /**
       * Format: uri
       * @description Pre-signed download URL
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Bundle file size in bytes
       */
      size: number;
      /** @description Which of the requested assets this bundle provides */
      assetsProvided: string[];
    };
    /** @description A standalone asset selected for download */
    ResolvedAsset: {
      /** @description Asset identifier */
      assetId: string;
      /**
       * Format: uri
       * @description Pre-signed download URL
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Asset file size in bytes
       */
      size: number;
      /** @description SHA256 hash of asset content */
      contentHash?: string | null;
    };
    /** @description Statistics about asset resolution coverage */
    CoverageAnalysis: {
      /** @description Total number of assets requested */
      totalRequested: number;
      /** @description Assets resolved through bundle downloads */
      resolvedViaBundles: number;
      /** @description Assets resolved as standalone downloads */
      resolvedStandalone: number;
      /** @description Assets that could not be found */
      unresolvedCount: number;
      /**
       * Format: float
       * @description Ratio of assets provided to bundle downloads (higher is better)
       */
      bundleEfficiency?: number | null;
    };
    /** @description Request to find bundles containing a specific asset */
    QueryBundlesByAssetRequest: {
      /** @description Platform asset ID to search for */
      assetId: string;
      /** @description Game realm to search within */
      realm: components['schemas']['Realm'];
      /** @description Filter by bundle type (optional, null for all types) */
      bundleType?: components['schemas']['BundleType'] | null;
      /**
       * @description Maximum results to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Bundles containing the requested asset */
    QueryBundlesByAssetResponse: {
      /** @description The queried asset ID */
      assetId: string;
      /** @description Bundles containing this asset */
      bundles: components['schemas']['BundleSummary'][];
      /** @description Total matching bundles */
      total: number;
      /** @description Page size */
      limit: number;
      /** @description Page offset */
      offset: number;
    };
    /** @description Summary information about a bundle */
    BundleSummary: {
      /** @description Bundle identifier */
      bundleId: string;
      /** @description Source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle version */
      version: string;
      /** @description Number of assets in bundle */
      assetCount: number;
      /**
       * Format: int64
       * @description Bundle file size
       */
      sizeBytes?: number | null;
      /** @description Game realm */
      realm: components['schemas']['Realm'];
      /**
       * Format: date-time
       * @description When the bundle was created
       */
      createdAt?: string | null;
    };
    /** @description Request to retrieve metadata for multiple assets */
    BulkGetAssetsRequest: {
      /** @description Asset IDs to retrieve (max 100) */
      assetIds: string[];
      /**
       * @description Whether to generate pre-signed download URLs
       * @default false
       */
      includeDownloadUrls: boolean;
    };
    /** @description Batch asset metadata response */
    BulkGetAssetsResponse: {
      /** @description Found assets with metadata */
      assets: components['schemas']['AssetWithDownloadUrl'][];
      /** @description Asset IDs that weren't found */
      notFound: string[];
    };
    /**
     * @description Bundle processing status:
     *     - pending: Bundle creation is pending/queued
     *     - processing: Bundle is being processed
     *     - ready: Bundle is ready for download
     *     - failed: Bundle creation failed
     * @enum {string}
     */
    BundleStatus: 'pending' | 'processing' | 'ready' | 'failed';
    /**
     * @description Bundle lifecycle status:
     *     - active: Bundle is available for use
     *     - deleted: Bundle has been soft-deleted (within retention period)
     *     - processing: Bundle is being processed (metabundle creation)
     * @enum {string}
     */
    BundleLifecycle: 'active' | 'deleted' | 'processing';
    /** @description Complete metadata for an asset bundle (API response model) */
    BundleInfo: {
      /** @description Unique bundle identifier */
      bundleId: string;
      /** @description Whether source or metabundle */
      bundleType: components['schemas']['BundleType'];
      /** @description Bundle content version string */
      version: string;
      /** @description Metadata version number (increments on metadata changes) */
      metadataVersion: number;
      /** @description Human-readable bundle name */
      name?: string | null;
      /** @description Bundle description */
      description?: string | null;
      /** @description Owner account ID or service name */
      owner: string;
      /** @description Game realm this bundle belongs to */
      realm: components['schemas']['Realm'];
      /** @description Key-value tags for categorization and filtering */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Bundle lifecycle status */
      status: components['schemas']['BundleLifecycle'];
      /** @description Number of assets in the bundle */
      assetCount: number;
      /**
       * Format: int64
       * @description Bundle file size in bytes (null if not yet calculated)
       */
      sizeBytes?: number | null;
      /**
       * Format: date-time
       * @description When the bundle was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description When the bundle metadata was last updated
       */
      updatedAt?: string | null;
      /**
       * Format: date-time
       * @description When the bundle was soft-deleted (null if active)
       */
      deletedAt?: string | null;
    };
    /** @description Request to update bundle metadata */
    UpdateBundleRequest: {
      /** @description Bundle identifier to update */
      bundleId: string;
      /** @description New bundle name (null to leave unchanged) */
      name?: string | null;
      /** @description New bundle description (null to leave unchanged) */
      description?: string | null;
      /** @description Replace all tags with these (null to leave unchanged) */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Tags to add (merged with existing) */
      addTags?: {
        [key: string]: string;
      } | null;
      /** @description Tag keys to remove */
      removeTags?: string[] | null;
      /** @description Optional reason for the update (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle update operation */
    UpdateBundleResponse: {
      /** @description Updated bundle identifier */
      bundleId: string;
      /** @description New version number after update */
      version: number;
      /** @description Version number before update */
      previousVersion: number;
      /** @description List of changes made (e.g., "name changed", "tag 'env' added") */
      changes: string[];
      /**
       * Format: date-time
       * @description When the update occurred
       */
      updatedAt?: string;
    };
    /** @description Request to delete a bundle */
    DeleteBundleRequest: {
      /** @description Bundle identifier to delete */
      bundleId: string;
      /**
       * @description If true, permanently delete (admin only). If false, soft-delete.
       * @default false
       */
      permanent: boolean;
      /** @description Optional reason for deletion (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle deletion */
    DeleteBundleResponse: {
      /** @description Deleted bundle identifier */
      bundleId: string;
      /**
       * @description Deletion status
       * @enum {string}
       */
      status: 'deleted' | 'permanently_deleted';
      /**
       * Format: date-time
       * @description When the bundle was deleted
       */
      deletedAt: string;
      /**
       * Format: date-time
       * @description When soft-deleted bundle will be permanently removed (null for permanent deletes)
       */
      retentionUntil?: string | null;
    };
    /** @description Request to restore a soft-deleted bundle */
    RestoreBundleRequest: {
      /** @description Bundle identifier to restore */
      bundleId: string;
      /** @description Optional reason for restoration (recorded in version history) */
      reason?: string | null;
    };
    /** @description Result of bundle restoration */
    RestoreBundleResponse: {
      /** @description Restored bundle identifier */
      bundleId: string;
      /** @description Current bundle status (should be "active") */
      status: string;
      /**
       * Format: date-time
       * @description When the bundle was restored
       */
      restoredAt: string;
      /** @description Version number the bundle was restored from */
      restoredFromVersion: number;
    };
    /** @description Advanced bundle query with filters */
    QueryBundlesRequest: {
      /** @description Filter by exact tag key-value matches */
      tags?: {
        [key: string]: string;
      } | null;
      /** @description Filter bundles that have these tag keys (any value) */
      tagExists?: string[] | null;
      /** @description Filter bundles that do NOT have these tag keys */
      tagNotExists?: string[] | null;
      /** @description Filter by lifecycle status (null for active only by default) */
      status?: components['schemas']['BundleLifecycle'] | null;
      /**
       * Format: date-time
       * @description Filter bundles created after this time
       */
      createdAfter?: string | null;
      /**
       * Format: date-time
       * @description Filter bundles created before this time
       */
      createdBefore?: string | null;
      /** @description Filter bundles with name containing this string (case-insensitive) */
      nameContains?: string | null;
      /** @description Filter by bundle owner account ID */
      owner?: string | null;
      /** @description Filter by realm */
      realm?: components['schemas']['Realm'] | null;
      /** @description Filter by bundle type (source or metabundle) */
      bundleType?: components['schemas']['BundleType'] | null;
      /**
       * @description Field to sort by (default created_at)
       * @enum {string|null}
       */
      sortField?: 'created_at' | 'updated_at' | 'name' | 'size' | null;
      /**
       * @description Sort order (default desc)
       * @enum {string|null}
       */
      sortOrder?: 'asc' | 'desc' | null;
      /**
       * @description Maximum results to return (max 1000)
       * @default 100
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Include soft-deleted bundles in results
       * @default false
       */
      includeDeleted: boolean;
    };
    /** @description Bundle query results */
    QueryBundlesResponse: {
      /** @description Matching bundles */
      bundles: components['schemas']['BundleInfo'][];
      /** @description Total number of matching bundles (for pagination) */
      totalCount: number;
      /** @description Page size used */
      limit: number;
      /** @description Page offset used */
      offset: number;
    };
    /** @description Request to list bundle version history */
    ListBundleVersionsRequest: {
      /** @description Bundle identifier to get history for */
      bundleId: string;
      /**
       * @description Maximum versions to return
       * @default 50
       */
      limit: number;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
    };
    /** @description Bundle version history */
    ListBundleVersionsResponse: {
      /** @description Bundle identifier */
      bundleId: string;
      /** @description Current version number */
      currentVersion: number;
      /** @description Version history records (newest first) */
      versions: components['schemas']['BundleVersionRecord'][];
      /** @description Total number of versions */
      totalCount: number;
    };
    /** @description A single version record in bundle history */
    BundleVersionRecord: {
      /** @description Version number */
      version: number;
      /**
       * Format: date-time
       * @description When this version was created
       */
      createdAt: string;
      /** @description Account ID that made the change */
      createdBy: string;
      /** @description List of changes in this version */
      changes: string[];
      /** @description Reason provided for the change */
      reason?: string | null;
      /** @description Full metadata snapshot at this version (only for current version) */
      snapshot?: components['schemas']['BundleInfo'] | null;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  requestUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UploadRequest'];
      };
    };
    responses: {
      /** @description Upload URL generated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UploadResponse'];
        };
      };
      /** @description Invalid request (filename, size, or content_type) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authenticated */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Insufficient permissions */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  completeUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CompleteUploadRequest'];
      };
    };
    responses: {
      /** @description Asset created, processing started */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetMetadata'];
        };
      };
      /** @description Invalid upload_id or missing parts for multipart */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Upload session not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAssetRequest'];
      };
    };
    responses: {
      /** @description Asset metadata with download URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetWithDownloadUrl'];
        };
      };
      /** @description Asset not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteAssetRequest'];
      };
    };
    responses: {
      /** @description Asset deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteAssetResponse'];
        };
      };
      /** @description Insufficient permissions */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Asset not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listAssetVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListVersionsRequest'];
      };
    };
    responses: {
      /** @description List of asset versions */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetVersionList'];
        };
      };
      /** @description Asset not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  searchAssets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AssetSearchRequest'];
      };
    };
    responses: {
      /** @description Matching assets */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssetSearchResult'];
        };
      };
    };
  };
  createBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle created immediately (small bundles) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateBundleResponse'];
        };
      };
      /** @description Bundle creation queued (large bundles) */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateBundleResponse'];
        };
      };
      /** @description Invalid asset_ids or bundle_id */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle manifest with download URL */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BundleWithDownloadUrl'];
        };
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  requestBundleUpload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BundleUploadRequest'];
      };
    };
    responses: {
      /** @description Upload URL generated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UploadResponse'];
        };
      };
      /** @description Invalid filename or size */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createMetabundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateMetabundleRequest'];
      };
    };
    responses: {
      /** @description Metabundle created or queued for creation */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateMetabundleResponse'];
        };
      };
      /** @description Invalid request or asset conflicts detected */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description One or more source bundles not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Metabundle ID already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getJobStatus: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetJobStatusRequest'];
      };
    };
    responses: {
      /** @description Job status retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetJobStatusResponse'];
        };
      };
      /** @description Job not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  cancelJob: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CancelJobRequest'];
      };
    };
    responses: {
      /** @description Job cancellation result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CancelJobResponse'];
        };
      };
      /** @description Job not found or expired */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Job cannot be cancelled (already completed) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  resolveBundles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResolveBundlesRequest'];
      };
    };
    responses: {
      /** @description Resolution complete with download URLs */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResolveBundlesResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryBundlesByAsset: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBundlesByAssetRequest'];
      };
    };
    responses: {
      /** @description Bundles containing the asset */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBundlesByAssetResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  updateBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UpdateBundleResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to update this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found or deleted */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deleteBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle deleted successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteBundleResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to delete this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  restoreBundle: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RestoreBundleRequest'];
      };
    };
    responses: {
      /** @description Bundle restored successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RestoreBundleResponse'];
        };
      };
      /** @description Invalid request or bundle not in deleted state */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to restore this bundle */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle not found or permanently deleted */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bundle retention period has expired */
      410: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  queryBundles: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QueryBundlesRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QueryBundlesResponse'];
        };
      };
      /** @description Invalid query parameters */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listBundleVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListBundleVersionsRequest'];
      };
    };
    responses: {
      /** @description Version history */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListBundleVersionsResponse'];
        };
      };
      /** @description Bundle not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  bulkGetAssets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkGetAssetsRequest'];
      };
    };
    responses: {
      /** @description Asset metadata retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkGetAssetsResponse'];
        };
      };
      /** @description Invalid request or too many asset IDs */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
