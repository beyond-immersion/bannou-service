/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/relationship/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a new relationship between two entities
     * @description Creates a relationship between two entities.
     *     Duplicate relationships (same entities + same type) are prevented.
     *     Relationships can be re-created after being ended.
     */
    post: operations['createRelationship'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Get a relationship by ID */
    post: operations['getRelationship'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/list-by-entity': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationships for an entity
     * @description Returns all relationships where the specified entity is either
     *     entity1 or entity2. Supports filtering by relationship type,
     *     other entity type, and whether to include ended relationships.
     */
    post: operations['listRelationshipsByEntity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/get-between': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all relationships between two specific entities
     * @description Returns all relationships that exist between two specific entities,
     *     regardless of which is entity1 or entity2.
     */
    post: operations['getRelationshipsBetween'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/list-by-type': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all relationships of a specific type
     * @description Returns all relationships that use a specific relationship type.
     *     Useful for finding all "FRIEND" relationships, for example.
     */
    post: operations['listRelationshipsByType'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update relationship metadata
     * @description Only metadata can be updated. Entity IDs and types cannot be changed.
     */
    post: operations['updateRelationship'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/relationship/end': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * End a relationship
     * @description Marks a relationship as ended with a timestamp.
     *     Ended relationships are preserved for history and can be re-created.
     *     The composite uniqueness key is cleared, allowing new relationships
     *     between the same entities with the same type.
     */
    post: operations['endRelationship'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * @description Type of entity in a relationship.
     *     - CHARACTER: Player-controlled characters
     *     - NPC: Non-player characters
     *     - MONSTER: Hostile or neutral creatures
     *     - ITEM: Physical objects, artifacts, etc.
     *     - LOCATION: Places, regions, buildings
     *     - ORGANIZATION: Guilds, companies, groups
     *     - FACTION: Political or social factions
     *     - REALM: Game realms/worlds
     *     - SOUL: Immortal soul entity for reincarnation chains
     *     - OTHER: Catch-all for future entity types
     * @enum {string}
     */
    EntityType:
      | 'CHARACTER'
      | 'NPC'
      | 'MONSTER'
      | 'ITEM'
      | 'LOCATION'
      | 'ORGANIZATION'
      | 'FACTION'
      | 'REALM'
      | 'SOUL'
      | 'OTHER';
    /** @description Request to create a new relationship between two entities */
    CreateRelationshipRequest: {
      /**
       * Format: uuid
       * @description ID of the first entity in the relationship
       */
      entity1Id: string;
      /** @description Type of the first entity in the relationship */
      entity1Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the second entity in the relationship
       */
      entity2Id: string;
      /** @description Type of the second entity in the relationship */
      entity2Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Relationship type ID (from RelationshipType service)
       */
      relationshipTypeId: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship started
       */
      startedAt: string;
      /** @description Type-specific relationship data (JSON) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to retrieve a specific relationship by its ID */
    GetRelationshipRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship to retrieve
       */
      relationshipId: string;
    };
    /** @description Request to list all relationships for a specific entity with optional filters */
    ListRelationshipsByEntityRequest: {
      /**
       * Format: uuid
       * @description ID of the entity to get relationships for
       */
      entityId: string;
      /** @description Type of the entity to get relationships for */
      entityType: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional filter by relationship type
       */
      relationshipTypeId?: string | null;
      /** @description Optional filter by the other entity's type */
      otherEntityType?: components['schemas']['EntityType'];
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
      /**
       * @description Page number for paginated results (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page (max 100)
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to get all relationships between two specific entities */
    GetRelationshipsBetweenRequest: {
      /**
       * Format: uuid
       * @description ID of the first entity to check relationships for
       */
      entity1Id: string;
      /** @description Type of the first entity */
      entity1Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the second entity to check relationships for
       */
      entity2Id: string;
      /** @description Type of the second entity */
      entity2Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Optional filter by relationship type
       */
      relationshipTypeId?: string | null;
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
    };
    /** @description Request to list all relationships of a specific relationship type */
    ListRelationshipsByTypeRequest: {
      /**
       * Format: uuid
       * @description Relationship type to filter by
       */
      relationshipTypeId: string;
      /** @description Optional filter by entity1 type */
      entity1Type?: components['schemas']['EntityType'];
      /** @description Optional filter by entity2 type */
      entity2Type?: components['schemas']['EntityType'];
      /**
       * @description Include relationships that have ended
       * @default false
       */
      includeEnded: boolean;
      /**
       * @description Page number for paginated results (1-based)
       * @default 1
       */
      page: number;
      /**
       * @description Number of results per page (max 100)
       * @default 20
       */
      pageSize: number;
    };
    /** @description Request to update the metadata or type of an existing relationship */
    UpdateRelationshipRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship to update
       */
      relationshipId: string;
      /**
       * Format: uuid
       * @description Update relationship type (used for type merge migrations)
       */
      relationshipTypeId?: string | null;
      /** @description Updated type-specific relationship data */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /** @description Request to end an existing relationship with an optional timestamp and reason */
    EndRelationshipRequest: {
      /**
       * Format: uuid
       * @description ID of the relationship to end
       */
      relationshipId: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship ended (defaults to now)
       */
      endedAt?: string;
      /** @description Optional reason for ending the relationship */
      reason?: string | null;
    };
    /** @description Complete details of a relationship between two entities */
    RelationshipResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the relationship
       */
      relationshipId: string;
      /**
       * Format: uuid
       * @description ID of the first entity in the relationship
       */
      entity1Id: string;
      /** @description Type of the first entity in the relationship */
      entity1Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description ID of the second entity in the relationship
       */
      entity2Id: string;
      /** @description Type of the second entity in the relationship */
      entity2Type: components['schemas']['EntityType'];
      /**
       * Format: uuid
       * @description Relationship type ID (from RelationshipType service)
       */
      relationshipTypeId: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship started
       */
      startedAt: string;
      /**
       * Format: date-time
       * @description In-game timestamp when relationship ended, null if still active
       */
      endedAt?: string | null;
      /** @description Type-specific relationship data */
      metadata?: {
        [key: string]: unknown;
      } | null;
      /**
       * Format: date-time
       * @description System timestamp when the relationship record was created
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description System timestamp when the relationship record was last updated
       */
      updatedAt?: string | null;
    };
    /** @description Paginated list of relationships with metadata for navigation */
    RelationshipListResponse: {
      /** @description List of relationships matching the query */
      relationships: components['schemas']['RelationshipResponse'][];
      /** @description Total number of relationships matching the query */
      totalCount: number;
      /** @description Current page number (1-based) */
      page: number;
      /** @description Number of results per page */
      pageSize: number;
      /** @description Whether there are more results on the next page */
      hasNextPage?: boolean;
      /** @description Whether there are results on the previous page */
      hasPreviousPage?: boolean;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  createRelationship: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateRelationshipRequest'];
      };
    };
    responses: {
      /** @description Relationship created successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipResponse'];
        };
      };
      /** @description Invalid request (missing fields, invalid entity types) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Relationship already exists between these entities with this type */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRelationship: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipRequest'];
      };
    };
    responses: {
      /** @description Relationship retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipResponse'];
        };
      };
      /** @description Relationship not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listRelationshipsByEntity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipsByEntityRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  getRelationshipsBetween: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRelationshipsBetweenRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  listRelationshipsByType: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListRelationshipsByTypeRequest'];
      };
    };
    responses: {
      /** @description Relationships retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipListResponse'];
        };
      };
    };
  };
  updateRelationship: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateRelationshipRequest'];
      };
    };
    responses: {
      /** @description Relationship updated successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RelationshipResponse'];
        };
      };
      /** @description Relationship not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  endRelationship: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EndRelationshipRequest'];
      };
    };
    responses: {
      /** @description Relationship ended successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Relationship not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
