/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/save-load/slot/create': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create or configure a save slot
     * @description Creates a new save slot or updates configuration of an existing slot.
     *     Slots are auto-created on first save, but pre-creation allows setting
     *     custom configuration (max versions, retention policy, etc.).
     */
    post: operations['CreateSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get slot metadata
     * @description Returns slot configuration and version summary.
     */
    post: operations['GetSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List slots for owner
     * @description Returns all slots owned by the specified entity.
     */
    post: operations['ListSlots'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete slot and all versions
     * @description Permanently deletes a slot and all save versions within it.
     *     This is irreversible. Requires owner access or admin role.
     */
    post: operations['DeleteSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/rename': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Rename a save slot
     * @description Renames an existing slot without affecting its versions or data.
     *     The new name must not already exist for this owner.
     */
    post: operations['RenameSlot'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/slot/bulk-delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete multiple slots at once
     * @description Deletes multiple slots and all their versions in a single operation.
     *     Useful for cleanup operations or account deletion.
     */
    post: operations['BulkDeleteSlots'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/save': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save data to slot
     * @description Creates a new version in the specified slot with the provided data.
     *     If the slot doesn't exist, it's auto-created with default configuration.
     *
     *     Large saves (>1MB by default) are automatically compressed.
     *     Rolling version cleanup is applied based on slot configuration.
     */
    post: operations['Save'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/load': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Load data from slot
     * @description Retrieves save data from the specified slot. By default, loads the
     *     latest version. Optionally specify a version number or checkpoint name.
     */
    post: operations['Load'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/save-delta': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Save incremental changes from base version
     * @description Creates a new version by applying a delta (patch) to a base version.
     *     Significantly reduces storage for large saves with small incremental changes.
     *
     *     Uses JSON Patch (RFC 6902) by default. The implementation is designed to
     *     allow swapping to binary diff algorithms (bsdiff/xdelta) if needed for
     *     specific use cases (e.g., binary game state).
     *
     *     Delta versions store only the patch; full data is reconstructed on load.
     */
    post: operations['SaveDelta'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/load-with-deltas': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Load save reconstructing from delta chain
     * @description Loads save data, automatically reconstructing from delta chain if needed.
     *     Returns the full reconstructed data, not the raw delta.
     *
     *     For performance, the service may cache reconstructed data or collapse
     *     delta chains during background cleanup.
     */
    post: operations['LoadWithDeltas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/collapse-deltas': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Collapse delta chain into full snapshot
     * @description Collapses a chain of delta versions into a single full snapshot.
     *     Useful for reducing load latency or before deleting base versions.
     */
    post: operations['CollapseDeltas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List versions in slot
     * @description Returns all versions in a slot with metadata.
     */
    post: operations['ListVersions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/pin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Pin a version as checkpoint
     * @description Pins a specific version, excluding it from rolling cleanup.
     *     Optionally assigns a checkpoint name for easy retrieval.
     */
    post: operations['PinVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/unpin': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unpin a version
     * @description Removes pin from a version, making it eligible for rolling cleanup.
     */
    post: operations['UnpinVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete specific version
     * @description Permanently deletes a specific version from a slot.
     *     Cannot delete pinned versions; unpin first.
     */
    post: operations['DeleteVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/query': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Query saves with filters
     * @description Search and filter saves across slots. Supports filtering by owner,
     *     category, date range, metadata, and more. Paginated results.
     */
    post: operations['QuerySaves'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/copy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Copy save to different slot or owner
     * @description Copies a save version to a different slot or owner.
     *     Can copy to same owner (different slot) or different owner (with admin).
     */
    post: operations['CopySave'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/export': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Export saves for backup/portability
     * @description Exports one or more slots with all versions as a downloadable archive.
     *     Returns a pre-signed URL to download the export bundle.
     */
    post: operations['ExportSaves'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/import': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Import saves from backup
     * @description Imports saves from a previously exported archive.
     *     Supports conflict resolution strategies for existing slots.
     */
    post: operations['ImportSaves'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify save data integrity
     * @description Verifies the integrity of stored save data by comparing content hash
     *     against the stored SHA-256 hash. Detects corruption or tampering.
     */
    post: operations['VerifyIntegrity'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/version/promote': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Promote old version to latest
     * @description Creates a new version from an existing older version, effectively
     *     "promoting" it to be the latest. Useful for rollback scenarios.
     */
    post: operations['PromoteVersion'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/migrate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Migrate save to new schema version
     * @description Applies migration handlers to upgrade a save from one schema version
     *     to another. Creates a new version with the migrated data.
     */
    post: operations['MigrateSave'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/schema/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register a save data schema
     * @description Registers a JSON schema for validation of save data.
     *     Optionally includes migration handlers from previous versions.
     */
    post: operations['RegisterSchema'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/schema/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List registered schemas
     * @description Returns all registered schemas for a game/namespace.
     */
    post: operations['ListSchemas'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/admin/cleanup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Run cleanup for expired/orphaned saves
     * @description Triggers cleanup of expired versions and orphaned assets.
     *     Normally runs automatically, but can be triggered manually.
     */
    post: operations['AdminCleanup'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/save-load/admin/stats': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get storage statistics
     * @description Returns storage usage statistics by owner, category, etc.
     */
    post: operations['AdminStats'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /**
     * @description Type of entity that owns this save slot
     * @enum {string}
     */
    OwnerType: 'ACCOUNT' | 'CHARACTER' | 'SESSION' | 'REALM';
    /**
     * @description Category of save with predefined behaviors.
     *     QUICK_SAVE: Single-slot fast save, overwritten frequently (max 1 version).
     *     AUTO_SAVE: System-triggered periodic saves (max 5 versions, rolling).
     *     MANUAL_SAVE: User-initiated named saves (max 10 versions, no auto-cleanup).
     *     CHECKPOINT: Progress markers (max 20 versions, rolling).
     *     STATE_SNAPSHOT: Full state captures for debugging (max 3 versions, rolling).
     * @enum {string}
     */
    SaveCategory: 'QUICK_SAVE' | 'AUTO_SAVE' | 'MANUAL_SAVE' | 'CHECKPOINT' | 'STATE_SNAPSHOT';
    /**
     * @description Compression algorithm used for save data
     * @enum {string}
     */
    CompressionType: 'NONE' | 'GZIP' | 'BROTLI';
    /**
     * @description Strategy for handling conflicts during import
     * @enum {string}
     */
    ConflictResolution: 'SKIP' | 'OVERWRITE' | 'RENAME' | 'FAIL';
    /**
     * @description JSON Patch operation per RFC 6902.
     *     Uses JsonPatch.Net library (MIT licensed).
     */
    JsonPatchOperation: {
      /**
       * @description Operation type
       * @enum {string}
       */
      op: 'add' | 'remove' | 'replace' | 'move' | 'copy' | 'test';
      /** @description JSON Pointer to target location */
      path: string;
      /** @description Source path (for move/copy operations) */
      from?: string | null;
      /** @description Value to use (for add/replace/test operations) */
      value?: unknown;
    };
    /** @description Request to create a new save slot for an entity. */
    CreateSlotRequest: {
      /** @description Game identifier for namespace isolation (e.g., "arcadia", "fantasia") */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name (lowercase alphanumeric with hyphens, single char like "q" allowed) */
      slotName: string;
      /** @description Save category determining retention and cleanup behavior */
      category: components['schemas']['SaveCategory'];
      /** @description Override default max versions for this category (null = use category default) */
      maxVersions?: number | null;
      /** @description Days to retain versions (null = indefinite) */
      retentionDays?: number | null;
      /** @description Compression algorithm to use for save data (null = use category default) */
      compressionType?: components['schemas']['CompressionType'] | null;
      /** @description Searchable tags for slot categorization (e.g., "boss-fight", "chapter-3") */
      tags?: string[] | null;
      /** @description Custom key-value metadata for the slot */
      metadata?: {
        [key: string]: string;
      } | null;
    };
    /** @description Request to retrieve metadata for a specific save slot */
    GetSlotRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
    };
    /** @description Request to list all save slots belonging to a specific owner */
    ListSlotsRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns the save slots to list */
      ownerType: components['schemas']['OwnerType'];
      /** @description Optional filter by save category */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * @description Include version count in response
       * @default true
       */
      includeVersionCount: boolean;
    };
    /** @description Request to permanently delete a save slot and all its versions */
    DeleteSlotRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
    };
    /** @description Complete metadata for a save slot including version statistics */
    SlotResponse: {
      /**
       * Format: uuid
       * @description Unique slot identifier
       */
      slotId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Save category determining retention and cleanup behavior */
      category: components['schemas']['SaveCategory'];
      /** @description Maximum versions to retain */
      maxVersions?: number;
      /** @description Days to retain versions (null = indefinite) */
      retentionDays?: number | null;
      /** @description Compression algorithm used for save data */
      compressionType?: components['schemas']['CompressionType'];
      /** @description Current number of versions in slot */
      versionCount?: number;
      /** @description Latest version number (null if empty) */
      latestVersion?: number | null;
      /**
       * Format: int64
       * @description Total storage used by all versions
       */
      totalSizeBytes?: number;
      /**
       * Format: date-time
       * @description Slot creation timestamp
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last modification timestamp
       */
      updatedAt?: string;
      /** @description Custom key-value metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Response containing a list of save slots for an owner */
    ListSlotsResponse: {
      /** @description List of slots */
      slots: components['schemas']['SlotResponse'][];
      /** @description Total number of slots for owner */
      totalCount?: number;
    };
    /** @description Result of a slot deletion operation with cleanup statistics */
    DeleteSlotResponse: {
      /** @description Whether slot was deleted */
      deleted: boolean;
      /** @description Number of versions deleted */
      versionsDeleted: number;
      /**
       * Format: int64
       * @description Storage freed in bytes
       */
      bytesFreed: number;
    };
    /** @description Request to save game state data to a slot with optional compression and metadata */
    SaveRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name (auto-created if doesn't exist) */
      slotName: string;
      /** @description Category for auto-created slots (defaults to MANUAL_SAVE) */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * Format: byte
       * @description Base64-encoded save data
       */
      data: string;
      /** @description Schema version identifier for migration tracking */
      schemaVersion?: string | null;
      /** @description Human-readable name for this save */
      displayName?: string | null;
      /**
       * Format: byte
       * @description Optional preview image (JPEG/WebP). Max size configurable
       *     (default 256KB). Used for save slot previews in game UI.
       */
      thumbnail?: string | null;
      /**
       * @description Optional device identifier for cloud save conflict detection.
       *     When provided, saves are prefixed/tagged with device info,
       *     enabling opt-in cross-device sync with collision awareness.
       */
      deviceId?: string | null;
      /** @description Custom metadata (e.g., level, playtime, location) */
      metadata?: {
        [key: string]: string;
      } | null;
      /** @description If provided, pin this version with checkpoint name */
      pinAsCheckpoint?: string | null;
    };
    /** @description Result of a save operation including version info and conflict detection */
    SaveResponse: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Assigned version number */
      versionNumber: number;
      /** @description SHA-256 hash of save data */
      contentHash: string;
      /**
       * Format: int64
       * @description Size of save data in bytes
       */
      sizeBytes: number;
      /**
       * Format: int64
       * @description Compressed size (if compression applied)
       */
      compressedSizeBytes?: number;
      /**
       * Format: double
       * @description Compression ratio (0-1)
       */
      compressionRatio?: number;
      /** @description Whether version was pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: uri
       * @description Pre-signed URL to retrieve thumbnail (if provided)
       */
      thumbnailUrl?: string | null;
      /**
       * @description True if this save overwrote a version from a different device.
       *     Only relevant when deviceId is used for cloud sync.
       */
      conflictDetected?: boolean;
      /** @description Device ID of the overwritten version (if conflict) */
      conflictingDeviceId?: string | null;
      /** @description Version number that was overwritten (if conflict) */
      conflictingVersion?: number | null;
      /**
       * Format: date-time
       * @description Save timestamp
       */
      createdAt: string;
      /** @description Number of old versions cleaned up by rolling policy */
      versionsCleanedUp?: number;
      /**
       * @description True if async upload is enabled and data is queued for MinIO upload.
       *     Save is immediately loadable from Redis cache, but not yet durable.
       */
      uploadPending?: boolean;
    };
    /** @description Request to load save data from a specific slot and version */
    LoadRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Specific version to load (defaults to latest) */
      versionNumber?: number | null;
      /** @description Load by checkpoint name instead of version number */
      checkpointName?: string | null;
      /**
       * @description Include version metadata in response
       * @default true
       */
      includeMetadata: boolean;
    };
    /** @description Response containing loaded save data with integrity verification */
    LoadResponse: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Version number loaded */
      versionNumber: number;
      /**
       * Format: byte
       * @description Base64-encoded save data (decompressed)
       */
      data: string;
      /** @description SHA-256 hash for integrity verification */
      contentHash: string;
      /** @description Schema version of this save */
      schemaVersion?: string | null;
      /** @description Human-readable name */
      displayName?: string | null;
      /** @description Whether this version is pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Save timestamp
       */
      createdAt?: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Request to list all versions within a save slot with pagination */
    ListVersionsRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results to return
       * @default 20
       */
      limit: number;
      /**
       * @description Only return pinned versions
       * @default false
       */
      pinnedOnly: boolean;
    };
    /** @description Paginated list of save versions within a slot */
    ListVersionsResponse: {
      /** @description List of versions */
      versions: components['schemas']['VersionResponse'][];
      /** @description Total version count in slot */
      totalCount: number;
    };
    /** @description Metadata for a single save version including size and checkpoint info */
    VersionResponse: {
      /** @description Version number */
      versionNumber: number;
      /**
       * Format: uuid
       * @description Reference to asset in lib-asset
       */
      assetId?: string;
      /** @description SHA-256 hash */
      contentHash: string;
      /**
       * Format: int64
       * @description Size in bytes
       */
      sizeBytes: number;
      /**
       * Format: int64
       * @description Compressed size if applicable
       */
      compressedSizeBytes?: number;
      /** @description Schema version */
      schemaVersion?: string | null;
      /** @description Human-readable name */
      displayName?: string | null;
      /** @description Whether version is pinned */
      pinned?: boolean;
      /** @description Checkpoint name if pinned */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Request to pin a save version as a checkpoint to prevent cleanup */
    PinVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to pin */
      versionNumber: number;
      /** @description Optional checkpoint name for easy retrieval */
      checkpointName?: string;
    };
    /** @description Request to unpin a previously pinned save version */
    UnpinVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to unpin */
      versionNumber: number;
    };
    /** @description Request to permanently delete a specific save version */
    DeleteVersionRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Version to delete */
      versionNumber: number;
    };
    /** @description Result of a version deletion operation with storage freed */
    DeleteVersionResponse: {
      /** @description Whether version was deleted */
      deleted: boolean;
      /**
       * Format: int64
       * @description Storage freed in bytes
       */
      bytesFreed: number;
    };
    /** @description Advanced query for saves across multiple owners with filtering and sorting */
    QuerySavesRequest: {
      /**
       * Format: uuid
       * @description Filter by owner ID
       */
      ownerId?: string | null;
      /** @description Filter by owner type */
      ownerType?: components['schemas']['OwnerType'] | null;
      /** @description Filter by save category */
      category?: components['schemas']['SaveCategory'] | null;
      /**
       * Format: date-time
       * @description Filter by creation date
       */
      createdAfter?: string | null;
      /**
       * Format: date-time
       * @description Filter by creation date
       */
      createdBefore?: string | null;
      /** @description Only return pinned versions */
      pinnedOnly?: boolean | null;
      /** @description Filter by schema version */
      schemaVersion?: string | null;
      /** @description Filter by metadata key-value pairs */
      metadataFilter?: {
        [key: string]: string;
      } | null;
      /**
       * @description Pagination offset
       * @default 0
       */
      offset: number;
      /**
       * @description Maximum results
       * @default 20
       */
      limit: number;
      /**
       * @description Sort field
       * @default created_at
       * @enum {string}
       */
      sortBy: 'created_at' | 'size' | 'version_number';
      /**
       * @description Sort order
       * @default desc
       * @enum {string}
       */
      sortOrder: 'asc' | 'desc';
    };
    /** @description Paginated results from a save query operation */
    QuerySavesResponse: {
      /** @description Query results */
      results: components['schemas']['QueryResultItem'][];
      /** @description Total matching results */
      totalCount: number;
    };
    /** @description Single result item from a save query with slot and version metadata */
    QueryResultItem: {
      /**
       * Format: uuid
       * @description Slot identifier
       */
      slotId: string;
      /** @description Slot name */
      slotName: string;
      /**
       * Format: uuid
       * @description Owner ID
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Save category of the slot */
      category: components['schemas']['SaveCategory'];
      /** @description Version number */
      versionNumber: number;
      /**
       * Format: int64
       * @description Size in bytes
       */
      sizeBytes?: number;
      /** @description Schema version */
      schemaVersion?: string | null;
      /** @description Display name */
      displayName?: string | null;
      /** @description Whether pinned */
      pinned?: boolean;
      /** @description Checkpoint name */
      checkpointName?: string | null;
      /**
       * Format: date-time
       * @description Creation timestamp
       */
      createdAt: string;
      /** @description Custom metadata */
      metadata?: {
        [key: string]: string;
      };
    };
    /** @description Request to migrate a save to a newer schema version */
    MigrateSaveRequest: {
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Slot name */
      slotName: string;
      /** @description Specific version to migrate (defaults to latest) */
      versionNumber?: number;
      /** @description Target schema version to migrate to */
      targetSchemaVersion: string;
      /**
       * @description Validate migration without saving
       * @default false
       */
      dryRun: boolean;
    };
    /** @description Result of a schema migration operation with version path details */
    MigrateSaveResponse: {
      /** @description Whether migration succeeded */
      success: boolean;
      /** @description Original schema version */
      fromSchemaVersion: string;
      /** @description Target schema version */
      toSchemaVersion: string;
      /** @description New version number (null if dry run) */
      newVersionNumber?: number | null;
      /** @description Migration path applied (list of versions) */
      migrationPath?: string[];
      /** @description Non-fatal migration warnings */
      warnings?: string[];
    };
    /** @description Request to register a new save data schema with optional migration rules */
    RegisterSchemaRequest: {
      /** @description Schema namespace (e.g., game identifier) */
      namespace: string;
      /** @description Schema version identifier */
      schemaVersion: string;
      /** @description JSON Schema definition for validation */
      schema: Record<string, never>;
      /** @description Previous version this migrates from */
      previousVersion?: string | null;
      /**
       * @description JSON Patch (RFC 6902) operations to migrate from previousVersion.
       *     Uses JsonPatch.Net library (MIT licensed).
       */
      migrationPatch?: components['schemas']['JsonPatchOperation'][] | null;
    };
    /** @description Registered schema definition with version lineage information */
    SchemaResponse: {
      /** @description Schema namespace */
      namespace: string;
      /** @description Schema version */
      schemaVersion: string;
      /** @description JSON Schema definition */
      schema?: Record<string, never>;
      /** @description Previous version */
      previousVersion?: string | null;
      /** @description Whether migration script is registered */
      hasMigration?: boolean;
      /**
       * Format: date-time
       * @description Registration timestamp
       */
      createdAt: string;
    };
    /** @description Request to list all registered schemas for a namespace */
    ListSchemasRequest: {
      /** @description Schema namespace to list */
      namespace: string;
    };
    /** @description List of registered schemas with latest version indicator */
    ListSchemasResponse: {
      /** @description Registered schemas */
      schemas: components['schemas']['SchemaResponse'][];
      /** @description Latest schema version */
      latestVersion?: string | null;
    };
    /** @description Request for admin-triggered cleanup of expired or orphaned saves */
    AdminCleanupRequest: {
      /**
       * @description Preview cleanup without executing
       * @default true
       */
      dryRun: boolean;
      /** @description Only cleanup versions older than N days */
      olderThanDays?: number;
      /** @description Filter cleanup to specific owner type */
      ownerType?: components['schemas']['OwnerType'];
      /** @description Filter cleanup to specific save category */
      category?: components['schemas']['SaveCategory'];
    };
    /** @description Result of admin cleanup operation with storage reclamation details */
    AdminCleanupResponse: {
      /** @description Number of versions deleted */
      versionsDeleted: number;
      /** @description Number of empty slots deleted */
      slotsDeleted?: number;
      /**
       * Format: int64
       * @description Storage freed in bytes
       */
      bytesFreed: number;
      /** @description Whether this was a preview */
      dryRun: boolean;
    };
    /** @description Request for aggregate storage statistics with optional grouping */
    AdminStatsRequest: {
      /**
       * @description Group statistics by field
       * @enum {string}
       */
      groupBy?: 'owner_type' | 'category' | 'schema_version';
    };
    /** @description Aggregate storage statistics with optional breakdown by category */
    AdminStatsResponse: {
      /** @description Total slot count */
      totalSlots: number;
      /** @description Total version count */
      totalVersions: number;
      /**
       * Format: int64
       * @description Total storage used
       */
      totalSizeBytes: number;
      /** @description Number of pinned versions */
      pinnedVersions?: number;
      /** @description Breakdown by groupBy field */
      breakdown?: components['schemas']['StatsBreakdown'][];
    };
    /** @description Storage statistics for a single category in the breakdown */
    StatsBreakdown: {
      /** @description Group key */
      key: string;
      /** @description Slot count */
      slots: number;
      /** @description Version count */
      versions: number;
      /**
       * Format: int64
       * @description Storage used
       */
      sizeBytes: number;
    };
    /** @description Request to rename an existing save slot */
    RenameSlotRequest: {
      /** @description Game identifier */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the slot
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Current slot name */
      slotName: string;
      /** @description New slot name */
      newSlotName: string;
    };
    /** @description Request to delete multiple save slots in a single operation */
    BulkDeleteSlotsRequest: {
      /** @description Game identifier */
      gameId: string;
      /** @description Slot IDs to delete */
      slotIds: string[];
    };
    /** @description Result of bulk slot deletion with total cleanup statistics */
    BulkDeleteSlotsResponse: {
      /** @description Number of slots deleted */
      deletedCount: number;
      /**
       * Format: int64
       * @description Total storage freed
       */
      bytesFreed: number;
    };
    /** @description Request to copy save data from one slot to another, optionally across different entities or games. */
    CopySaveRequest: {
      /** @description Game identifier of the source save */
      sourceGameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the source save
       */
      sourceOwnerId: string;
      /** @description Type of entity that owns the source save */
      sourceOwnerType: components['schemas']['OwnerType'];
      /** @description Name of the source slot to copy from */
      sourceSlotName: string;
      /** @description Version to copy (latest if null) */
      sourceVersion?: number | null;
      /** @description Game identifier for the target save */
      targetGameId: string;
      /**
       * Format: uuid
       * @description Entity ID that will own the copied save
       */
      targetOwnerId: string;
      /** @description Type of entity that will own the copied save */
      targetOwnerType: components['schemas']['OwnerType'];
      /** @description Name of the target slot to copy to */
      targetSlotName: string;
      /** @description Category for new slot if auto-created */
      targetCategory?: components['schemas']['SaveCategory'];
    };
    /** @description Request to export all saves for an owner to a downloadable archive */
    ExportSavesRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the saves to export
       */
      ownerId: string;
      /** @description Type of entity that owns the saves to export */
      ownerType: components['schemas']['OwnerType'];
      /** @description Specific slots to export (all if null) */
      slotNames?: string[];
    };
    /** @description Response with pre-signed URL for downloading exported save archive */
    ExportSavesResponse: {
      /**
       * Format: uri
       * @description Pre-signed URL to download export archive
       */
      downloadUrl: string;
      /**
       * Format: date-time
       * @description When the download URL expires
       */
      expiresAt: string;
      /**
       * Format: int64
       * @description Archive size
       */
      sizeBytes: number;
    };
    /** @description Request to import saves from an uploaded archive */
    ImportSavesRequest: {
      /**
       * Format: uuid
       * @description Asset ID of uploaded export archive
       */
      archiveAssetId: string;
      /** @description Game identifier for namespace isolation */
      targetGameId: string;
      /**
       * Format: uuid
       * @description Entity ID that will own the imported saves
       */
      targetOwnerId: string;
      /** @description Type of entity that will own the imported saves */
      targetOwnerType: components['schemas']['OwnerType'];
      /** @description How to handle existing slots */
      conflictResolution?: components['schemas']['ConflictResolution'];
    };
    /** @description Result of save archive import with success and conflict counts */
    ImportSavesResponse: {
      /** @description Number of slots successfully imported */
      importedSlots: number;
      /** @description Total number of versions imported across all slots */
      importedVersions: number;
      /** @description Slots skipped due to conflicts */
      skippedSlots: number;
      /** @description Names of slots that had conflicts */
      conflicts?: string[];
    };
    /** @description Request to verify data integrity of a save version via hash comparison */
    VerifyIntegrityRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot to verify */
      slotName: string;
      /** @description Version to verify (latest if null) */
      versionNumber?: number | null;
    };
    /** @description Result of integrity verification with hash comparison details */
    VerifyIntegrityResponse: {
      /** @description Whether integrity check passed */
      valid: boolean;
      /** @description Version that was verified */
      versionNumber: number;
      /** @description Expected SHA-256 hash */
      expectedHash?: string;
      /** @description Actual hash (null if data unavailable) */
      actualHash?: string | null;
      /** @description Error details if verification failed */
      errorMessage?: string | null;
    };
    /** @description Request to promote an older save version to be the latest */
    PromoteVersionRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot containing the version to promote */
      slotName: string;
      /** @description Old version to promote to latest */
      versionNumber: number;
      /** @description Display name for promoted version */
      displayName?: string | null;
    };
    /**
     * @description Algorithm used for delta computation.
     *     JSON_PATCH: RFC 6902, best for structured JSON data
     *     BSDIFF: Binary diff, good for general binary data
     *     XDELTA: RFC 3284 VCDIFF, efficient for large binary files
     * @default JSON_PATCH
     * @enum {string}
     */
    DeltaAlgorithm: 'JSON_PATCH' | 'BSDIFF' | 'XDELTA';
    /** @description Request to save incremental changes as a delta from a base version */
    SaveDeltaRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description ID of the owning entity
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot to save the delta to */
      slotName: string;
      /** @description Version number this delta is based on */
      baseVersion: number;
      /**
       * Format: byte
       * @description Base64-encoded delta/patch data.
       *     For JSON_PATCH: Array of RFC 6902 operations
       *     For BSDIFF/XDELTA: Binary patch data
       */
      delta: string;
      /** @description Delta computation algorithm to use (defaults to JSON_PATCH) */
      algorithm?: components['schemas']['DeltaAlgorithm'] | null;
      /** @description Schema version of this save for migration tracking */
      schemaVersion?: string | null;
      /** @description Human-readable name for this delta save */
      displayName?: string | null;
      /** @description Device identifier for cross-device sync conflict detection */
      deviceId?: string | null;
      /** @description Custom key-value metadata for this delta version */
      metadata?: {
        [key: string]: string;
      } | null;
    };
    /** @description Result of delta save operation with size and chain information */
    SaveDeltaResponse: {
      /**
       * Format: uuid
       * @description Unique identifier of the save slot
       */
      slotId: string;
      /** @description New version number */
      versionNumber: number;
      /** @description Base version this delta is relative to */
      baseVersion: number;
      /**
       * Format: int64
       * @description Size of stored delta
       */
      deltaSizeBytes: number;
      /**
       * Format: int64
       * @description Estimated size when reconstructed
       */
      estimatedFullSizeBytes: number;
      /** @description Number of deltas in chain to base snapshot */
      chainLength?: number;
      /**
       * Format: double
       * @description Storage savings vs full snapshot (0-1)
       */
      compressionSavings?: number;
      /**
       * Format: date-time
       * @description When the delta version was created
       */
      createdAt: string;
    };
    /** @description Request to collapse a delta chain into a full snapshot */
    CollapseDeltasRequest: {
      /** @description Game identifier for namespace isolation */
      gameId: string;
      /**
       * Format: uuid
       * @description Entity ID that owns the save slot
       */
      ownerId: string;
      /** @description Type of entity that owns this save slot */
      ownerType: components['schemas']['OwnerType'];
      /** @description Name of the slot containing deltas to collapse */
      slotName: string;
      /** @description Version to collapse to (latest if null) */
      versionNumber?: number | null;
      /**
       * @description Delete intermediate delta versions after collapse
       * @default true
       */
      deleteIntermediates: boolean;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  CreateSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateSlotRequest'];
      };
    };
    responses: {
      /** @description Slot created or updated */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Invalid request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot already exists with different owner */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetSlotRequest'];
      };
    };
    responses: {
      /** @description Slot found */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListSlots: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSlotsRequest'];
      };
    };
    responses: {
      /** @description Slots listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSlotsResponse'];
        };
      };
    };
  };
  DeleteSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteSlotRequest'];
      };
    };
    responses: {
      /** @description Slot deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteSlotResponse'];
        };
      };
      /** @description Not authorized to delete this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RenameSlot: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RenameSlotRequest'];
      };
    };
    responses: {
      /** @description Slot renamed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SlotResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Target name already exists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BulkDeleteSlots: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkDeleteSlotsRequest'];
      };
    };
    responses: {
      /** @description Slots deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BulkDeleteSlotsResponse'];
        };
      };
    };
  };
  Save: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveRequest'];
      };
    };
    responses: {
      /** @description Save successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Invalid request or data validation failed */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not authorized to save to this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Save data exceeds maximum size limit */
      413: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  Load: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoadRequest'];
      };
    };
    responses: {
      /** @description Load successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LoadResponse'];
        };
      };
      /** @description Not authorized to load from this slot */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SaveDelta: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveDeltaRequest'];
      };
    };
    responses: {
      /** @description Delta save successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveDeltaResponse'];
        };
      };
      /** @description Invalid delta or base version not found */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Base version has been deleted (cannot apply delta) */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Delta too large (consider full save instead) */
      413: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  LoadWithDeltas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['LoadRequest'];
      };
    };
    responses: {
      /** @description Load successful (reconstructed if delta) */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LoadResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Delta chain broken (base version missing) */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CollapseDeltas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CollapseDeltasRequest'];
      };
    };
    responses: {
      /** @description Delta chain collapsed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListVersions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListVersionsRequest'];
      };
    };
    responses: {
      /** @description Versions listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListVersionsResponse'];
        };
      };
      /** @description Slot not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PinVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PinVersionRequest'];
      };
    };
    responses: {
      /** @description Version pinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UnpinVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UnpinVersionRequest'];
      };
    };
    responses: {
      /** @description Version unpinned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeleteVersionRequest'];
      };
    };
    responses: {
      /** @description Version deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DeleteVersionResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Cannot delete pinned version */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  QuerySaves: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['QuerySavesRequest'];
      };
    };
    responses: {
      /** @description Query results */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['QuerySavesResponse'];
        };
      };
    };
  };
  CopySave: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CopySaveRequest'];
      };
    };
    responses: {
      /** @description Save copied */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Not authorized to copy to target */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Source slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ExportSaves: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ExportSavesRequest'];
      };
    };
    responses: {
      /** @description Export prepared */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExportSavesResponse'];
        };
      };
    };
  };
  ImportSaves: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ImportSavesRequest'];
      };
    };
    responses: {
      /** @description Import completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ImportSavesResponse'];
        };
      };
      /** @description Invalid archive format */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  VerifyIntegrity: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VerifyIntegrityRequest'];
      };
    };
    responses: {
      /** @description Verification result */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyIntegrityResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PromoteVersion: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PromoteVersionRequest'];
      };
    };
    responses: {
      /** @description Version promoted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SaveResponse'];
        };
      };
      /** @description Slot or version not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  MigrateSave: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['MigrateSaveRequest'];
      };
    };
    responses: {
      /** @description Migration successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MigrateSaveResponse'];
        };
      };
      /** @description Migration failed or no path exists */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Save not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RegisterSchema: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterSchemaRequest'];
      };
    };
    responses: {
      /** @description Schema registered */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SchemaResponse'];
        };
      };
    };
  };
  ListSchemas: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListSchemasRequest'];
      };
    };
    responses: {
      /** @description Schemas listed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListSchemasResponse'];
        };
      };
    };
  };
  AdminCleanup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AdminCleanupRequest'];
      };
    };
    responses: {
      /** @description Cleanup completed */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AdminCleanupResponse'];
        };
      };
    };
  };
  AdminStats: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AdminStatsRequest'];
      };
    };
    responses: {
      /** @description Statistics returned */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AdminStatsResponse'];
        };
      };
    };
  };
}
