/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/mesh/endpoints/get': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get endpoints for a service
     * @description Returns all healthy endpoints for the specified app-id.
     *     Used by IMeshClient to resolve target hosts for service invocation.
     */
    post: operations['getEndpoints'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mesh/endpoints/list': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * List all registered endpoints
     * @description Returns all registered service endpoints across all app-ids.
     *     Admin-only endpoint for monitoring and debugging.
     */
    post: operations['listEndpoints'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mesh/register': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register a service endpoint
     * @description Registers this instance's endpoint in the service mesh.
     *     Called during service startup to announce availability.
     *     Endpoint TTL is refreshed on each heartbeat.
     */
    post: operations['registerEndpoint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mesh/deregister': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deregister a service endpoint
     * @description Removes this instance's endpoint from the service mesh.
     *     Called during graceful shutdown.
     */
    post: operations['deregisterEndpoint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mesh/heartbeat': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update endpoint health and load
     * @description Refreshes endpoint TTL and updates health/load metrics.
     *     Should be called periodically (default: every 30 seconds).
     */
    post: operations['heartbeat'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mesh/route': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get optimal endpoint for routing
     * @description Returns a single endpoint for the specified app-id, selected by the
     *     configured load balancing algorithm (round-robin, least-connections, weighted).
     */
    post: operations['getRoute'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mesh/mappings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get service-to-app-id mappings
     * @description Returns the current service name to app-id mapping table.
     *     Used by ServiceAppMappingResolver for distributed deployment.
     */
    post: operations['getMappings'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mesh/health': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get mesh health status
     * @description Returns overall health of the service mesh including:
     *     - Total registered endpoints
     *     - Healthy/degraded/unavailable counts
     *     - Redis connectivity status
     */
    post: operations['getHealth'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description A service endpoint in the mesh */
    MeshEndpoint: {
      /**
       * Format: uuid
       * @description Unique identifier for this instance
       */
      instanceId: string;
      /** @description Bannou app-id (e.g., "bannou", "bannou-npc-01") */
      appId: string;
      /** @description Hostname or IP address */
      host: string;
      /** @description Service port (typically 80) */
      port: number;
      /** @description Current health status of the endpoint */
      status: components['schemas']['EndpointStatus'];
      /**
       * Format: float
       * @description Current load as percentage (0-100)
       * @default 0
       */
      loadPercent: number;
      /** @description Maximum concurrent connections */
      maxConnections?: number;
      /** @description Current active connections */
      currentConnections?: number;
      /** @description List of service names hosted on this endpoint */
      services?: string[];
      /**
       * Format: date-time
       * @description Last heartbeat timestamp
       */
      lastSeen?: string;
      /**
       * Format: date-time
       * @description When endpoint was first registered
       */
      registeredAt?: string;
    };
    /**
     * @description Health status of an endpoint
     * @enum {string}
     */
    EndpointStatus: 'Healthy' | 'Degraded' | 'Unavailable' | 'ShuttingDown';
    /**
     * @description Load balancing algorithm
     * @enum {string}
     */
    LoadBalancerAlgorithm: 'RoundRobin' | 'LeastConnections' | 'Weighted' | 'Random';
    /** @description Request to get endpoints for a service */
    GetEndpointsRequest: {
      /** @description App-id to get endpoints for */
      appId: string;
      /**
       * @description If true, include degraded/unavailable endpoints
       * @default false
       */
      includeUnhealthy: boolean;
      /** @description Optional filter by specific service name (null for all services) */
      serviceName?: string | null;
    };
    /** @description Response containing endpoints for a service */
    GetEndpointsResponse: {
      /** @description The app-id that was queried */
      appId: string;
      /** @description List of endpoints for the requested app-id */
      endpoints: components['schemas']['MeshEndpoint'][];
      /** @description Number of healthy endpoints */
      healthyCount?: number;
      /** @description Total number of endpoints (including unhealthy) */
      totalCount?: number;
    };
    /** @description Request to list all endpoints */
    ListEndpointsRequest: {
      /** @description Filter endpoints by health status (null for all statuses) */
      statusFilter?: components['schemas']['EndpointStatus'];
      /** @description Optional filter by app-id prefix (null for all app IDs) */
      appIdFilter?: string | null;
    };
    /** @description Response containing all endpoints */
    ListEndpointsResponse: {
      /** @description List of all registered endpoints */
      endpoints: components['schemas']['MeshEndpoint'][];
      /** @description Summary statistics for the endpoints */
      summary: components['schemas']['EndpointSummary'];
    };
    /** @description Summary statistics for endpoints */
    EndpointSummary: {
      /** @description Total number of registered endpoints */
      totalEndpoints?: number;
      /** @description Number of endpoints with Healthy status */
      healthyCount?: number;
      /** @description Number of endpoints with Degraded status */
      degradedCount?: number;
      /** @description Number of endpoints with Unavailable status */
      unavailableCount?: number;
      /** @description Number of unique app-ids across all endpoints */
      uniqueAppIds?: number;
    };
    /** @description Request to register a service endpoint */
    RegisterEndpointRequest: {
      /**
       * Format: uuid
       * @description Unique identifier for this instance
       */
      instanceId: string;
      /** @description App-id for this instance */
      appId: string;
      /** @description Hostname or IP address to register */
      host: string;
      /**
       * @description Service port
       * @default 80
       */
      port: number;
      /** @description List of service names hosted on this endpoint (null for none) */
      services?: string[] | null;
      /**
       * @description Maximum concurrent connections
       * @default 1000
       */
      maxConnections: number;
      /** @description Optional metadata key-value pairs (null if none) */
      metadata?: {
        [key: string]: string;
      } | null;
    };
    /** @description Response after registering endpoint */
    RegisterEndpointResponse: {
      /** @description The registered endpoint details */
      endpoint: components['schemas']['MeshEndpoint'];
      /** @description TTL for the registration (requires heartbeat refresh) */
      ttlSeconds?: number;
    };
    /** @description Request to deregister an endpoint */
    DeregisterEndpointRequest: {
      /**
       * Format: uuid
       * @description Instance to deregister
       */
      instanceId: string;
    };
    /** @description Heartbeat to refresh endpoint TTL and update metrics */
    HeartbeatRequest: {
      /**
       * Format: uuid
       * @description Unique identifier for the instance sending the heartbeat
       */
      instanceId: string;
      /** @description Current health status of the endpoint (null defaults to Healthy) */
      status?: components['schemas']['EndpointStatus'] | null;
      /**
       * Format: float
       * @description Current load 0-100 (null defaults to 0)
       */
      loadPercent?: number | null;
      /** @description Current active connections (null defaults to 0) */
      currentConnections?: number | null;
      /** @description List of non-critical issues (null if none) */
      issues?: string[] | null;
    };
    /** @description Response after heartbeat processed */
    HeartbeatResponse: {
      /** @description Recommended seconds until next heartbeat */
      nextHeartbeatSeconds?: number;
      /** @description Remaining TTL for registration */
      ttlSeconds?: number;
    };
    /** @description Request to get optimal route for a service call */
    GetRouteRequest: {
      /** @description Target app-id to route to */
      appId: string;
      /** @description Optional service name for affinity routing (null for no affinity) */
      serviceName?: string | null;
      /** @description Load balancing algorithm to use for endpoint selection */
      algorithm?: components['schemas']['LoadBalancerAlgorithm'];
    };
    /** @description Selected route for service call */
    GetRouteResponse: {
      /** @description The selected optimal endpoint for routing */
      endpoint: components['schemas']['MeshEndpoint'];
      /** @description Alternative endpoints if primary fails */
      alternates?: components['schemas']['MeshEndpoint'][];
    };
    /** @description Request to get service-to-app-id mappings */
    GetMappingsRequest: {
      /** @description Optional filter by service name prefix (null for all services) */
      serviceNameFilter?: string | null;
    };
    /** @description Current service mappings */
    GetMappingsResponse: {
      /** @description Map of serviceName -> appId */
      mappings: {
        [key: string]: string;
      };
      /**
       * @description Default app-id when no mapping exists
       * @default bannou
       */
      defaultAppId: string;
      /**
       * Format: int64
       * @description Mapping version for change detection
       */
      version: number;
    };
    /** @description Request for mesh health status */
    GetHealthRequest: {
      /**
       * @description Include full endpoint list in response
       * @default false
       */
      includeEndpoints: boolean;
    };
    /** @description Overall mesh health status */
    MeshHealthResponse: {
      /** @description Overall health status of the mesh */
      status: components['schemas']['EndpointStatus'];
      /** @description Summary statistics for all endpoints */
      summary: components['schemas']['EndpointSummary'];
      /** @description Whether Redis connection is healthy */
      redisConnected?: boolean;
      /**
       * Format: date-time
       * @description Timestamp of the last health status update
       */
      lastUpdateTime?: string;
      /** @description Mesh service uptime (e.g., "2d 5h 30m") */
      uptime?: string;
      /** @description Full endpoint list (only if includeEndpoints=true) */
      endpoints?: components['schemas']['MeshEndpoint'][];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  getEndpoints: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetEndpointsRequest'];
      };
    };
    responses: {
      /** @description Endpoints retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetEndpointsResponse'];
        };
      };
      /** @description No endpoints found for app-id */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listEndpoints: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ListEndpointsRequest'];
      };
    };
    responses: {
      /** @description All endpoints retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListEndpointsResponse'];
        };
      };
    };
  };
  registerEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['RegisterEndpointRequest'];
      };
    };
    responses: {
      /** @description Endpoint registered successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RegisterEndpointResponse'];
        };
      };
      /** @description Invalid registration data */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deregisterEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DeregisterEndpointRequest'];
      };
    };
    responses: {
      /** @description Endpoint deregistered successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Endpoint not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  heartbeat: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['HeartbeatRequest'];
      };
    };
    responses: {
      /** @description Heartbeat processed successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HeartbeatResponse'];
        };
      };
      /** @description Endpoint not registered */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getRoute: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetRouteRequest'];
      };
    };
    responses: {
      /** @description Route selected successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetRouteResponse'];
        };
      };
      /** @description No healthy endpoints available for the requested app-id */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getMappings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetMappingsRequest'];
      };
    };
    responses: {
      /** @description Mappings retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetMappingsResponse'];
        };
      };
    };
  };
  getHealth: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetHealthRequest'];
      };
    };
    responses: {
      /** @description Health status retrieved */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MeshHealthResponse'];
        };
      };
    };
  };
}
