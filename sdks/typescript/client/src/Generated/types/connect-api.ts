/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/internal/proxy': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Internal API proxy for stateless requests
     * @description Stateless HTTP proxy for internal requests that don't require persistent sessions.
     *     Applies permission validation and rate limiting based on agent role and context.
     *     Perfect for AI agents making one-off API calls or bulk operations.
     */
    post: operations['proxyInternalRequest'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/client-capabilities': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get client capability manifest (GUID â†’ API mappings)
     * @description Returns the capability manifest for the authenticated client's session.
     *     Maps client-salted GUIDs to available API endpoints based on the client's
     *     current permissions and session state.
     *
     *     **Security**: Each client receives unique GUIDs for the same API endpoints.
     *     This prevents cross-session exploitation and enables per-client rate limiting.
     *
     *     **Dynamic Updates**: Capabilities may change during a session when:
     *     - Role changes occur (admin promotion, etc.)
     *     - Subscription status changes
     *     - Session state transitions
     *
     *     Clients should listen for capability update events via WebSocket to stay current.
     */
    post: operations['getClientCapabilities'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/connect': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Establish WebSocket connection
     * @description Initiates a WebSocket connection for real-time communication.
     *     Requires JWT authentication via Authorization header.
     *
     *     **Connection Flow:**
     *     1. Send HTTP GET request with `Connection: Upgrade` and `Upgrade: websocket` headers
     *     2. Include `Authorization: Bearer <jwt_token>` header for authentication
     *     3. Server validates JWT and extracts user claims (roles, scopes, services)
     *     4. Connection upgrades to WebSocket protocol
     *     5. Client can send binary messages using the custom protocol
     *
     *     **Reconnection:**
     *     For existing sessions, use `Authorization: Reconnect <reconnect_token>` instead.
     */
    get: operations['ConnectWebSocket'];
    put?: never;
    /**
     * Establish WebSocket connection (POST variant)
     * @description Alternative POST method for establishing WebSocket connections.
     *     Functionally identical to the GET method but supports clients that
     *     require POST for WebSocket upgrades.
     */
    post: operations['ConnectWebSocketPost'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/connect/get-account-sessions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Get all active WebSocket sessions for an account
     * @description Returns all active WebSocket session IDs for a specified account.
     *     This is an internal endpoint used by services that need to know which
     *     sessions are currently connected for a given account.
     *
     *     **Use Cases:**
     *     - GameSessionService periodic cache sync
     *     - Service-to-service session discovery
     *     - Admin session management
     *
     *     **Note:** Session IDs returned are those with active WebSocket connections.
     *     Sessions in reconnection windows may not appear in this list.
     */
    post: operations['getAccountSessions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** @description Request to get all active WebSocket sessions for an account */
    GetAccountSessionsRequest: {
      /**
       * Format: uuid
       * @description Account ID to retrieve sessions for
       */
      accountId: string;
    };
    /** @description Response containing all active WebSocket session IDs for an account */
    GetAccountSessionsResponse: {
      /**
       * Format: uuid
       * @description Account ID the sessions belong to
       */
      accountId: string;
      /** @description List of active WebSocket session IDs for this account */
      sessionIds: string[];
      /** @description Number of active sessions */
      count?: number;
      /**
       * Format: date-time
       * @description When this session list was retrieved
       */
      retrievedAt: string;
    };
    /** @description Request to get capability manifest for a connected session (debugging endpoint) */
    GetClientCapabilitiesRequest: {
      /** @description Session ID to retrieve capabilities for (must have active WebSocket connection) */
      sessionId: string;
      /** @description Optional filter by service name prefix */
      serviceFilter?: string | null;
      /**
       * @description Include additional metadata about each capability
       * @default false
       */
      includeMetadata: boolean;
    };
    /** @description Response containing the client's capability manifest with available API endpoints and shortcuts */
    ClientCapabilitiesResponse: {
      /** @description Session ID this capability manifest belongs to */
      sessionId: string;
      /** @description Available API capabilities for this client */
      capabilities: components['schemas']['ClientCapability'][];
      /**
       * @description Pre-bound API calls available for this session.
       *     Shortcuts are invoked like normal capabilities but Connect injects
       *     a pre-bound payload instead of using the client's payload.
       */
      shortcuts?: components['schemas']['ClientShortcut'][] | null;
      /** @description Capability manifest version (increments on changes) */
      version: number;
      /**
       * Format: date-time
       * @description When this capability manifest was generated
       */
      generatedAt: string;
      /**
       * Format: date-time
       * @description When these capabilities expire and need refresh
       */
      expiresAt?: string | null;
    };
    /** @description A single API capability available to the client, mapping a client-salted GUID to a service endpoint */
    ClientCapability: {
      /**
       * Format: uuid
       * @description Client-salted GUID for this API endpoint (unique per session)
       */
      guid: string;
      /** @description Service name (e.g., "account", "auth") */
      service: string;
      /** @description API endpoint path (e.g., "/account/create") */
      endpoint: string;
      /**
       * @description HTTP method for this endpoint
       * @enum {string}
       */
      method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
      /** @description Human-readable description of this capability */
      description?: string | null;
      /**
       * Format: uint16
       * @description Preferred WebSocket channel for this capability
       * @default 0
       */
      channel: number;
    };
    /**
     * @description Session shortcut information sent to clients in the capability manifest.
     *     Shortcuts appear as invocable capabilities but Connect injects a pre-bound
     *     payload when the shortcut GUID is used, replacing any client-provided payload.
     */
    ClientShortcut: {
      /**
       * Format: uuid
       * @description GUID to use in WebSocket message header when invoking this shortcut.
       *     Uses UUID version 7 bits to distinguish from regular service GUIDs (version 5).
       */
      guid: string;
      /** @description The service this shortcut invokes (for client display purposes). */
      targetService: string;
      /** @description The endpoint this shortcut invokes (for client display purposes). */
      targetEndpoint: string;
      /** @description Machine-readable shortcut identifier (e.g., "get_my_stats", "join_game"). */
      name: string;
      /** @description Human-readable description of what this shortcut does. */
      description?: string | null;
      /** @description User-friendly name for display in client UIs. */
      displayName?: string | null;
      /** @description The service that created this shortcut. */
      sourceService?: string | null;
      /** @description Categorization tags for client-side organization. */
      tags?: string[] | null;
      /**
       * Format: date-time
       * @description When this shortcut expires (if time-limited).
       */
      expiresAt?: string | null;
    };
    /** @description Request to proxy an API call through the Connect service to a target backend service */
    InternalProxyRequest: {
      /** @description WebSocket session ID making the request */
      sessionId: string;
      /** @description Target service name (e.g., "account", "auth", "behavior") */
      targetService: string;
      /** @description Target API endpoint path (e.g., "/account/{id}") */
      targetEndpoint: string;
      /**
       * @description HTTP method for the target endpoint
       * @enum {string}
       */
      method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
      /** @description Additional headers to forward to the service (null if none) */
      headers?: {
        [key: string]: string;
      } | null;
      /** @description Request body to forward to target service (null for no body) */
      body?: {
        [key: string]: unknown;
      } | null;
      /** @description Path parameters for the endpoint (null if none) */
      pathParameters?: {
        [key: string]: string;
      } | null;
      /** @description Query string parameters for the endpoint (null if none) */
      queryParameters?: {
        [key: string]: string;
      } | null;
    };
    /** @description Response from a proxied API call containing the target service's response data */
    InternalProxyResponse: {
      /** @description HTTP status code from the target service */
      statusCode: number;
      /** @description JSON response from the target service (as string) */
      response?: string | null;
      /** @description Response headers from the target service */
      headers?: {
        [key: string]: string[];
      } | null;
      /** @description Error message if the request failed */
      error?: string | null;
      /** @description Request execution time in milliseconds */
      executionTime?: number;
    };
    /**
     * @description Request model for WebSocket connection establishment.
     *     Currently contains no specific fields but extends the base ApiRequest.
     */
    ConnectRequest: Record<string, never>;
    /**
     * Format: byte
     * @description Bit flags controlling message behavior in the enhanced 31-byte binary protocol.
     *
     *     **Flags:**
     *     - 0x00 (None): Default - JSON text, service request, unencrypted, standard priority, expects response
     *     - 0x01 (Binary): Message payload is binary data (not JSON)
     *     - 0x02 (Encrypted): Message payload is encrypted
     *     - 0x04 (Compressed): Message payload is compressed (gzip)
     *     - 0x08 (HighPriority): Deliver at high priority, skip to front of queues
     *     - 0x10 (Event): Fire-and-forget message, no response expected
     *     - 0x20 (Client): Route to another WebSocket client (not a Bannou service)
     *     - 0x40 (Response): Message is a response to an RPC (not a new request)
     *     - 0x80 (Reserved): Reserved for future use
     * @example 0
     */
    MessageFlags: number;
    /**
     * Format: byte
     * @description Response codes used in the binary protocol for success/error indication.
     *     Provides fine-grained error reporting for different failure scenarios.
     *
     *     **Broadcast error codes (40-49):**
     *     - 40 (BroadcastNotAllowed): Broadcast attempted in External mode where it is forbidden
     *
     *     **Shortcut-specific error codes (70-79):**
     *     - 70 (ShortcutExpired): Session shortcut has expired (TTL exceeded)
     *     - 71 (ShortcutTargetNotFound): Shortcut's target capability no longer available
     *     - 72 (ShortcutRevoked): Session shortcut was explicitly revoked
     * @example 0
     * @enum {integer}
     */
    ResponseCodes:
      | 0
      | 10
      | 11
      | 12
      | 13
      | 20
      | 30
      | 31
      | 32
      | 40
      | 50
      | 51
      | 52
      | 53
      | 60
      | 70
      | 71
      | 72;
    /**
     * @description Structure of a service request message in the enhanced 31-byte binary protocol.
     *     This schema is for documentation - actual messages are binary.
     *
     *     **Binary Header Layout (31 bytes):**
     *     - Bytes 0: Message Flags (1 byte)
     *     - Bytes 1-2: Channel ID (2 bytes, big-endian)
     *     - Bytes 3-6: Sequence Number (4 bytes, big-endian)
     *     - Bytes 7-22: Service GUID (16 bytes)
     *     - Bytes 23-30: Message ID (8 bytes)
     *     - Bytes 31+: Payload (variable length)
     */
    ServiceRequestMessage: {
      /** @description Bit flags controlling message behavior (binary, encrypted, compressed, etc.) */
      flags: components['schemas']['MessageFlags'];
      /**
       * Format: uint16
       * @description Channel for sequential message processing (0-65535, 0 = default)
       */
      channel: number;
      /**
       * Format: uint32
       * @description Per-channel sequence number for message ordering
       */
      sequenceNumber: number;
      /**
       * Format: uuid
       * @description Client-salted service GUID for routing
       */
      serviceGuid: string;
      /**
       * Format: int64
       * @description Unique message ID for request/response correlation
       */
      messageId: number;
      /**
       * Format: byte
       * @description Message payload (JSON or binary data based on flags)
       */
      payload: string;
    };
    /**
     * @description Structure of a service response message in the enhanced 31-byte binary protocol.
     *     This schema is for documentation - actual messages are binary.
     *
     *     **Binary Header Layout (31 bytes):**
     *     - Same as ServiceRequestMessage but with Response flag (0x40) set
     */
    ServiceResponseMessage: {
      /** @description Must have Response flag (0x40) set */
      flags: components['schemas']['MessageFlags'];
      /**
       * Format: uint16
       * @description Matches the request channel
       */
      channel: number;
      /**
       * Format: uint32
       * @description Matches the request sequence number
       */
      sequenceNumber: number;
      /**
       * Format: uuid
       * @description Matches the request service GUID
       */
      serviceGuid: string;
      /**
       * Format: int64
       * @description Matches the request message ID
       */
      messageId: number;
      /** @description Response status code indicating success or specific error condition */
      responseCode: components['schemas']['ResponseCodes'];
      /**
       * Format: byte
       * @description Optional response payload
       */
      payload?: string | null;
    };
    /**
     * @description Authentication state change events (login, logout, token refresh).
     *     Triggers session capability updates for connected clients.
     */
    AuthEvent: {
      /** @description Session ID affected by the auth event */
      sessionId: string;
      /** @description Type of authentication event (Login, Logout, TokenRefresh, PermissionChange) */
      eventType: components['schemas']['AuthEventType'];
      /**
       * Format: date-time
       * @description When the auth event occurred
       */
      timestamp: string;
      /** @description User ID associated with the session (optional for some events) */
      userId?: string | null;
      /** @description Additional event metadata (device info, location, etc.) */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
    /**
     * @description Type of authentication event that occurred
     * @enum {string}
     */
    AuthEventType: 'Login' | 'Logout' | 'TokenRefresh' | 'PermissionChange';
    /**
     * @description Event for server-to-client push messaging.
     *     Allows services to send messages directly to connected WebSocket clients.
     */
    ClientMessageEvent: {
      /** @description Target client session ID */
      clientId: string;
      /** @description Name of the service sending the message */
      serviceName?: string | null;
      /**
       * Format: uuid
       * @description Service GUID for routing
       */
      serviceGuid: string;
      /**
       * Format: int64
       * @description Unique message ID for correlation
       */
      messageId: number;
      /**
       * Format: byte
       * @description Message payload (binary data)
       */
      payload: string;
      /** @description Bit flags controlling message behavior (binary, encrypted, compressed, etc.) */
      flags?: components['schemas']['MessageFlags'];
      /**
       * Format: uint16
       * @description Channel for message routing
       * @default 0
       */
      channel: number;
      /**
       * Format: date-time
       * @description When the message was sent
       */
      timestamp?: string | null;
    };
    /**
     * @description Event for bidirectional RPC where services call clients and expect responses.
     *     Extends ClientMessageEvent with response handling.
     */
    ClientRPCEvent: {
      /** @description Target client session ID */
      clientId: string;
      /** @description Name of the service making the RPC call */
      serviceName?: string | null;
      /**
       * Format: uuid
       * @description Service GUID for routing
       */
      serviceGuid: string;
      /**
       * Format: int64
       * @description Unique message ID for correlation
       */
      messageId: number;
      /**
       * Format: byte
       * @description RPC request payload (binary data)
       */
      payload: string;
      /** @description Bit flags controlling message behavior (binary, encrypted, compressed, etc.) */
      flags?: components['schemas']['MessageFlags'];
      /**
       * Format: uint16
       * @description Channel for message routing
       * @default 0
       */
      channel: number;
      /** @description RabbitMQ channel for sending response back to service */
      responseChannel: string;
      /**
       * @description RPC timeout in seconds
       * @default 30
       */
      timeoutSeconds: number;
      /**
       * Format: date-time
       * @description When the RPC was initiated
       */
      timestamp?: string | null;
    };
    /**
     * @description Response event for bidirectional RPC from client back to service.
     *     Published by Connect when a client responds to a ClientRPCEvent.
     */
    ClientRPCResponseEvent: {
      /** @description Client session ID that sent the response */
      clientId: string;
      /** @description Name of the service that initiated the RPC */
      serviceName?: string | null;
      /**
       * Format: uuid
       * @description Service GUID from the original RPC
       */
      serviceGuid?: string | null;
      /**
       * Format: int64
       * @description Message ID for correlation with original request
       */
      messageId: number;
      /**
       * Format: byte
       * @description RPC response payload (binary data)
       */
      payload: string;
      /**
       * Format: uint16
       * @description Response code (0 = success, non-zero = error)
       */
      responseCode: number;
      /**
       * Format: date-time
       * @description When the response was received
       */
      timestamp?: string | null;
    };
    /**
     * @description Event to trigger permission recompilation for all sessions.
     *     Published when services register new APIs or permission rules change.
     */
    PermissionRecompileEvent: {
      /** @description Unique identifier for this recompilation event */
      eventId: string;
      /**
       * Format: date-time
       * @description When the recompilation was triggered
       */
      timestamp: string;
      /**
       * @description Reason for triggering permission recompilation
       * @enum {string}
       */
      reason:
        | 'service_registered'
        | 'permission_rules_changed'
        | 'role_definitions_updated'
        | 'manual_trigger';
      /** @description Service ID that triggered the recompilation (if applicable) */
      serviceId?: string | null;
      /** @description Additional context for the recompilation */
      metadata?: {
        [key: string]: unknown;
      } | null;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  proxyInternalRequest: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['InternalProxyRequest'];
      };
    };
    responses: {
      /** @description Request proxied successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['InternalProxyResponse'];
        };
      };
      /** @description Permission denied */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Target service or endpoint not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Rate limit exceeded */
      429: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getClientCapabilities: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetClientCapabilitiesRequest'];
      };
    };
    responses: {
      /** @description Client capabilities retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ClientCapabilitiesResponse'];
        };
      };
      /** @description Not authenticated - requires valid session */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error retrieving capabilities */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ConnectWebSocket: {
    parameters: {
      query?: never;
      header: {
        /** @description Must be "Upgrade" to initiate WebSocket connection */
        Connection: 'Upgrade';
        /** @description Must be "websocket" to specify protocol upgrade */
        Upgrade: 'websocket';
        /**
         * @description JWT Bearer token for new connections: "Bearer <jwt_token>"
         *     Reconnect token for existing sessions: "Reconnect <reconnect_token>"
         */
        Authorization: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description WebSocket connection established successfully */
      101: {
        headers: {
          /** @description Confirms protocol upgrade to WebSocket */
          Upgrade?: 'websocket';
          /** @description Confirms connection upgrade */
          Connection?: 'Upgrade';
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request - missing required headers or invalid request format */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden - invalid JWT token or reconnection token */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error during connection setup */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ConnectWebSocketPost: {
    parameters: {
      query?: never;
      header: {
        Connection: 'Upgrade';
        Upgrade: 'websocket';
        Authorization: string;
      };
      path?: never;
      cookie?: never;
    };
    /** @description Optional connection parameters */
    requestBody?: {
      content: {
        'application/json': components['schemas']['ConnectRequest'];
      };
    };
    responses: {
      /** @description WebSocket connection established successfully */
      101: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  getAccountSessions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAccountSessionsRequest'];
      };
    };
    responses: {
      /** @description Account sessions retrieved successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['GetAccountSessionsResponse'];
        };
      };
      /** @description Invalid request (missing account ID) */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Permission denied */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Error retrieving sessions */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
