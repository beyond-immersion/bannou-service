{"version":3,"sources":["../src/IBannouClient.ts","../src/ConnectionState.ts","../src/EventSubscription.ts","../src/GuidGenerator.ts","../src/protocol/MessageFlags.ts","../src/protocol/ResponseCodes.ts","../src/protocol/NetworkByteOrder.ts","../src/protocol/BinaryMessage.ts","../src/BannouClient.ts"],"names":["DisconnectReason","MetaType","isResponse","isSuccess","isError","isMeta","BannouJson","ApiResponse","createErrorResponse"],"mappings":"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","file":"index.cjs","sourcesContent":["/**\n * Interface for the Bannou WebSocket client.\n * Provides a mockable interface for testing.\n */\n\nimport type { ApiResponse, BaseClientEvent } from '@beyondimmersion/bannou-core';\nimport type { IEventSubscription } from './EventSubscription.js';\n\n/**\n * Disconnect reason codes.\n */\nexport enum DisconnectReason {\n  /** Normal client-initiated disconnect */\n  ClientDisconnect = 'client_disconnect',\n  /** Server closed the connection */\n  ServerClose = 'server_close',\n  /** Network error or connection lost */\n  NetworkError = 'network_error',\n  /** Session expired (token invalid) */\n  SessionExpired = 'session_expired',\n  /** Server is shutting down */\n  ServerShutdown = 'server_shutdown',\n  /** Kicked by admin or anti-cheat */\n  Kicked = 'kicked',\n}\n\n/**\n * Information about a disconnect event.\n */\nexport interface DisconnectInfo {\n  /** Reason for the disconnect */\n  reason: DisconnectReason;\n  /** Human-readable message */\n  message?: string;\n  /** Reconnection token (if server provided one) */\n  reconnectionToken?: string;\n  /** Whether reconnection is possible */\n  canReconnect: boolean;\n  /** WebSocket close code (if available) */\n  closeCode?: number;\n}\n\n/**\n * Meta type for endpoint metadata requests.\n */\nexport enum MetaType {\n  /** Basic endpoint info (summary, description, tags) */\n  EndpointInfo = 0,\n  /** JSON Schema for request body */\n  RequestSchema = 1,\n  /** JSON Schema for response body */\n  ResponseSchema = 2,\n  /** Full schema (info + request + response) */\n  FullSchema = 3,\n}\n\n/**\n * Endpoint information from meta request.\n */\nexport interface EndpointInfoData {\n  summary?: string;\n  description?: string;\n  tags?: string[];\n  deprecated?: boolean;\n}\n\n/**\n * JSON Schema data from meta request.\n */\nexport interface JsonSchemaData {\n  schema: Record<string, unknown>;\n}\n\n/**\n * Full schema data from meta request.\n */\nexport interface FullSchemaData {\n  info: EndpointInfoData;\n  requestSchema?: Record<string, unknown>;\n  responseSchema?: Record<string, unknown>;\n}\n\n/**\n * Meta response wrapper.\n */\nexport interface MetaResponse<T> {\n  data: T;\n  endpointKey: string;\n  metaType: MetaType;\n}\n\n/**\n * Interface for the Bannou WebSocket client.\n */\nexport interface IBannouClient {\n  /**\n   * Whether the client is currently connected.\n   */\n  readonly isConnected: boolean;\n\n  /**\n   * Session ID assigned by the server after connection.\n   */\n  readonly sessionId: string | undefined;\n\n  /**\n   * All available API endpoints with their client-salted GUIDs.\n   * Key format: \"/path\" (e.g., \"/species/get\")\n   */\n  readonly availableApis: ReadonlyMap<string, string>;\n\n  /**\n   * Current access token (JWT).\n   */\n  readonly accessToken: string | undefined;\n\n  /**\n   * Current refresh token for re-authentication.\n   */\n  readonly refreshToken: string | undefined;\n\n  /**\n   * Last error message from a failed operation.\n   */\n  readonly lastError: string | undefined;\n\n  /**\n   * Connects to a Bannou server using username/password authentication.\n   * @param serverUrl - Base URL (e.g., \"http://localhost:8080\" or \"https://game.example.com\")\n   * @param email - Account email\n   * @param password - Account password\n   * @returns True if connection successful\n   */\n  connectAsync(serverUrl: string, email: string, password: string): Promise<boolean>;\n\n  /**\n   * Connects using an existing JWT token.\n   * @param serverUrl - Base URL (e.g., \"http://localhost:8080\")\n   * @param accessToken - Valid JWT access token\n   * @param refreshToken - Optional refresh token for re-authentication\n   * @returns True if connection successful\n   */\n  connectWithTokenAsync(\n    serverUrl: string,\n    accessToken: string,\n    refreshToken?: string\n  ): Promise<boolean>;\n\n  /**\n   * Connects in internal mode using a service token (or network-trust if token\n   * is null) without JWT login.\n   * @param connectUrl - Full WebSocket URL to the Connect service (internal)\n   * @param serviceToken - Optional X-Service-Token for internal auth mode\n   * @returns True if connection successful\n   */\n  connectInternalAsync(connectUrl: string, serviceToken?: string): Promise<boolean>;\n\n  /**\n   * Registers a new account and connects.\n   * @param serverUrl - Base URL\n   * @param username - Desired username\n   * @param email - Email address\n   * @param password - Password\n   * @returns True if registration and connection successful\n   */\n  registerAndConnectAsync(\n    serverUrl: string,\n    username: string,\n    email: string,\n    password: string\n  ): Promise<boolean>;\n\n  /**\n   * Gets the service GUID for a specific API endpoint.\n   * @param endpoint - API path (e.g., \"/account/get\")\n   * @returns The client-salted GUID, or undefined if not found\n   */\n  getServiceGuid(endpoint: string): string | undefined;\n\n  /**\n   * Invokes a service method by specifying the API endpoint path.\n   * @param endpoint - API path (e.g., \"/account/get\")\n   * @param request - Request payload\n   * @param channel - Message channel for ordering (default 0)\n   * @param timeout - Request timeout in milliseconds\n   * @returns ApiResponse containing either the success result or error details\n   */\n  invokeAsync<TRequest, TResponse>(\n    endpoint: string,\n    request: TRequest,\n    channel?: number,\n    timeout?: number\n  ): Promise<ApiResponse<TResponse>>;\n\n  /**\n   * Sends a fire-and-forget event (no response expected).\n   * @param endpoint - API path (e.g., \"/events/publish\")\n   * @param request - Request payload\n   * @param channel - Message channel for ordering\n   */\n  sendEventAsync<TRequest>(endpoint: string, request: TRequest, channel?: number): Promise<void>;\n\n  /**\n   * Subscribe to a typed event with automatic deserialization.\n   * @param eventName - Event name to subscribe to\n   * @param handler - Handler to invoke when event is received\n   * @returns Subscription handle - call dispose() to unsubscribe\n   */\n  onEvent<TEvent extends BaseClientEvent>(\n    eventName: string,\n    handler: (event: TEvent) => void\n  ): IEventSubscription;\n\n  /**\n   * Subscribe to raw event JSON.\n   * @param eventName - Event name to subscribe to\n   * @param handler - Handler to invoke with raw JSON payload\n   * @returns Subscription handle - call dispose() to unsubscribe\n   */\n  onRawEvent(eventName: string, handler: (json: string) => void): IEventSubscription;\n\n  /**\n   * Removes all event handlers for a specific event.\n   */\n  removeEventHandlers(eventName: string): void;\n\n  /**\n   * Disconnects from the server.\n   */\n  disconnectAsync(): Promise<void>;\n\n  // Lifecycle callbacks\n\n  /**\n   * Set callback for when the connection is closed.\n   */\n  set onDisconnect(callback: ((info: DisconnectInfo) => void) | null);\n\n  /**\n   * Set callback for when a connection error occurs.\n   */\n  set onError(callback: ((error: Error) => void) | null);\n\n  /**\n   * Set callback for when event handlers throw exceptions.\n   */\n  set onEventHandlerFailed(callback: ((error: Error) => void) | null);\n\n  // Meta requests\n\n  /**\n   * Requests metadata about an endpoint instead of executing it.\n   * @param endpoint - API path (e.g., \"/account/get\")\n   * @param metaType - Type of metadata to request\n   * @param timeout - Request timeout in milliseconds\n   */\n  getEndpointMetaAsync<T>(\n    endpoint: string,\n    metaType?: MetaType,\n    timeout?: number\n  ): Promise<MetaResponse<T>>;\n\n  /**\n   * Gets human-readable endpoint information (summary, description, tags).\n   * @param endpoint - API path (e.g., \"/account/get\")\n   */\n  getEndpointInfoAsync(endpoint: string): Promise<MetaResponse<EndpointInfoData>>;\n\n  /**\n   * Gets JSON Schema for the request body of an endpoint.\n   * @param endpoint - API path (e.g., \"/account/get\")\n   */\n  getRequestSchemaAsync(endpoint: string): Promise<MetaResponse<JsonSchemaData>>;\n\n  /**\n   * Gets JSON Schema for the response body of an endpoint.\n   * @param endpoint - API path (e.g., \"/account/get\")\n   */\n  getResponseSchemaAsync(endpoint: string): Promise<MetaResponse<JsonSchemaData>>;\n\n  /**\n   * Gets full schema including info, request schema, and response schema.\n   * @param endpoint - API path (e.g., \"/account/get\")\n   */\n  getFullSchemaAsync(endpoint: string): Promise<MetaResponse<FullSchemaData>>;\n\n  // Reconnection\n\n  /**\n   * Reconnects using a reconnection token from a DisconnectNotificationEvent.\n   * @param reconnectionToken - Token provided by the server\n   */\n  reconnectWithTokenAsync(reconnectionToken: string): Promise<boolean>;\n\n  /**\n   * Refreshes the access token using the stored refresh token.\n   * Requires a valid refresh token from previous login/registration.\n   * @returns True if refresh successful, false otherwise\n   */\n  refreshAccessTokenAsync(): Promise<boolean>;\n\n  /**\n   * Set callback for when tokens are refreshed.\n   * Useful for persisting updated tokens.\n   */\n  set onTokenRefreshed(\n    callback: ((accessToken: string, refreshToken: string | undefined) => void) | null\n  );\n}\n","/**\n * Manages connection state for a BannouClient session.\n * Tracks sequence numbers, pending requests, and service mappings.\n */\nexport class ConnectionState {\n  /** Session ID assigned by the server */\n  readonly sessionId: string;\n\n  /** Per-channel sequence numbers for message ordering */\n  private readonly sequenceNumbers: Map<number, number> = new Map();\n\n  /** Service GUID mappings from capability manifest */\n  private readonly serviceMappings: Map<string, string> = new Map();\n\n  /** Pending message tracking for debugging */\n  private readonly pendingMessages: Map<bigint, PendingMessageInfo> = new Map();\n\n  constructor(sessionId: string) {\n    this.sessionId = sessionId;\n  }\n\n  /**\n   * Gets the next sequence number for a channel and increments it.\n   */\n  getNextSequenceNumber(channel: number): number {\n    const current = this.sequenceNumbers.get(channel) ?? 0;\n    this.sequenceNumbers.set(channel, current + 1);\n    return current;\n  }\n\n  /**\n   * Gets the current sequence number for a channel without incrementing.\n   */\n  getCurrentSequenceNumber(channel: number): number {\n    return this.sequenceNumbers.get(channel) ?? 0;\n  }\n\n  /**\n   * Adds a service mapping from endpoint key to GUID.\n   */\n  addServiceMapping(endpointKey: string, guid: string): void {\n    this.serviceMappings.set(endpointKey, guid);\n  }\n\n  /**\n   * Gets the service GUID for an endpoint key.\n   */\n  getServiceGuid(endpointKey: string): string | undefined {\n    return this.serviceMappings.get(endpointKey);\n  }\n\n  /**\n   * Gets all service mappings.\n   */\n  getServiceMappings(): ReadonlyMap<string, string> {\n    return this.serviceMappings;\n  }\n\n  /**\n   * Clears all service mappings (for capability manifest updates).\n   */\n  clearServiceMappings(): void {\n    this.serviceMappings.clear();\n  }\n\n  /**\n   * Tracks a pending message for debugging.\n   */\n  addPendingMessage(messageId: bigint, endpointKey: string, sentAt: Date): void {\n    this.pendingMessages.set(messageId, {\n      endpointKey,\n      sentAt,\n    });\n  }\n\n  /**\n   * Removes a pending message after response or timeout.\n   */\n  removePendingMessage(messageId: bigint): void {\n    this.pendingMessages.delete(messageId);\n  }\n\n  /**\n   * Gets pending message info for debugging.\n   */\n  getPendingMessage(messageId: bigint): PendingMessageInfo | undefined {\n    return this.pendingMessages.get(messageId);\n  }\n\n  /**\n   * Gets count of pending messages.\n   */\n  getPendingMessageCount(): number {\n    return this.pendingMessages.size;\n  }\n}\n\n/**\n * Information about a pending message.\n */\nexport interface PendingMessageInfo {\n  endpointKey: string;\n  sentAt: Date;\n}\n","/**\n * Represents a subscription to client events.\n * Call dispose() to unsubscribe.\n */\nexport interface IEventSubscription {\n  /**\n   * The event name this subscription is for.\n   */\n  readonly eventName: string;\n\n  /**\n   * Unique identifier for this subscription.\n   */\n  readonly subscriptionId: string;\n\n  /**\n   * Unsubscribe from the event.\n   */\n  dispose(): void;\n}\n\n/**\n * Implementation of IEventSubscription.\n */\nexport class EventSubscription implements IEventSubscription {\n  readonly eventName: string;\n  readonly subscriptionId: string;\n  private readonly disposeCallback: (subscriptionId: string) => void;\n  private disposed = false;\n\n  constructor(\n    eventName: string,\n    subscriptionId: string,\n    disposeCallback: (subscriptionId: string) => void\n  ) {\n    this.eventName = eventName;\n    this.subscriptionId = subscriptionId;\n    this.disposeCallback = disposeCallback;\n  }\n\n  dispose(): void {\n    if (!this.disposed) {\n      this.disposed = true;\n      this.disposeCallback(this.subscriptionId);\n    }\n  }\n}\n","/**\n * Generates unique message IDs and GUIDs for the Bannou protocol.\n */\n\n/**\n * Counter for generating unique message IDs within a session.\n * Uses BigInt to support the 64-bit message ID space.\n */\nlet messageIdCounter = 0n;\n\n/**\n * Generates a unique message ID for request/response correlation.\n * Message IDs are 64-bit unsigned integers.\n */\nexport function generateMessageId(): bigint {\n  // Combine timestamp with counter for uniqueness across sessions\n  const timestamp = BigInt(Date.now()) << 16n;\n  const counter = messageIdCounter++ & 0xffffn;\n  return timestamp | counter;\n}\n\n/**\n * Generates a random UUID v4.\n * Uses crypto.randomUUID() if available, otherwise falls back to manual generation.\n */\nexport function generateUuid(): string {\n  // Use native crypto.randomUUID if available (modern browsers and Node.js 19+)\n  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\n    return crypto.randomUUID();\n  }\n\n  // Fallback: manual UUID v4 generation\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/**\n * Resets the message ID counter (for testing).\n */\nexport function resetMessageIdCounter(): void {\n  messageIdCounter = 0n;\n}\n","/**\n * Bit flags controlling message behavior in the enhanced 31-byte binary protocol.\n * These flags provide zero-copy routing and performance optimizations.\n *\n * Flags can be combined using bitwise OR operations.\n *\n * @example\n * ```typescript\n * const flags = MessageFlags.Binary | MessageFlags.HighPriority;\n * ```\n */\nexport const MessageFlags = {\n  /**\n   * Default - JSON text, service request, unencrypted, standard priority, expects response\n   */\n  None: 0x00,\n\n  /**\n   * Message payload is binary data (not JSON)\n   */\n  Binary: 0x01,\n\n  /**\n   * Message payload is encrypted\n   */\n  Encrypted: 0x02,\n\n  /**\n   * Message payload is compressed (gzip)\n   */\n  Compressed: 0x04,\n\n  /**\n   * Deliver at high priority, skip to front of queues\n   */\n  HighPriority: 0x08,\n\n  /**\n   * Fire-and-forget message, no response expected\n   */\n  Event: 0x10,\n\n  /**\n   * Route to another WebSocket client (not a Bannou service)\n   */\n  Client: 0x20,\n\n  /**\n   * Message is a response to an RPC (not a new request)\n   */\n  Response: 0x40,\n\n  /**\n   * Request metadata about endpoint instead of executing it.\n   * When set, the Channel field specifies the meta type:\n   * 0 = endpoint-info, 1 = request-schema, 2 = response-schema, 3 = full-schema.\n   * Connect service transforms the path and routes to companion endpoints.\n   */\n  Meta: 0x80,\n} as const;\n\nexport type MessageFlagsType = (typeof MessageFlags)[keyof typeof MessageFlags];\n\n/**\n * Check if a flags byte has a specific flag set.\n */\nexport function hasFlag(flags: number, flag: number): boolean {\n  return (flags & flag) === flag;\n}\n\n/**\n * Check if this is a response message.\n */\nexport function isResponse(flags: number): boolean {\n  return hasFlag(flags, MessageFlags.Response);\n}\n\n/**\n * Check if this is an event message (fire-and-forget).\n */\nexport function isEvent(flags: number): boolean {\n  return hasFlag(flags, MessageFlags.Event);\n}\n\n/**\n * Check if this is a meta request.\n */\nexport function isMeta(flags: number): boolean {\n  return hasFlag(flags, MessageFlags.Meta);\n}\n\n/**\n * Check if payload is binary (not JSON).\n */\nexport function isBinary(flags: number): boolean {\n  return hasFlag(flags, MessageFlags.Binary);\n}\n","/**\n * Response codes used in the binary WebSocket protocol for success/error indication.\n * These codes are returned in the response header's ResponseCode field.\n *\n * Code ranges:\n * - 0-49: Protocol-level errors (Connect service)\n * - 50-69: Service-level errors (downstream service responses)\n * - 70+: Shortcut-specific errors\n */\nexport const ResponseCodes = {\n  /** Request completed successfully. */\n  OK: 0,\n\n  /** Generic request error (malformed message, invalid format). */\n  RequestError: 10,\n\n  /** Request payload exceeds maximum allowed size. */\n  RequestTooLarge: 11,\n\n  /** Rate limit exceeded for this client/session. */\n  TooManyRequests: 12,\n\n  /** Invalid channel number in request header. */\n  InvalidRequestChannel: 13,\n\n  /** Authentication required but not provided or invalid. */\n  Unauthorized: 20,\n\n  /** Target service GUID not found in capability manifest. */\n  ServiceNotFound: 30,\n\n  /** Target client GUID not found (for client-to-client messages). */\n  ClientNotFound: 31,\n\n  /** Referenced message ID not found. */\n  MessageNotFound: 32,\n\n  /** Broadcast not allowed in this connection mode (External mode blocks broadcast). */\n  BroadcastNotAllowed: 40,\n\n  /** Service returned 400 Bad Request. */\n  Service_BadRequest: 50,\n\n  /** Service returned 404 Not Found. */\n  Service_NotFound: 51,\n\n  /** Service returned 401/403 Unauthorized/Forbidden. */\n  Service_Unauthorized: 52,\n\n  /** Service returned 409 Conflict. */\n  Service_Conflict: 53,\n\n  /** Service returned 500 Internal Server Error. */\n  Service_InternalServerError: 60,\n\n  /** Shortcut has expired and is no longer valid. */\n  ShortcutExpired: 70,\n\n  /** Shortcut target endpoint no longer exists. */\n  ShortcutTargetNotFound: 71,\n\n  /** Shortcut was explicitly revoked. */\n  ShortcutRevoked: 72,\n} as const;\n\nexport type ResponseCodesType = (typeof ResponseCodes)[keyof typeof ResponseCodes];\n\n/**\n * Maps protocol response codes to HTTP status codes.\n * This hides the binary protocol implementation details from client code.\n */\nexport function mapToHttpStatus(code: number): number {\n  switch (code) {\n    case ResponseCodes.OK:\n      return 200;\n    case ResponseCodes.RequestError:\n    case ResponseCodes.RequestTooLarge:\n    case ResponseCodes.InvalidRequestChannel:\n    case ResponseCodes.Service_BadRequest:\n      return 400;\n    case ResponseCodes.Unauthorized:\n    case ResponseCodes.Service_Unauthorized:\n      return 401;\n    case ResponseCodes.TooManyRequests:\n      return 429;\n    case ResponseCodes.ServiceNotFound:\n    case ResponseCodes.ClientNotFound:\n    case ResponseCodes.MessageNotFound:\n    case ResponseCodes.Service_NotFound:\n    case ResponseCodes.ShortcutTargetNotFound:\n      return 404;\n    case ResponseCodes.Service_Conflict:\n      return 409;\n    case ResponseCodes.BroadcastNotAllowed:\n      return 403;\n    case ResponseCodes.ShortcutExpired:\n    case ResponseCodes.ShortcutRevoked:\n      return 410; // Gone\n    case ResponseCodes.Service_InternalServerError:\n    default:\n      return 500;\n  }\n}\n\n/**\n * Gets a human-readable error name for a response code.\n */\nexport function getResponseCodeName(code: number): string {\n  const entries = Object.entries(ResponseCodes);\n  for (const [name, value] of entries) {\n    if (value === code) {\n      return name;\n    }\n  }\n  return 'UnknownError';\n}\n\n/**\n * Check if a response code indicates success.\n */\nexport function isSuccess(code: number): boolean {\n  return code === ResponseCodes.OK;\n}\n\n/**\n * Check if a response code indicates an error.\n */\nexport function isError(code: number): boolean {\n  return code !== ResponseCodes.OK;\n}\n","/**\n * Network byte order utilities for cross-platform binary protocol compatibility.\n * Ensures consistent endianness across all client and server implementations.\n *\n * All multi-byte integers in the Bannou protocol use BIG-ENDIAN (network) byte order.\n * GUIDs follow RFC 4122 network byte ordering.\n */\n\n/**\n * Writes a 16-bit unsigned integer in network byte order (big-endian).\n */\nexport function writeUInt16(view: DataView, offset: number, value: number): void {\n  view.setUint16(offset, value, false); // false = big-endian\n}\n\n/**\n * Writes a 32-bit unsigned integer in network byte order (big-endian).\n */\nexport function writeUInt32(view: DataView, offset: number, value: number): void {\n  view.setUint32(offset, value, false); // false = big-endian\n}\n\n/**\n * Writes a 64-bit unsigned integer in network byte order (big-endian).\n * JavaScript's DataView doesn't have native BigInt support in all versions,\n * so we write it as two 32-bit values.\n */\nexport function writeUInt64(view: DataView, offset: number, value: bigint): void {\n  const high = Number(value >> 32n);\n  const low = Number(value & 0xffffffffn);\n  view.setUint32(offset, high, false); // High 32 bits first (big-endian)\n  view.setUint32(offset + 4, low, false); // Low 32 bits second\n}\n\n/**\n * Reads a 16-bit unsigned integer from network byte order (big-endian).\n */\nexport function readUInt16(view: DataView, offset: number): number {\n  return view.getUint16(offset, false); // false = big-endian\n}\n\n/**\n * Reads a 32-bit unsigned integer from network byte order (big-endian).\n */\nexport function readUInt32(view: DataView, offset: number): number {\n  return view.getUint32(offset, false); // false = big-endian\n}\n\n/**\n * Reads a 64-bit unsigned integer from network byte order (big-endian).\n */\nexport function readUInt64(view: DataView, offset: number): bigint {\n  const high = BigInt(view.getUint32(offset, false));\n  const low = BigInt(view.getUint32(offset + 4, false));\n  return (high << 32n) | low;\n}\n\n/**\n * Writes a GUID in consistent network byte order.\n * Uses RFC 4122 standard byte ordering for cross-platform compatibility.\n *\n * CRITICAL: The GUID string is already in RFC 4122 display format (big-endian),\n * so we write the parsed bytes directly WITHOUT reversal.\n *\n * This differs from C# which uses Guid.ToByteArray() that returns little-endian\n * for time fields, requiring reversal. TypeScript parses the string directly\n * which is already big-endian.\n *\n * @param view - DataView to write to\n * @param offset - Byte offset to start writing\n * @param guid - GUID string in standard format (e.g., \"12345678-1234-5678-9abc-def012345678\")\n */\nexport function writeGuid(view: DataView, offset: number, guid: string): void {\n  // Parse GUID string (format: \"12345678-1234-5678-9abc-def012345678\")\n  const cleanGuid = guid.replace(/-/g, '');\n\n  if (cleanGuid.length !== 32) {\n    throw new Error(`Invalid GUID format: ${guid}`);\n  }\n\n  // Parse each hex pair as bytes and write directly.\n  // The GUID string is already in RFC 4122 big-endian display format,\n  // so NO byte reversal is needed (unlike C# which reverses from little-endian).\n  for (let i = 0; i < 16; i++) {\n    const byte = parseInt(cleanGuid.slice(i * 2, i * 2 + 2), 16);\n    view.setUint8(offset + i, byte);\n  }\n}\n\n/**\n * Reads a GUID from consistent network byte order.\n * Uses RFC 4122 standard byte ordering for cross-platform compatibility.\n *\n * CRITICAL: Bytes are read directly without reversal because they're stored\n * in RFC 4122 big-endian format, which matches the GUID string display format.\n *\n * @param view - DataView to read from\n * @param offset - Byte offset to start reading\n * @returns GUID string in standard format (lowercase)\n */\nexport function readGuid(view: DataView, offset: number): string {\n  // Read bytes directly - they're already in RFC 4122 big-endian format\n  // which matches the GUID string display format (no reversal needed)\n  const hexParts: string[] = [];\n  for (let i = 0; i < 16; i++) {\n    hexParts.push(\n      view\n        .getUint8(offset + i)\n        .toString(16)\n        .padStart(2, '0')\n    );\n  }\n  const hex = hexParts.join('');\n\n  return (\n    `${hex.slice(0, 8)}-${hex.slice(8, 12)}-${hex.slice(12, 16)}-` +\n    `${hex.slice(16, 20)}-${hex.slice(20, 32)}`\n  );\n}\n\n/**\n * Generates an empty GUID (all zeros).\n */\nexport const EMPTY_GUID = '00000000-0000-0000-0000-000000000000';\n\n/**\n * Tests cross-platform compatibility of network byte order operations.\n * Useful for unit testing and validation.\n */\nexport function testNetworkByteOrderCompatibility(): boolean {\n  try {\n    const buffer = new ArrayBuffer(32);\n    const view = new DataView(buffer);\n\n    // Test all data types\n    writeUInt16(view, 0, 0x1234);\n    writeUInt32(view, 2, 0x12345678);\n    writeUInt64(view, 6, 0x123456789abcdef0n);\n\n    const testGuid = '12345678-1234-5678-9abc-def012345678';\n    writeGuid(view, 14, testGuid);\n\n    // Read back and verify\n    const readU16 = readUInt16(view, 0);\n    const readU32 = readUInt32(view, 2);\n    const readU64 = readUInt64(view, 6);\n    const readG = readGuid(view, 14);\n\n    return (\n      readU16 === 0x1234 &&\n      readU32 === 0x12345678 &&\n      readU64 === 0x123456789abcdef0n &&\n      readG === testGuid\n    );\n  } catch {\n    return false;\n  }\n}\n","/**\n * Represents a complete binary message in the Bannou WebSocket protocol.\n * Request messages use a 31-byte header, response messages use a 16-byte header.\n * Provides zero-copy parsing and serialization for optimal performance.\n */\n\nimport { MessageFlags, hasFlag, isResponse as checkIsResponse } from './MessageFlags.js';\nimport {\n  readUInt16,\n  readUInt32,\n  readUInt64,\n  readGuid,\n  writeUInt16,\n  writeUInt32,\n  writeUInt64,\n  writeGuid,\n  EMPTY_GUID,\n} from './NetworkByteOrder.js';\n\n/**\n * Size of the binary header in bytes for request messages.\n *\n * Request header layout (31 bytes):\n * - [0]     Flags (1 byte)\n * - [1-2]   Channel (uint16 BE)\n * - [3-6]   Sequence (uint32 BE)\n * - [7-22]  ServiceGUID (16 bytes, RFC 4122)\n * - [23-30] MessageID (uint64 BE)\n * - [31+]   Payload (JSON UTF-8)\n */\nexport const HEADER_SIZE = 31;\n\n/**\n * Size of the binary header in bytes for response messages.\n * Response headers are smaller because ServiceGuid is not needed (client correlates via MessageId).\n *\n * Response header layout (16 bytes):\n * - [0]     Flags (1 byte, Response flag set)\n * - [1-2]   Channel (uint16 BE)\n * - [3-6]   Sequence (uint32 BE)\n * - [7-14]  MessageID (uint64 BE)\n * - [15]    ResponseCode (1 byte)\n * - [16+]   Payload (empty for errors)\n */\nexport const RESPONSE_HEADER_SIZE = 16;\n\n/**\n * Represents a parsed or constructed binary message.\n */\nexport interface BinaryMessage {\n  /** Message behavior flags */\n  flags: number;\n\n  /** Channel for sequential message processing (0-65535, 0 = default) */\n  channel: number;\n\n  /** Per-channel sequence number for message ordering */\n  sequenceNumber: number;\n\n  /** Client-salted service GUID for routing (only used in request messages) */\n  serviceGuid: string;\n\n  /** Unique message ID for request/response correlation */\n  messageId: bigint;\n\n  /** Response code for response messages (0 = OK, non-zero = error) */\n  responseCode: number;\n\n  /** Message payload (JSON or binary data based on flags) */\n  payload: Uint8Array;\n}\n\n/**\n * Creates a request message.\n */\nexport function createRequest(\n  flags: number,\n  channel: number,\n  sequenceNumber: number,\n  serviceGuid: string,\n  messageId: bigint,\n  payload: Uint8Array\n): BinaryMessage {\n  return {\n    flags,\n    channel,\n    sequenceNumber,\n    serviceGuid,\n    messageId,\n    responseCode: 0,\n    payload,\n  };\n}\n\n/**\n * Creates a response message.\n */\nexport function createResponse(\n  flags: number,\n  channel: number,\n  sequenceNumber: number,\n  messageId: bigint,\n  responseCode: number,\n  payload: Uint8Array\n): BinaryMessage {\n  return {\n    flags: flags | MessageFlags.Response,\n    channel,\n    sequenceNumber,\n    serviceGuid: EMPTY_GUID,\n    messageId,\n    responseCode,\n    payload,\n  };\n}\n\n/**\n * Creates a binary message from a JSON string payload.\n */\nexport function fromJson(\n  channel: number,\n  sequenceNumber: number,\n  serviceGuid: string,\n  messageId: bigint,\n  jsonPayload: string,\n  additionalFlags: number = MessageFlags.None\n): BinaryMessage {\n  const payloadBytes = new TextEncoder().encode(jsonPayload);\n  return createRequest(\n    additionalFlags,\n    channel,\n    sequenceNumber,\n    serviceGuid,\n    messageId,\n    payloadBytes\n  );\n}\n\n/**\n * Gets the JSON payload as a string (if the message is JSON).\n * @throws Error if the message has the Binary flag set\n */\nexport function getJsonPayload(message: BinaryMessage): string {\n  if (hasFlag(message.flags, MessageFlags.Binary)) {\n    throw new Error('Cannot get JSON payload from binary message');\n  }\n  return new TextDecoder().decode(message.payload);\n}\n\n/**\n * Parses a binary message from a byte array.\n * Automatically detects whether this is a request (31-byte header) or response (16-byte header).\n */\nexport function parse(buffer: ArrayBuffer | Uint8Array): BinaryMessage {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n\n  if (bytes.length < 1) {\n    throw new Error('Message too short. Expected at least 1 byte for flags.');\n  }\n\n  const flags = view.getUint8(0);\n\n  // Check if this is a response message (16-byte header) or request message (31-byte header)\n  if (checkIsResponse(flags)) {\n    return parseResponse(view, bytes);\n  } else {\n    return parseRequest(view, bytes);\n  }\n}\n\nfunction parseRequest(view: DataView, bytes: Uint8Array): BinaryMessage {\n  if (bytes.length < HEADER_SIZE) {\n    throw new Error(\n      `Request message too short. Expected at least ${HEADER_SIZE} bytes, got ${bytes.length}`\n    );\n  }\n\n  const flags = view.getUint8(0);\n  const channel = readUInt16(view, 1);\n  const sequenceNumber = readUInt32(view, 3);\n  const serviceGuid = readGuid(view, 7);\n  const messageId = readUInt64(view, 23);\n\n  // Extract payload (remaining bytes after 31-byte header)\n  const payload = bytes.slice(HEADER_SIZE);\n\n  return {\n    flags,\n    channel,\n    sequenceNumber,\n    serviceGuid,\n    messageId,\n    responseCode: 0,\n    payload,\n  };\n}\n\nfunction parseResponse(view: DataView, bytes: Uint8Array): BinaryMessage {\n  if (bytes.length < RESPONSE_HEADER_SIZE) {\n    throw new Error(\n      `Response message too short. Expected at least ` +\n        `${RESPONSE_HEADER_SIZE} bytes, got ${bytes.length}`\n    );\n  }\n\n  const flags = view.getUint8(0);\n  const channel = readUInt16(view, 1);\n  const sequenceNumber = readUInt32(view, 3);\n  const messageId = readUInt64(view, 7);\n  const responseCode = view.getUint8(15);\n\n  // Extract payload (remaining bytes after 16-byte header)\n  const payload = bytes.slice(RESPONSE_HEADER_SIZE);\n\n  return {\n    flags,\n    channel,\n    sequenceNumber,\n    serviceGuid: EMPTY_GUID,\n    messageId,\n    responseCode,\n    payload,\n  };\n}\n\n/**\n * Serializes the binary message to a byte array.\n * Uses 31-byte header for requests, 16-byte header for responses.\n */\nexport function toByteArray(message: BinaryMessage): Uint8Array {\n  if (checkIsResponse(message.flags)) {\n    return toResponseByteArray(message);\n  } else {\n    return toRequestByteArray(message);\n  }\n}\n\nfunction toRequestByteArray(message: BinaryMessage): Uint8Array {\n  const totalLength = HEADER_SIZE + message.payload.length;\n  const result = new Uint8Array(totalLength);\n  const view = new DataView(result.buffer);\n\n  // Build 31-byte request header\n  view.setUint8(0, message.flags);\n  writeUInt16(view, 1, message.channel);\n  writeUInt32(view, 3, message.sequenceNumber);\n  writeGuid(view, 7, message.serviceGuid);\n  writeUInt64(view, 23, message.messageId);\n\n  // Append payload\n  if (message.payload.length > 0) {\n    result.set(message.payload, HEADER_SIZE);\n  }\n\n  return result;\n}\n\nfunction toResponseByteArray(message: BinaryMessage): Uint8Array {\n  const totalLength = RESPONSE_HEADER_SIZE + message.payload.length;\n  const result = new Uint8Array(totalLength);\n  const view = new DataView(result.buffer);\n\n  // Build 16-byte response header\n  view.setUint8(0, message.flags);\n  writeUInt16(view, 1, message.channel);\n  writeUInt32(view, 3, message.sequenceNumber);\n  writeUInt64(view, 7, message.messageId);\n  view.setUint8(15, message.responseCode);\n\n  // Append payload (empty for error responses)\n  if (message.payload.length > 0) {\n    result.set(message.payload, RESPONSE_HEADER_SIZE);\n  }\n\n  return result;\n}\n\n/**\n * Returns true if this message expects a response.\n */\nexport function expectsResponse(message: BinaryMessage): boolean {\n  return !hasFlag(message.flags, MessageFlags.Event) && !checkIsResponse(message.flags);\n}\n\n/**\n * Returns true if this message is a response to another message.\n */\nexport function isResponse(message: BinaryMessage): boolean {\n  return checkIsResponse(message.flags);\n}\n\n/**\n * Returns true if this message should be routed to a client (not a service).\n */\nexport function isClientRouted(message: BinaryMessage): boolean {\n  return hasFlag(message.flags, MessageFlags.Client);\n}\n\n/**\n * Returns true if this message has high priority.\n */\nexport function isHighPriority(message: BinaryMessage): boolean {\n  return hasFlag(message.flags, MessageFlags.HighPriority);\n}\n\n/**\n * Returns true if this is a successful response (ResponseCode is 0).\n */\nexport function isSuccess(message: BinaryMessage): boolean {\n  return checkIsResponse(message.flags) && message.responseCode === 0;\n}\n\n/**\n * Returns true if this is an error response (ResponseCode is non-zero).\n */\nexport function isError(message: BinaryMessage): boolean {\n  return checkIsResponse(message.flags) && message.responseCode !== 0;\n}\n\n/**\n * Returns true if this message requests endpoint metadata.\n */\nexport function isMeta(message: BinaryMessage): boolean {\n  return hasFlag(message.flags, MessageFlags.Meta);\n}\n","/**\n * High-level client for connecting to Bannou services via WebSocket.\n * Handles authentication, connection lifecycle, capability discovery, and message correlation.\n */\n\nimport {\n  ApiResponse,\n  BannouJson,\n  type BaseClientEvent,\n  createErrorResponse,\n} from '@beyondimmersion/bannou-core';\nimport type {\n  IBannouClient,\n  DisconnectInfo,\n  MetaResponse,\n  EndpointInfoData,\n  JsonSchemaData,\n  FullSchemaData,\n} from './IBannouClient.js';\nimport { DisconnectReason, MetaType } from './IBannouClient.js';\nimport { ConnectionState } from './ConnectionState.js';\nimport { EventSubscription, type IEventSubscription } from './EventSubscription.js';\nimport { generateMessageId, generateUuid } from './GuidGenerator.js';\nimport {\n  MessageFlags,\n  RESPONSE_HEADER_SIZE,\n  type BinaryMessage,\n  parse,\n  toByteArray,\n  isResponse,\n  getJsonPayload,\n} from './protocol/index.js';\n\n// Type definition for WebSocket (browser or Node.js)\ntype WebSocketType = WebSocket | import('ws').WebSocket;\n\n/** Default request timeout in milliseconds */\nconst DEFAULT_TIMEOUT_MS = 30_000;\n\n/** Capability manifest wait timeout in milliseconds */\nconst CAPABILITY_MANIFEST_TIMEOUT_MS = 30_000;\n\n/** Internal authorization header value */\nconst INTERNAL_AUTHORIZATION_HEADER = 'Internal';\n\n/**\n * Login response from auth service.\n */\ninterface LoginResponse {\n  accessToken?: string;\n  refreshToken?: string;\n  connectUrl?: string;\n}\n\n/**\n * Pending request tracking.\n */\ninterface PendingRequest {\n  resolve: (message: BinaryMessage) => void;\n  reject: (error: Error) => void;\n  timeoutId: ReturnType<typeof setTimeout>;\n}\n\n/**\n * Event handler entry.\n */\ninterface EventHandler {\n  subscriptionId: string;\n  handler: (json: string) => void;\n}\n\n/**\n * High-level client for connecting to Bannou services via WebSocket.\n */\nexport class BannouClient implements IBannouClient {\n  private webSocket: WebSocketType | null = null;\n  private connectionState: ConnectionState | null = null;\n  private readonly pendingRequests = new Map<string, PendingRequest>();\n  private readonly apiMappings = new Map<string, string>();\n  private readonly eventHandlers = new Map<string, EventHandler[]>();\n\n  private _accessToken: string | undefined;\n  private _refreshToken: string | undefined;\n  private serverBaseUrl: string | undefined;\n  private connectUrl: string | undefined;\n  private serviceToken: string | undefined;\n  private _sessionId: string | undefined;\n  private _lastError: string | undefined;\n\n  private capabilityManifestResolver: ((value: boolean) => void) | null = null;\n  private eventHandlerFailedCallback: ((error: Error) => void) | null = null;\n  private disconnectCallback: ((info: DisconnectInfo) => void) | null = null;\n  private errorCallback: ((error: Error) => void) | null = null;\n  private tokenRefreshedCallback:\n    | ((accessToken: string, refreshToken: string | undefined) => void)\n    | null = null;\n  private pendingReconnectionToken: string | undefined;\n  private lastDisconnectInfo: DisconnectInfo | undefined;\n\n  /**\n   * Current connection state.\n   */\n  get isConnected(): boolean {\n    return this.webSocket?.readyState === 1; // WebSocket.OPEN = 1\n  }\n\n  /**\n   * Session ID assigned by the server after connection.\n   */\n  get sessionId(): string | undefined {\n    return this._sessionId;\n  }\n\n  /**\n   * All available API endpoints with their client-salted GUIDs.\n   */\n  get availableApis(): ReadonlyMap<string, string> {\n    return this.apiMappings;\n  }\n\n  /**\n   * Current access token (JWT).\n   */\n  get accessToken(): string | undefined {\n    return this._accessToken;\n  }\n\n  /**\n   * Current refresh token for re-authentication.\n   */\n  get refreshToken(): string | undefined {\n    return this._refreshToken;\n  }\n\n  /**\n   * Last error message from a failed operation.\n   */\n  get lastError(): string | undefined {\n    return this._lastError;\n  }\n\n  /**\n   * Set a callback for when event handlers throw exceptions.\n   */\n  set onEventHandlerFailed(callback: ((error: Error) => void) | null) {\n    this.eventHandlerFailedCallback = callback;\n  }\n\n  /**\n   * Set a callback for when the connection is closed.\n   */\n  set onDisconnect(callback: ((info: DisconnectInfo) => void) | null) {\n    this.disconnectCallback = callback;\n  }\n\n  /**\n   * Set a callback for when a connection error occurs.\n   */\n  set onError(callback: ((error: Error) => void) | null) {\n    this.errorCallback = callback;\n  }\n\n  /**\n   * Set a callback for when tokens are refreshed.\n   */\n  set onTokenRefreshed(\n    callback: ((accessToken: string, refreshToken: string | undefined) => void) | null\n  ) {\n    this.tokenRefreshedCallback = callback;\n  }\n\n  /**\n   * Get the last disconnect information (if any).\n   */\n  get lastDisconnect(): DisconnectInfo | undefined {\n    return this.lastDisconnectInfo;\n  }\n\n  /**\n   * Connects to a Bannou server using username/password authentication.\n   */\n  async connectAsync(serverUrl: string, email: string, password: string): Promise<boolean> {\n    this.serverBaseUrl = serverUrl.replace(/\\/$/, '');\n    this.serviceToken = undefined;\n\n    // Step 1: Authenticate via HTTP to get JWT\n    const loginResult = await this.loginAsync(email, password);\n    if (!loginResult) {\n      return false;\n    }\n\n    // Step 2: Establish WebSocket connection with JWT\n    return this.establishWebSocketAsync();\n  }\n\n  /**\n   * Connects using an existing JWT token.\n   */\n  async connectWithTokenAsync(\n    serverUrl: string,\n    accessToken: string,\n    refreshToken?: string\n  ): Promise<boolean> {\n    this.serverBaseUrl = serverUrl.replace(/\\/$/, '');\n    this._accessToken = accessToken;\n    this._refreshToken = refreshToken;\n    this.serviceToken = undefined;\n\n    return this.establishWebSocketAsync();\n  }\n\n  /**\n   * Connects in internal mode using a service token.\n   */\n  async connectInternalAsync(connectUrl: string, serviceToken?: string): Promise<boolean> {\n    this.serverBaseUrl = undefined;\n    this.connectUrl = connectUrl.replace(/\\/$/, '');\n    this._accessToken = undefined;\n    this._refreshToken = undefined;\n    this.serviceToken = serviceToken;\n\n    return this.establishWebSocketAsync(true);\n  }\n\n  /**\n   * Registers a new account and connects.\n   */\n  async registerAndConnectAsync(\n    serverUrl: string,\n    username: string,\n    email: string,\n    password: string\n  ): Promise<boolean> {\n    this.serverBaseUrl = serverUrl.replace(/\\/$/, '');\n    this.serviceToken = undefined;\n\n    // Step 1: Register account\n    const registerResult = await this.registerAsync(username, email, password);\n    if (!registerResult) {\n      return false;\n    }\n\n    // Step 2: Establish WebSocket connection with JWT\n    return this.establishWebSocketAsync();\n  }\n\n  /**\n   * Gets the service GUID for a specific API endpoint.\n   * @param endpoint API path (e.g., \"/account/get\")\n   */\n  getServiceGuid(endpoint: string): string | undefined {\n    return this.apiMappings.get(endpoint);\n  }\n\n  /**\n   * Invokes a service method by specifying the API endpoint path.\n   * @param endpoint API path (e.g., \"/account/get\")\n   */\n  async invokeAsync<TRequest, TResponse>(\n    endpoint: string,\n    request: TRequest,\n    channel: number = 0,\n    timeout: number = DEFAULT_TIMEOUT_MS\n  ): Promise<ApiResponse<TResponse>> {\n    if (!this.isConnected || !this.webSocket) {\n      throw new Error('WebSocket is not connected. Call connectAsync first.');\n    }\n\n    if (!this.connectionState) {\n      throw new Error('Connection state not initialized.');\n    }\n\n    // Get service GUID\n    const serviceGuid = this.getServiceGuid(endpoint);\n    if (!serviceGuid) {\n      const available = Array.from(this.apiMappings.keys()).slice(0, 10).join(', ');\n      throw new Error(`Unknown endpoint: ${endpoint}. Available: ${available}...`);\n    }\n\n    // Serialize request to JSON\n    const jsonPayload = BannouJson.serialize(request);\n    const payloadBytes = new TextEncoder().encode(jsonPayload);\n\n    // Create binary message\n    const messageId = generateMessageId();\n    const sequenceNumber = this.connectionState.getNextSequenceNumber(channel);\n\n    const message: BinaryMessage = {\n      flags: MessageFlags.None,\n      channel,\n      sequenceNumber,\n      serviceGuid,\n      messageId,\n      responseCode: 0,\n      payload: payloadBytes,\n    };\n\n    // Set up response awaiter\n    const responsePromise = this.createResponsePromise(messageId, timeout, endpoint);\n    this.connectionState.addPendingMessage(messageId, endpoint, new Date());\n\n    try {\n      // Send message\n      const messageBytes = toByteArray(message);\n      this.sendBinaryMessage(messageBytes);\n\n      // Wait for response\n      const response = await responsePromise;\n\n      // Check response code\n      if (response.responseCode !== 0) {\n        return ApiResponse.failure<TResponse>(\n          createErrorResponse(response.responseCode, messageId, endpoint)\n        );\n      }\n\n      // Success response - parse JSON payload\n      if (response.payload.length === 0) {\n        return ApiResponse.successEmpty<TResponse>();\n      }\n\n      const responseJson = getJsonPayload(response);\n      const result = BannouJson.deserialize<TResponse>(responseJson);\n      if (result === null) {\n        return ApiResponse.failure<TResponse>(\n          createErrorResponse(60, messageId, endpoint, 'Failed to deserialize response')\n        );\n      }\n\n      return ApiResponse.success(result);\n    } finally {\n      this.pendingRequests.delete(messageId.toString());\n      this.connectionState?.removePendingMessage(messageId);\n    }\n  }\n\n  /**\n   * Sends a fire-and-forget event (no response expected).\n   * @param endpoint API path (e.g., \"/events/publish\")\n   */\n  async sendEventAsync<TRequest>(\n    endpoint: string,\n    request: TRequest,\n    channel: number = 0\n  ): Promise<void> {\n    if (!this.isConnected || !this.webSocket) {\n      throw new Error('WebSocket is not connected. Call connectAsync first.');\n    }\n\n    if (!this.connectionState) {\n      throw new Error('Connection state not initialized.');\n    }\n\n    // Get service GUID\n    const serviceGuid = this.getServiceGuid(endpoint);\n    if (!serviceGuid) {\n      throw new Error(`Unknown endpoint: ${endpoint}`);\n    }\n\n    // Serialize request to JSON\n    const jsonPayload = BannouJson.serialize(request);\n    const payloadBytes = new TextEncoder().encode(jsonPayload);\n\n    // Create binary message with Event flag\n    const messageId = generateMessageId();\n    const sequenceNumber = this.connectionState.getNextSequenceNumber(channel);\n\n    const message: BinaryMessage = {\n      flags: MessageFlags.Event,\n      channel,\n      sequenceNumber,\n      serviceGuid,\n      messageId,\n      responseCode: 0,\n      payload: payloadBytes,\n    };\n\n    // Send message\n    const messageBytes = toByteArray(message);\n    this.sendBinaryMessage(messageBytes);\n  }\n\n  /**\n   * Subscribe to a typed event with automatic deserialization.\n   */\n  onEvent<TEvent extends BaseClientEvent>(\n    eventName: string,\n    handler: (event: TEvent) => void\n  ): IEventSubscription {\n    const subscriptionId = generateUuid();\n\n    const wrappedHandler = (json: string): void => {\n      try {\n        const event = BannouJson.deserialize<TEvent>(json);\n        if (event) {\n          handler(event);\n        }\n      } catch (error) {\n        this.eventHandlerFailedCallback?.(error as Error);\n      }\n    };\n\n    const handlers = this.eventHandlers.get(eventName) ?? [];\n    handlers.push({ subscriptionId, handler: wrappedHandler });\n    this.eventHandlers.set(eventName, handlers);\n\n    return new EventSubscription(eventName, subscriptionId, (id) => {\n      const existing = this.eventHandlers.get(eventName);\n      if (existing) {\n        const filtered = existing.filter((h) => h.subscriptionId !== id);\n        if (filtered.length > 0) {\n          this.eventHandlers.set(eventName, filtered);\n        } else {\n          this.eventHandlers.delete(eventName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Subscribe to raw event JSON.\n   */\n  onRawEvent(eventName: string, handler: (json: string) => void): IEventSubscription {\n    const subscriptionId = generateUuid();\n\n    const handlers = this.eventHandlers.get(eventName) ?? [];\n    handlers.push({ subscriptionId, handler });\n    this.eventHandlers.set(eventName, handlers);\n\n    return new EventSubscription(eventName, subscriptionId, (id) => {\n      const existing = this.eventHandlers.get(eventName);\n      if (existing) {\n        const filtered = existing.filter((h) => h.subscriptionId !== id);\n        if (filtered.length > 0) {\n          this.eventHandlers.set(eventName, filtered);\n        } else {\n          this.eventHandlers.delete(eventName);\n        }\n      }\n    });\n  }\n\n  /**\n   * Removes all event handlers for a specific event.\n   */\n  removeEventHandlers(eventName: string): void {\n    this.eventHandlers.delete(eventName);\n  }\n\n  /**\n   * Requests metadata about an endpoint instead of executing it.\n   * Uses the Meta flag (0x80) which triggers route transformation at Connect service.\n   * @param endpoint API path (e.g., \"/account/get\")\n   */\n  async getEndpointMetaAsync<T>(\n    endpoint: string,\n    metaType: MetaType = MetaType.FullSchema,\n    timeout: number = 10_000\n  ): Promise<MetaResponse<T>> {\n    if (!this.isConnected || !this.webSocket) {\n      throw new Error('WebSocket is not connected. Call connectAsync first.');\n    }\n\n    if (!this.connectionState) {\n      throw new Error('Connection state not initialized.');\n    }\n\n    // Get service GUID (same as regular requests)\n    const serviceGuid = this.getServiceGuid(endpoint);\n    if (!serviceGuid) {\n      const available = Array.from(this.apiMappings.keys()).slice(0, 10).join(', ');\n      throw new Error(`Unknown endpoint: ${endpoint}. Available: ${available}...`);\n    }\n\n    // Create meta message - meta type encoded in Channel field, payload is EMPTY\n    const messageId = generateMessageId();\n    const sequenceNumber = this.connectionState.getNextSequenceNumber(metaType);\n\n    const message: BinaryMessage = {\n      flags: MessageFlags.Meta, // Meta flag triggers route transformation\n      channel: metaType, // Meta type in Channel (0=info, 1=req, 2=resp, 3=full)\n      sequenceNumber,\n      serviceGuid,\n      messageId,\n      responseCode: 0,\n      payload: new Uint8Array(0), // EMPTY - Connect never reads payloads\n    };\n\n    // Set up response awaiter\n    const responsePromise = this.createResponsePromise(messageId, timeout, `META:${endpoint}`);\n    this.connectionState.addPendingMessage(messageId, `META:${endpoint}`, new Date());\n\n    try {\n      // Send message\n      const messageBytes = toByteArray(message);\n      this.sendBinaryMessage(messageBytes);\n\n      // Wait for response\n      const response = await responsePromise;\n\n      // Check response code\n      if (response.responseCode !== 0) {\n        throw new Error(`Meta request failed with response code ${response.responseCode}`);\n      }\n\n      // Parse meta response\n      const responseJson = getJsonPayload(response);\n      const result = BannouJson.deserialize<MetaResponse<T>>(responseJson);\n      if (result === null) {\n        throw new Error('Failed to deserialize meta response');\n      }\n\n      return result;\n    } finally {\n      this.pendingRequests.delete(messageId.toString());\n      this.connectionState?.removePendingMessage(messageId);\n    }\n  }\n\n  /**\n   * Gets human-readable endpoint information (summary, description, tags).\n   * @param endpoint API path (e.g., \"/account/get\")\n   */\n  async getEndpointInfoAsync(endpoint: string): Promise<MetaResponse<EndpointInfoData>> {\n    return this.getEndpointMetaAsync<EndpointInfoData>(endpoint, MetaType.EndpointInfo);\n  }\n\n  /**\n   * Gets JSON Schema for the request body of an endpoint.\n   * @param endpoint API path (e.g., \"/account/get\")\n   */\n  async getRequestSchemaAsync(endpoint: string): Promise<MetaResponse<JsonSchemaData>> {\n    return this.getEndpointMetaAsync<JsonSchemaData>(endpoint, MetaType.RequestSchema);\n  }\n\n  /**\n   * Gets JSON Schema for the response body of an endpoint.\n   * @param endpoint API path (e.g., \"/account/get\")\n   */\n  async getResponseSchemaAsync(endpoint: string): Promise<MetaResponse<JsonSchemaData>> {\n    return this.getEndpointMetaAsync<JsonSchemaData>(endpoint, MetaType.ResponseSchema);\n  }\n\n  /**\n   * Gets full schema including info, request schema, and response schema.\n   * @param endpoint API path (e.g., \"/account/get\")\n   */\n  async getFullSchemaAsync(endpoint: string): Promise<MetaResponse<FullSchemaData>> {\n    return this.getEndpointMetaAsync<FullSchemaData>(endpoint, MetaType.FullSchema);\n  }\n\n  /**\n   * Reconnects using a reconnection token from a DisconnectNotificationEvent.\n   */\n  async reconnectWithTokenAsync(reconnectionToken: string): Promise<boolean> {\n    if (!this.serverBaseUrl && !this.connectUrl) {\n      this._lastError = 'No server URL available for reconnection';\n      return false;\n    }\n\n    // Store the reconnection token for the WebSocket connection\n    this.pendingReconnectionToken = reconnectionToken;\n\n    try {\n      // Re-establish WebSocket connection with the reconnection token\n      return await this.establishWebSocketAsync();\n    } finally {\n      this.pendingReconnectionToken = undefined;\n    }\n  }\n\n  /**\n   * Refreshes the access token using the stored refresh token.\n   */\n  async refreshAccessTokenAsync(): Promise<boolean> {\n    if (!this._refreshToken) {\n      this._lastError = 'No refresh token available';\n      return false;\n    }\n\n    if (!this.serverBaseUrl) {\n      this._lastError = 'No server URL available for token refresh';\n      return false;\n    }\n\n    const refreshUrl = `${this.serverBaseUrl}/auth/refresh`;\n\n    try {\n      const response = await fetch(refreshUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ refreshToken: this._refreshToken }),\n      });\n\n      if (!response.ok) {\n        const errorContent = await response.text();\n        this._lastError = `Token refresh failed (${response.status}): ${errorContent}`;\n        return false;\n      }\n\n      const result: LoginResponse = await response.json();\n      if (!result.accessToken) {\n        this._lastError = 'Token refresh response missing access token';\n        return false;\n      }\n\n      this._accessToken = result.accessToken;\n      if (result.refreshToken) {\n        this._refreshToken = result.refreshToken;\n      }\n\n      // Notify callback if set\n      this.tokenRefreshedCallback?.(this._accessToken, this._refreshToken);\n\n      return true;\n    } catch (error) {\n      this._lastError = `Token refresh exception: ${(error as Error).message}`;\n      return false;\n    }\n  }\n\n  /**\n   * Disconnects from the server.\n   */\n  async disconnectAsync(): Promise<void> {\n    // Cancel all pending requests\n    for (const [, pending] of this.pendingRequests) {\n      clearTimeout(pending.timeoutId);\n      pending.reject(new Error('Disconnecting'));\n    }\n    this.pendingRequests.clear();\n\n    if (this.webSocket) {\n      try {\n        this.webSocket.close(1000, 'Client disconnecting');\n      } catch {\n        // Ignore close errors\n      }\n    }\n\n    this.webSocket = null;\n    this.connectionState = null;\n    this._accessToken = undefined;\n    this._refreshToken = undefined;\n    this.serviceToken = undefined;\n    this.apiMappings.clear();\n  }\n\n  // Private methods\n\n  private buildAuthorizationHeader(allowAnonymousInternal: boolean): string {\n    if (this._accessToken) {\n      return `Bearer ${this._accessToken}`;\n    }\n\n    if (this.serviceToken || allowAnonymousInternal) {\n      return INTERNAL_AUTHORIZATION_HEADER;\n    }\n\n    return '';\n  }\n\n  private async loginAsync(email: string, password: string): Promise<boolean> {\n    const loginUrl = `${this.serverBaseUrl}/auth/login`;\n\n    try {\n      const response = await fetch(loginUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email, password }),\n      });\n\n      if (!response.ok) {\n        const errorContent = await response.text();\n        this._lastError = `Login failed (${response.status}): ${errorContent}`;\n        return false;\n      }\n\n      const result: LoginResponse = await response.json();\n      if (!result.accessToken) {\n        this._lastError = 'Login response missing access token';\n        return false;\n      }\n\n      this._accessToken = result.accessToken;\n      this._refreshToken = result.refreshToken;\n      this.connectUrl = result.connectUrl;\n      return true;\n    } catch (error) {\n      this._lastError = `Login exception: ${(error as Error).message}`;\n      return false;\n    }\n  }\n\n  private async registerAsync(username: string, email: string, password: string): Promise<boolean> {\n    const registerUrl = `${this.serverBaseUrl}/auth/register`;\n\n    try {\n      const response = await fetch(registerUrl, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ username, email, password }),\n      });\n\n      if (!response.ok) {\n        const errorContent = await response.text();\n        this._lastError = `Registration failed (${response.status}): ${errorContent}`;\n        return false;\n      }\n\n      const result: LoginResponse = await response.json();\n      if (!result.accessToken) {\n        this._lastError = 'Registration response missing access token';\n        return false;\n      }\n\n      this._accessToken = result.accessToken;\n      this._refreshToken = result.refreshToken;\n      this.connectUrl = result.connectUrl;\n      return true;\n    } catch (error) {\n      this._lastError = `Registration exception: ${(error as Error).message}`;\n      return false;\n    }\n  }\n\n  private async establishWebSocketAsync(allowAnonymousInternal: boolean = false): Promise<boolean> {\n    if (!this._accessToken && !this.serviceToken && !allowAnonymousInternal) {\n      this._lastError = 'No access token available for WebSocket connection';\n      return false;\n    }\n\n    // Determine WebSocket URL\n    let wsUrl: string;\n    if (this.connectUrl) {\n      wsUrl = this.connectUrl.replace('https://', 'wss://').replace('http://', 'ws://');\n    } else if (this.serverBaseUrl) {\n      wsUrl = this.serverBaseUrl.replace('https://', 'wss://').replace('http://', 'ws://');\n      // Add /connect path if not already present\n      if (!wsUrl.endsWith('/connect')) {\n        wsUrl = `${wsUrl}/connect`;\n      }\n    } else {\n      this._lastError = 'No server URL available';\n      return false;\n    }\n\n    try {\n      this.webSocket = await this.createWebSocket(wsUrl, allowAnonymousInternal);\n    } catch (error) {\n      this._lastError = `WebSocket connection failed to ${wsUrl}: ${(error as Error).message}`;\n      return false;\n    }\n\n    // Initialize connection state\n    const sessionId = generateUuid();\n    this.connectionState = new ConnectionState(sessionId);\n\n    // Set up message handler\n    this.setupMessageHandler();\n\n    // Wait for capability manifest\n    const manifestReceived = await this.waitForCapabilityManifest();\n    if (!manifestReceived) {\n      // Connection still works, but warn\n      console.warn('Capability manifest not received within timeout');\n    }\n\n    return true;\n  }\n\n  private async createWebSocket(\n    url: string,\n    allowAnonymousInternal: boolean\n  ): Promise<WebSocketType> {\n    const authHeader = this.buildAuthorizationHeader(allowAnonymousInternal);\n\n    // Check if we're in a browser environment\n    if (typeof window !== 'undefined' && typeof window.WebSocket !== 'undefined') {\n      // Browser environment - WebSocket constructor doesn't support custom headers\n      // The server should accept auth via query param or cookie for browser clients\n      return new Promise<WebSocket>((resolve, reject) => {\n        // Add auth to URL for browser (if server supports it)\n        let authUrl = url;\n        if (authHeader && authHeader.startsWith('Bearer ')) {\n          const token = authHeader.replace('Bearer ', '');\n          const separator = url.includes('?') ? '&' : '?';\n          authUrl = `${url}${separator}token=${encodeURIComponent(token)}`;\n        }\n\n        const ws = new WebSocket(authUrl);\n        ws.binaryType = 'arraybuffer';\n\n        ws.onopen = () => resolve(ws);\n        ws.onerror = () => reject(new Error('WebSocket connection failed'));\n      });\n    } else {\n      // Node.js environment - use 'ws' package with headers\n      const WebSocketModule = await import('ws');\n      const WS = WebSocketModule.default || WebSocketModule.WebSocket || WebSocketModule;\n\n      return new Promise<import('ws').WebSocket>((resolve, reject) => {\n        const headers: Record<string, string> = {};\n        if (authHeader) {\n          headers['Authorization'] = authHeader;\n        }\n        if (this.serviceToken) {\n          headers['X-Service-Token'] = this.serviceToken;\n        }\n\n        const ws = new WS(url, { headers }) as import('ws').WebSocket;\n        console.error(`[DEBUG] createWebSocket: created WebSocket to ${url}`);\n\n        // CRITICAL: Set up message buffering BEFORE 'open' fires to avoid race condition.\n        // The server may send capability manifest immediately after accepting connection,\n        // so we must buffer messages until setupMessageHandler() takes over.\n        // The early handler stays active until setupMessageHandler removes it.\n        const earlyMessages: Buffer[] = [];\n        const earlyMessageHandler = (data: Buffer): void => {\n          earlyMessages.push(data);\n        };\n        ws.on('message', earlyMessageHandler);\n\n        // Store references so setupMessageHandler can access them\n        const wsWithEarly = ws as import('ws').WebSocket & {\n          _earlyMessages?: Buffer[];\n          _earlyMessageHandler?: (data: Buffer) => void;\n        };\n        wsWithEarly._earlyMessages = earlyMessages;\n        wsWithEarly._earlyMessageHandler = earlyMessageHandler;\n\n        ws.on('open', () => {\n          // Don't remove early handler here - setupMessageHandler will handle the transition\n          // This prevents a gap where messages could be lost\n          resolve(ws);\n        });\n        ws.on('error', (err: Error) => {\n          reject(err);\n        });\n      });\n    }\n  }\n\n  private setupMessageHandler(): void {\n    if (!this.webSocket) return;\n\n    const handleMessage = (data: ArrayBuffer | Buffer): void => {\n      try {\n        // Handle both ArrayBuffer and Node.js Buffer correctly\n        // Node.js Buffers can be views into larger pooled ArrayBuffers,\n        // so we must account for byteOffset when converting\n        let bytes: Uint8Array;\n        if (data instanceof ArrayBuffer) {\n          bytes = new Uint8Array(data);\n        } else {\n          // Node.js Buffer: create Uint8Array with correct offset and length\n          bytes = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n        }\n\n        // Check minimum size\n        if (bytes.length < RESPONSE_HEADER_SIZE) {\n          return;\n        }\n\n        const message = parse(bytes);\n        this.handleReceivedMessage(message);\n      } catch {\n        // Silently ignore malformed messages\n      }\n    };\n\n    const handleClose = (code: number, reason?: string): void => {\n      // Map close code to disconnect reason\n      let disconnectReason = DisconnectReason.ServerClose;\n      let canReconnect = false;\n\n      // WebSocket close codes: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent/code\n      if (code === 1000) {\n        disconnectReason = DisconnectReason.ClientDisconnect;\n      } else if (code === 1001) {\n        disconnectReason = DisconnectReason.ServerShutdown;\n        canReconnect = true;\n      } else if (code >= 4000 && code < 5000) {\n        // Application-specific codes\n        if (code === 4001) {\n          disconnectReason = DisconnectReason.SessionExpired;\n        } else if (code === 4002) {\n          disconnectReason = DisconnectReason.Kicked;\n        } else {\n          disconnectReason = DisconnectReason.ServerClose;\n          canReconnect = true;\n        }\n      } else if (code >= 1002 && code <= 1015) {\n        disconnectReason = DisconnectReason.NetworkError;\n        canReconnect = true;\n      }\n\n      // Use pending reconnection token if available (from DisconnectNotificationEvent)\n      const reconnectionToken = this.pendingReconnectionToken;\n      if (reconnectionToken) {\n        canReconnect = true;\n      }\n\n      const info: DisconnectInfo = {\n        reason: disconnectReason,\n        message: reason || undefined,\n        reconnectionToken,\n        canReconnect,\n        closeCode: code,\n      };\n\n      this.lastDisconnectInfo = info;\n      this.disconnectCallback?.(info);\n    };\n\n    const handleError = (error: Error | Event): void => {\n      const err = error instanceof Error ? error : new Error('WebSocket error');\n      this.errorCallback?.(err);\n    };\n\n    // Check for browser environment the same way we do in createWebSocket\n    const isBrowser = typeof window !== 'undefined' && typeof window.WebSocket !== 'undefined';\n\n    if (isBrowser) {\n      // Browser WebSocket\n      const browserWs = this.webSocket as WebSocket;\n      browserWs.addEventListener('message', (event: MessageEvent) => {\n        if (event.data instanceof ArrayBuffer) {\n          handleMessage(event.data);\n        }\n      });\n      browserWs.addEventListener('close', (event: CloseEvent) => {\n        handleClose(event.code, event.reason);\n      });\n      browserWs.addEventListener('error', (event: Event) => {\n        handleError(event);\n      });\n    } else {\n      // Node.js 'ws' WebSocket\n      const nodeWs = this.webSocket as import('ws').WebSocket;\n      console.error(`[DEBUG] setupMessageHandler: Node.js WebSocket detected`);\n\n      // Remove the early message handler now that we're setting up the real handler.\n      // The early handler was set up in createWebSocket to buffer messages that arrive\n      // between 'open' firing and setupMessageHandler being called.\n      const wsWithEarly = nodeWs as import('ws').WebSocket & {\n        _earlyMessages?: Buffer[];\n        _earlyMessageHandler?: (data: Buffer) => void;\n      };\n      const earlyHandler = wsWithEarly._earlyMessageHandler;\n      console.error(`[DEBUG] setupMessageHandler: earlyHandler exists=${!!earlyHandler}`);\n      if (earlyHandler) {\n        nodeWs.off('message', earlyHandler);\n        wsWithEarly._earlyMessageHandler = undefined;\n      }\n\n      // Process any messages that arrived before setupMessageHandler was called\n      // (fixes race condition where server sends capability manifest immediately)\n      const earlyMessages = wsWithEarly._earlyMessages;\n      console.error(\n        `[DEBUG] setupMessageHandler: earlyMessages count=${earlyMessages?.length ?? 0}`\n      );\n      if (earlyMessages && earlyMessages.length > 0) {\n        console.error(\n          `[DEBUG] setupMessageHandler: processing ${earlyMessages.length} early messages`\n        );\n        for (const data of earlyMessages) {\n          console.error(\n            `[DEBUG] setupMessageHandler: processing early message, length=${data.length}`\n          );\n          handleMessage(data);\n        }\n      }\n      // Clear the early messages reference\n      wsWithEarly._earlyMessages = undefined;\n\n      nodeWs.on('message', (data: Buffer) => {\n        console.error(`[DEBUG] setupMessageHandler: received live message, length=${data.length}`);\n        handleMessage(data);\n      });\n      nodeWs.on('close', (code: number, reason: Buffer) => {\n        handleClose(code, reason.toString());\n      });\n      nodeWs.on('error', (error: Error) => {\n        handleError(error);\n      });\n    }\n  }\n\n  private handleReceivedMessage(message: BinaryMessage): void {\n    if (isResponse(message)) {\n      // Complete pending request\n      const pending = this.pendingRequests.get(message.messageId.toString());\n      if (pending) {\n        clearTimeout(pending.timeoutId);\n        pending.resolve(message);\n      }\n    } else if ((message.flags & MessageFlags.Event) !== 0) {\n      // Server-pushed event\n      this.handleEventMessage(message);\n    }\n  }\n\n  private handleEventMessage(message: BinaryMessage): void {\n    if (message.payload.length === 0) {\n      return;\n    }\n\n    try {\n      const payloadJson = new TextDecoder().decode(message.payload);\n      const parsed = JSON.parse(payloadJson) as { eventName?: string };\n\n      const eventName = parsed.eventName;\n      if (!eventName) {\n        return;\n      }\n\n      // Handle capability manifest specially\n      if (eventName === 'connect.capability_manifest') {\n        this.handleCapabilityManifest(payloadJson);\n      }\n\n      // Handle disconnect notification specially\n      if (eventName === 'connect.disconnect_notification') {\n        this.handleDisconnectNotification(payloadJson);\n      }\n\n      // Dispatch to registered handlers\n      const handlers = this.eventHandlers.get(eventName);\n      if (handlers) {\n        for (const { handler } of handlers) {\n          try {\n            handler(payloadJson);\n          } catch (error) {\n            this.eventHandlerFailedCallback?.(error as Error);\n          }\n        }\n      }\n    } catch {\n      // Silently ignore parse errors\n    }\n  }\n\n  private handleCapabilityManifest(json: string): void {\n    try {\n      const manifest = JSON.parse(json) as {\n        sessionId?: string;\n        availableApis?: Array<{\n          serviceId?: string;\n          endpoint?: string;\n          service?: string;\n          description?: string;\n        }>;\n      };\n\n      // Extract session ID\n      if (manifest.sessionId) {\n        this._sessionId = manifest.sessionId;\n      }\n\n      // Extract available APIs - new schema format: { serviceId, endpoint, service, description }\n      if (Array.isArray(manifest.availableApis)) {\n        for (const api of manifest.availableApis) {\n          // endpoint is now the lookup key (e.g., \"/account/get\")\n          if (api.endpoint && api.serviceId) {\n            this.apiMappings.set(api.endpoint, api.serviceId);\n            this.connectionState?.addServiceMapping(api.endpoint, api.serviceId);\n          }\n        }\n      }\n\n      // Signal that capabilities are received\n      if (this.capabilityManifestResolver) {\n        this.capabilityManifestResolver(true);\n        this.capabilityManifestResolver = null;\n      }\n    } catch {\n      // Silently ignore manifest parse errors\n    }\n  }\n\n  private handleDisconnectNotification(json: string): void {\n    try {\n      const notification = JSON.parse(json) as {\n        reason?: string;\n        message?: string;\n        reconnectionToken?: string;\n        shutdownTime?: string;\n      };\n\n      // Store reconnection token for when WebSocket actually closes\n      if (notification.reconnectionToken) {\n        this.pendingReconnectionToken = notification.reconnectionToken;\n      }\n\n      // Pre-populate disconnect info with data from notification\n      // This will be merged with close event data when connection actually closes\n      let reason = DisconnectReason.ServerClose;\n      if (notification.reason === 'session_expired') {\n        reason = DisconnectReason.SessionExpired;\n      } else if (notification.reason === 'kicked') {\n        reason = DisconnectReason.Kicked;\n      } else if (notification.reason === 'server_shutdown') {\n        reason = DisconnectReason.ServerShutdown;\n      }\n\n      this.lastDisconnectInfo = {\n        reason,\n        message: notification.message,\n        reconnectionToken: notification.reconnectionToken,\n        canReconnect: !!notification.reconnectionToken,\n      };\n    } catch {\n      // Ignore parse errors\n    }\n  }\n\n  private waitForCapabilityManifest(): Promise<boolean> {\n    return new Promise<boolean>((resolve) => {\n      this.capabilityManifestResolver = resolve;\n\n      // Set up timeout\n      setTimeout(() => {\n        if (this.capabilityManifestResolver) {\n          this.capabilityManifestResolver(false);\n          this.capabilityManifestResolver = null;\n        }\n      }, CAPABILITY_MANIFEST_TIMEOUT_MS);\n    });\n  }\n\n  private createResponsePromise(\n    messageId: bigint,\n    timeout: number,\n    endpoint: string\n  ): Promise<BinaryMessage> {\n    return new Promise<BinaryMessage>((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        this.pendingRequests.delete(messageId.toString());\n        reject(new Error(`Request to ${endpoint} timed out after ${timeout}ms`));\n      }, timeout);\n\n      this.pendingRequests.set(messageId.toString(), {\n        resolve,\n        reject,\n        timeoutId,\n      });\n    });\n  }\n\n  private sendBinaryMessage(data: Uint8Array): void {\n    if (!this.webSocket) {\n      throw new Error('WebSocket not connected');\n    }\n\n    if ('send' in this.webSocket) {\n      if (typeof window !== 'undefined') {\n        // Browser\n        (this.webSocket as WebSocket).send(data);\n      } else {\n        // Node.js\n        (this.webSocket as import('ws').WebSocket).send(data);\n      }\n    }\n  }\n}\n"]}