// <auto-generated>
// BannouProtocol.h - Binary protocol constants and utilities for Bannou WebSocket API
// Generated by generate-unreal-protocol.py on 2026-01-21 22:17:12 UTC
// Do not edit this file manually.
// </auto-generated>

#pragma once

#include "CoreMinimal.h"
#include "Misc/Guid.h"

/**
 * Bannou WebSocket Binary Protocol
 *
 * This header provides constants, enums, and utilities for implementing
 * the Bannou binary WebSocket protocol in Unreal Engine.
 *
 * Request messages use a 31-byte header, response messages use a 16-byte header.
 * All multi-byte integers use big-endian (network) byte order.
 * GUIDs follow RFC 4122 network byte ordering.
 */
namespace Bannou
{
    // ============================================================================
    // PROTOCOL CONSTANTS
    // ============================================================================

    /**
     * Size of the binary header in bytes for request messages.
     *
     * Request header layout (31 bytes):
     * - [0]     Flags (1 byte)
     * - [1-2]   Channel (uint16 BE)
     * - [3-6]   Sequence (uint32 BE)
     * - [7-22]  ServiceGUID (16 bytes, RFC 4122)
     * - [23-30] MessageID (uint64 BE)
     * - [31+]   Payload (JSON UTF-8)
     */
    constexpr int32 REQUEST_HEADER_SIZE = 31;

    /**
     * Size of the binary header in bytes for response messages.
     *
     * Response header layout (16 bytes):
     * - [0]     Flags (1 byte, Response flag set)
     * - [1-2]   Channel (uint16 BE)
     * - [3-6]   Sequence (uint32 BE)
     * - [7-14]  MessageID (uint64 BE)
     * - [15]    ResponseCode (1 byte)
     * - [16+]   Payload (empty for errors)
     */
    constexpr int32 RESPONSE_HEADER_SIZE = 16;

    /**
     * Empty GUID constant (all zeros).
     */
    static const FGuid EMPTY_GUID = FGuid(0, 0, 0, 0);

    // ============================================================================
    // MESSAGE FLAGS
    // ============================================================================

    /**
     * Bit flags controlling message behavior in the binary protocol.
     * Flags can be combined using bitwise OR operations.
     */
    UENUM(BlueprintType)
    enum class EMessageFlags : uint8
    {
        /** Default - JSON text, service request, unencrypted, standard priority, expects response */
        None = 0x00,

        /** Message payload is binary data (not JSON) */
        Binary = 0x01,

        /** Message payload is encrypted */
        Encrypted = 0x02,

        /** Message payload is compressed (gzip) */
        Compressed = 0x04,

        /** Deliver at high priority, skip to front of queues */
        HighPriority = 0x08,

        /** Fire-and-forget message, no response expected */
        Event = 0x10,

        /** Route to another WebSocket client (not a Bannou service) */
        Client = 0x20,

        /** Message is a response to an RPC (not a new request) */
        Response = 0x40,

        /** Request metadata about endpoint instead of executing it */
        Meta = 0x80
    };
    ENUM_CLASS_FLAGS(EMessageFlags);

    /**
     * Check if a flags byte has a specific flag set.
     */
    FORCEINLINE bool HasFlag(uint8 Flags, EMessageFlags Flag)
    {
        return (Flags & static_cast<uint8>(Flag)) == static_cast<uint8>(Flag);
    }

    /**
     * Check if this is a response message.
     */
    FORCEINLINE bool IsResponse(uint8 Flags)
    {
        return HasFlag(Flags, EMessageFlags::Response);
    }

    /**
     * Check if this is an event message (fire-and-forget).
     */
    FORCEINLINE bool IsEvent(uint8 Flags)
    {
        return HasFlag(Flags, EMessageFlags::Event);
    }

    /**
     * Check if this is a meta request.
     */
    FORCEINLINE bool IsMeta(uint8 Flags)
    {
        return HasFlag(Flags, EMessageFlags::Meta);
    }

    /**
     * Check if payload is binary (not JSON).
     */
    FORCEINLINE bool IsBinary(uint8 Flags)
    {
        return HasFlag(Flags, EMessageFlags::Binary);
    }

    // ============================================================================
    // RESPONSE CODES
    // ============================================================================

    /**
     * Response codes used in the binary protocol for success/error indication.
     *
     * Code ranges:
     * - 0-49: Protocol-level errors (Connect service)
     * - 50-69: Service-level errors (downstream service responses)
     * - 70+: Shortcut-specific errors
     */
    UENUM(BlueprintType)
    enum class EResponseCode : uint8
    {
        /** Request completed successfully */
        OK = 0,

        /** Generic request error (malformed message, invalid format) */
        RequestError = 10,

        /** Request payload exceeds maximum allowed size */
        RequestTooLarge = 11,

        /** Rate limit exceeded for this client/session */
        TooManyRequests = 12,

        /** Invalid channel number in request header */
        InvalidRequestChannel = 13,

        /** Authentication required but not provided or invalid */
        Unauthorized = 20,

        /** Target service GUID not found in capability manifest */
        ServiceNotFound = 30,

        /** Target client GUID not found (for client-to-client messages) */
        ClientNotFound = 31,

        /** Referenced message ID not found */
        MessageNotFound = 32,

        /** Broadcast not allowed in this connection mode */
        BroadcastNotAllowed = 40,

        /** Service returned 400 Bad Request */
        Service_BadRequest = 50,

        /** Service returned 404 Not Found */
        Service_NotFound = 51,

        /** Service returned 401/403 Unauthorized/Forbidden */
        Service_Unauthorized = 52,

        /** Service returned 409 Conflict */
        Service_Conflict = 53,

        /** Service returned 500 Internal Server Error */
        Service_InternalServerError = 60,

        /** Shortcut has expired and is no longer valid */
        ShortcutExpired = 70,

        /** Shortcut target endpoint no longer exists */
        ShortcutTargetNotFound = 71,

        /** Shortcut was explicitly revoked */
        ShortcutRevoked = 72
    };

    /**
     * Check if a response code indicates success.
     */
    FORCEINLINE bool IsSuccess(EResponseCode Code)
    {
        return Code == EResponseCode::OK;
    }

    /**
     * Check if a response code indicates an error.
     */
    FORCEINLINE bool IsError(EResponseCode Code)
    {
        return Code != EResponseCode::OK;
    }

    /**
     * Get a human-readable name for a response code.
     */
    FORCEINLINE FString GetResponseCodeName(EResponseCode Code)
    {
        switch (Code)
        {
            case EResponseCode::OK: return TEXT("OK");
            case EResponseCode::RequestError: return TEXT("RequestError");
            case EResponseCode::RequestTooLarge: return TEXT("RequestTooLarge");
            case EResponseCode::TooManyRequests: return TEXT("TooManyRequests");
            case EResponseCode::InvalidRequestChannel: return TEXT("InvalidRequestChannel");
            case EResponseCode::Unauthorized: return TEXT("Unauthorized");
            case EResponseCode::ServiceNotFound: return TEXT("ServiceNotFound");
            case EResponseCode::ClientNotFound: return TEXT("ClientNotFound");
            case EResponseCode::MessageNotFound: return TEXT("MessageNotFound");
            case EResponseCode::BroadcastNotAllowed: return TEXT("BroadcastNotAllowed");
            case EResponseCode::Service_BadRequest: return TEXT("Service_BadRequest");
            case EResponseCode::Service_NotFound: return TEXT("Service_NotFound");
            case EResponseCode::Service_Unauthorized: return TEXT("Service_Unauthorized");
            case EResponseCode::Service_Conflict: return TEXT("Service_Conflict");
            case EResponseCode::Service_InternalServerError: return TEXT("Service_InternalServerError");
            case EResponseCode::ShortcutExpired: return TEXT("ShortcutExpired");
            case EResponseCode::ShortcutTargetNotFound: return TEXT("ShortcutTargetNotFound");
            case EResponseCode::ShortcutRevoked: return TEXT("ShortcutRevoked");
            default: return TEXT("UnknownError");
        }
    }

    /**
     * Map protocol response code to HTTP status code.
     */
    FORCEINLINE int32 MapToHttpStatus(EResponseCode Code)
    {
        switch (Code)
        {
            case EResponseCode::OK: return 200;
            case EResponseCode::RequestError:
            case EResponseCode::RequestTooLarge:
            case EResponseCode::InvalidRequestChannel:
            case EResponseCode::Service_BadRequest: return 400;
            case EResponseCode::Unauthorized:
            case EResponseCode::Service_Unauthorized: return 401;
            case EResponseCode::TooManyRequests: return 429;
            case EResponseCode::ServiceNotFound:
            case EResponseCode::ClientNotFound:
            case EResponseCode::MessageNotFound:
            case EResponseCode::Service_NotFound:
            case EResponseCode::ShortcutTargetNotFound: return 404;
            case EResponseCode::Service_Conflict: return 409;
            case EResponseCode::BroadcastNotAllowed: return 403;
            case EResponseCode::ShortcutExpired:
            case EResponseCode::ShortcutRevoked: return 410;
            case EResponseCode::Service_InternalServerError:
            default: return 500;
        }
    }

    // ============================================================================
    // NETWORK BYTE ORDER UTILITIES
    // ============================================================================

    /**
     * Network byte order (big-endian) utilities for cross-platform compatibility.
     * All multi-byte integers in the Bannou protocol use big-endian byte order.
     */
    namespace NetworkByteOrder
    {
        /**
         * Write a 16-bit unsigned integer in network byte order (big-endian).
         */
        FORCEINLINE void WriteUInt16(uint8* Buffer, int32 Offset, uint16 Value)
        {
            Buffer[Offset] = static_cast<uint8>((Value >> 8) & 0xFF);
            Buffer[Offset + 1] = static_cast<uint8>(Value & 0xFF);
        }

        /**
         * Write a 32-bit unsigned integer in network byte order (big-endian).
         */
        FORCEINLINE void WriteUInt32(uint8* Buffer, int32 Offset, uint32 Value)
        {
            Buffer[Offset] = static_cast<uint8>((Value >> 24) & 0xFF);
            Buffer[Offset + 1] = static_cast<uint8>((Value >> 16) & 0xFF);
            Buffer[Offset + 2] = static_cast<uint8>((Value >> 8) & 0xFF);
            Buffer[Offset + 3] = static_cast<uint8>(Value & 0xFF);
        }

        /**
         * Write a 64-bit unsigned integer in network byte order (big-endian).
         */
        FORCEINLINE void WriteUInt64(uint8* Buffer, int32 Offset, uint64 Value)
        {
            Buffer[Offset] = static_cast<uint8>((Value >> 56) & 0xFF);
            Buffer[Offset + 1] = static_cast<uint8>((Value >> 48) & 0xFF);
            Buffer[Offset + 2] = static_cast<uint8>((Value >> 40) & 0xFF);
            Buffer[Offset + 3] = static_cast<uint8>((Value >> 32) & 0xFF);
            Buffer[Offset + 4] = static_cast<uint8>((Value >> 24) & 0xFF);
            Buffer[Offset + 5] = static_cast<uint8>((Value >> 16) & 0xFF);
            Buffer[Offset + 6] = static_cast<uint8>((Value >> 8) & 0xFF);
            Buffer[Offset + 7] = static_cast<uint8>(Value & 0xFF);
        }

        /**
         * Read a 16-bit unsigned integer from network byte order (big-endian).
         */
        FORCEINLINE uint16 ReadUInt16(const uint8* Buffer, int32 Offset)
        {
            return (static_cast<uint16>(Buffer[Offset]) << 8) |
                   static_cast<uint16>(Buffer[Offset + 1]);
        }

        /**
         * Read a 32-bit unsigned integer from network byte order (big-endian).
         */
        FORCEINLINE uint32 ReadUInt32(const uint8* Buffer, int32 Offset)
        {
            return (static_cast<uint32>(Buffer[Offset]) << 24) |
                   (static_cast<uint32>(Buffer[Offset + 1]) << 16) |
                   (static_cast<uint32>(Buffer[Offset + 2]) << 8) |
                   static_cast<uint32>(Buffer[Offset + 3]);
        }

        /**
         * Read a 64-bit unsigned integer from network byte order (big-endian).
         */
        FORCEINLINE uint64 ReadUInt64(const uint8* Buffer, int32 Offset)
        {
            return (static_cast<uint64>(Buffer[Offset]) << 56) |
                   (static_cast<uint64>(Buffer[Offset + 1]) << 48) |
                   (static_cast<uint64>(Buffer[Offset + 2]) << 40) |
                   (static_cast<uint64>(Buffer[Offset + 3]) << 32) |
                   (static_cast<uint64>(Buffer[Offset + 4]) << 24) |
                   (static_cast<uint64>(Buffer[Offset + 5]) << 16) |
                   (static_cast<uint64>(Buffer[Offset + 6]) << 8) |
                   static_cast<uint64>(Buffer[Offset + 7]);
        }

        /**
         * Write a GUID in RFC 4122 network byte order.
         *
         * RFC 4122 specifies that the time fields (first 8 bytes) use network byte order.
         * Unreal's FGuid stores components in host byte order, so we need to swap
         * bytes for the time fields when writing to the wire.
         *
         * @param Buffer Destination buffer (must have at least Offset + 16 bytes)
         * @param Offset Byte offset to start writing
         * @param Guid The GUID to write
         */
        FORCEINLINE void WriteGuid(uint8* Buffer, int32 Offset, const FGuid& Guid)
        {
            // FGuid components: A (time_low), B (time_mid | time_hi_and_version),
            // C (clock_seq_hi_and_reserved | clock_seq_low), D (node)

            // Time-low (4 bytes) - write in network byte order (reversed from Guid.A)
            Buffer[Offset + 0] = static_cast<uint8>((Guid.A >> 24) & 0xFF);
            Buffer[Offset + 1] = static_cast<uint8>((Guid.A >> 16) & 0xFF);
            Buffer[Offset + 2] = static_cast<uint8>((Guid.A >> 8) & 0xFF);
            Buffer[Offset + 3] = static_cast<uint8>(Guid.A & 0xFF);

            // Time-mid and time-hi-version (4 bytes) - from Guid.B
            Buffer[Offset + 4] = static_cast<uint8>((Guid.B >> 24) & 0xFF);
            Buffer[Offset + 5] = static_cast<uint8>((Guid.B >> 16) & 0xFF);
            Buffer[Offset + 6] = static_cast<uint8>((Guid.B >> 8) & 0xFF);
            Buffer[Offset + 7] = static_cast<uint8>(Guid.B & 0xFF);

            // Clock-seq and first 2 bytes of node - from Guid.C
            Buffer[Offset + 8] = static_cast<uint8>((Guid.C >> 24) & 0xFF);
            Buffer[Offset + 9] = static_cast<uint8>((Guid.C >> 16) & 0xFF);
            Buffer[Offset + 10] = static_cast<uint8>((Guid.C >> 8) & 0xFF);
            Buffer[Offset + 11] = static_cast<uint8>(Guid.C & 0xFF);

            // Last 4 bytes of node - from Guid.D
            Buffer[Offset + 12] = static_cast<uint8>((Guid.D >> 24) & 0xFF);
            Buffer[Offset + 13] = static_cast<uint8>((Guid.D >> 16) & 0xFF);
            Buffer[Offset + 14] = static_cast<uint8>((Guid.D >> 8) & 0xFF);
            Buffer[Offset + 15] = static_cast<uint8>(Guid.D & 0xFF);
        }

        /**
         * Read a GUID from RFC 4122 network byte order.
         *
         * @param Buffer Source buffer
         * @param Offset Byte offset to start reading
         * @return Parsed GUID
         */
        FORCEINLINE FGuid ReadGuid(const uint8* Buffer, int32 Offset)
        {
            FGuid Result;

            // Read time-low (4 bytes, big-endian)
            Result.A = (static_cast<uint32>(Buffer[Offset + 0]) << 24) |
                       (static_cast<uint32>(Buffer[Offset + 1]) << 16) |
                       (static_cast<uint32>(Buffer[Offset + 2]) << 8) |
                       static_cast<uint32>(Buffer[Offset + 3]);

            // Read time-mid and time-hi-version (4 bytes)
            Result.B = (static_cast<uint32>(Buffer[Offset + 4]) << 24) |
                       (static_cast<uint32>(Buffer[Offset + 5]) << 16) |
                       (static_cast<uint32>(Buffer[Offset + 6]) << 8) |
                       static_cast<uint32>(Buffer[Offset + 7]);

            // Read clock-seq and first 2 bytes of node (4 bytes)
            Result.C = (static_cast<uint32>(Buffer[Offset + 8]) << 24) |
                       (static_cast<uint32>(Buffer[Offset + 9]) << 16) |
                       (static_cast<uint32>(Buffer[Offset + 10]) << 8) |
                       static_cast<uint32>(Buffer[Offset + 11]);

            // Read last 4 bytes of node
            Result.D = (static_cast<uint32>(Buffer[Offset + 12]) << 24) |
                       (static_cast<uint32>(Buffer[Offset + 13]) << 16) |
                       (static_cast<uint32>(Buffer[Offset + 14]) << 8) |
                       static_cast<uint32>(Buffer[Offset + 15]);

            return Result;
        }
    } // namespace NetworkByteOrder

    // ============================================================================
    // BINARY MESSAGE STRUCTURE
    // ============================================================================

    /**
     * Represents a parsed or constructed binary message.
     */
    USTRUCT(BlueprintType)
    struct FBannouMessage
    {
        GENERATED_BODY()

        /** Message behavior flags */
        UPROPERTY(BlueprintReadWrite, Category = "Bannou")
        uint8 Flags = 0;

        /** Channel for sequential message processing (0-65535, 0 = default) */
        UPROPERTY(BlueprintReadWrite, Category = "Bannou")
        int32 Channel = 0;

        /** Per-channel sequence number for message ordering */
        UPROPERTY(BlueprintReadWrite, Category = "Bannou")
        int32 SequenceNumber = 0;

        /** Client-salted service GUID for routing (only used in request messages) */
        UPROPERTY(BlueprintReadWrite, Category = "Bannou")
        FGuid ServiceGuid;

        /** Unique message ID for request/response correlation */
        UPROPERTY(BlueprintReadWrite, Category = "Bannou")
        int64 MessageId = 0;

        /** Response code for response messages (0 = OK, non-zero = error) */
        UPROPERTY(BlueprintReadWrite, Category = "Bannou")
        uint8 ResponseCode = 0;

        /** Message payload (JSON string) */
        UPROPERTY(BlueprintReadWrite, Category = "Bannou")
        FString Payload;

        /** Raw binary payload (when Binary flag is set) */
        TArray<uint8> BinaryPayload;

        /** Default constructor */
        FBannouMessage() = default;

        /** Check if this message expects a response */
        bool ExpectsResponse() const
        {
            return !HasFlag(Flags, EMessageFlags::Event) && !IsResponse(Flags);
        }

        /** Check if this message is a response to another message */
        bool IsResponseMessage() const
        {
            return Bannou::IsResponse(Flags);
        }

        /** Check if this message should be routed to a client */
        bool IsClientRouted() const
        {
            return HasFlag(Flags, EMessageFlags::Client);
        }

        /** Check if this message has high priority */
        bool IsHighPriorityMessage() const
        {
            return HasFlag(Flags, EMessageFlags::HighPriority);
        }

        /** Check if this is a successful response */
        bool IsSuccessResponse() const
        {
            return IsResponseMessage() && ResponseCode == 0;
        }

        /** Check if this is an error response */
        bool IsErrorResponse() const
        {
            return IsResponseMessage() && ResponseCode != 0;
        }
    };

    // ============================================================================
    // MESSAGE SERIALIZATION
    // ============================================================================

    /**
     * Serialize a request message to a byte array.
     *
     * @param Message The message to serialize
     * @param OutBuffer The output buffer (will be resized)
     */
    FORCEINLINE void SerializeRequest(const FBannouMessage& Message, TArray<uint8>& OutBuffer)
    {
        const TArray<uint8>& PayloadBytes = Message.BinaryPayload.Num() > 0
            ? Message.BinaryPayload
            : TArray<uint8>(reinterpret_cast<const uint8*>(TCHAR_TO_UTF8(*Message.Payload)),
                            Message.Payload.Len());

        OutBuffer.SetNum(REQUEST_HEADER_SIZE + PayloadBytes.Num());
        uint8* Data = OutBuffer.GetData();

        // Write header
        Data[0] = Message.Flags;
        NetworkByteOrder::WriteUInt16(Data, 1, static_cast<uint16>(Message.Channel));
        NetworkByteOrder::WriteUInt32(Data, 3, static_cast<uint32>(Message.SequenceNumber));
        NetworkByteOrder::WriteGuid(Data, 7, Message.ServiceGuid);
        NetworkByteOrder::WriteUInt64(Data, 23, static_cast<uint64>(Message.MessageId));

        // Write payload
        if (PayloadBytes.Num() > 0)
        {
            FMemory::Memcpy(Data + REQUEST_HEADER_SIZE, PayloadBytes.GetData(), PayloadBytes.Num());
        }
    }

    /**
     * Parse a binary message from a byte array.
     * Automatically detects request (31-byte header) vs response (16-byte header).
     *
     * @param Buffer The source buffer
     * @param OutMessage The parsed message
     * @return True if parsing succeeded, false otherwise
     */
    FORCEINLINE bool ParseMessage(const TArray<uint8>& Buffer, FBannouMessage& OutMessage)
    {
        if (Buffer.Num() < 1)
        {
            return false;
        }

        const uint8* Data = Buffer.GetData();
        OutMessage.Flags = Data[0];

        if (Bannou::IsResponse(OutMessage.Flags))
        {
            // Parse response (16-byte header)
            if (Buffer.Num() < RESPONSE_HEADER_SIZE)
            {
                return false;
            }

            OutMessage.Channel = NetworkByteOrder::ReadUInt16(Data, 1);
            OutMessage.SequenceNumber = NetworkByteOrder::ReadUInt32(Data, 3);
            OutMessage.MessageId = static_cast<int64>(NetworkByteOrder::ReadUInt64(Data, 7));
            OutMessage.ResponseCode = Data[15];
            OutMessage.ServiceGuid = EMPTY_GUID;

            // Extract payload
            if (Buffer.Num() > RESPONSE_HEADER_SIZE)
            {
                if (HasFlag(OutMessage.Flags, EMessageFlags::Binary))
                {
                    OutMessage.BinaryPayload.SetNum(Buffer.Num() - RESPONSE_HEADER_SIZE);
                    FMemory::Memcpy(OutMessage.BinaryPayload.GetData(),
                                    Data + RESPONSE_HEADER_SIZE,
                                    Buffer.Num() - RESPONSE_HEADER_SIZE);
                }
                else
                {
                    OutMessage.Payload = FString(UTF8_TO_TCHAR(
                        reinterpret_cast<const char*>(Data + RESPONSE_HEADER_SIZE)));
                }
            }
        }
        else
        {
            // Parse request (31-byte header)
            if (Buffer.Num() < REQUEST_HEADER_SIZE)
            {
                return false;
            }

            OutMessage.Channel = NetworkByteOrder::ReadUInt16(Data, 1);
            OutMessage.SequenceNumber = NetworkByteOrder::ReadUInt32(Data, 3);
            OutMessage.ServiceGuid = NetworkByteOrder::ReadGuid(Data, 7);
            OutMessage.MessageId = static_cast<int64>(NetworkByteOrder::ReadUInt64(Data, 23));
            OutMessage.ResponseCode = 0;

            // Extract payload
            if (Buffer.Num() > REQUEST_HEADER_SIZE)
            {
                if (HasFlag(OutMessage.Flags, EMessageFlags::Binary))
                {
                    OutMessage.BinaryPayload.SetNum(Buffer.Num() - REQUEST_HEADER_SIZE);
                    FMemory::Memcpy(OutMessage.BinaryPayload.GetData(),
                                    Data + REQUEST_HEADER_SIZE,
                                    Buffer.Num() - REQUEST_HEADER_SIZE);
                }
                else
                {
                    OutMessage.Payload = FString(UTF8_TO_TCHAR(
                        reinterpret_cast<const char*>(Data + REQUEST_HEADER_SIZE)));
                }
            }
        }

        return true;
    }

} // namespace Bannou
