//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Orchestrator;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IOrchestratorController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Check infrastructure component health
    /// </summary>

    /// <remarks>
    /// Validates connectivity and health of core infrastructure components:
    /// <br/>- Redis (direct connection via StackExchange.Redis)
    /// <br/>- RabbitMQ (direct connection via RabbitMQ.Client)
    /// <br/>-
    /// </remarks>

    /// <returns>Infrastructure health status (check response body for component health)</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InfrastructureHealthResponse>> GetInfrastructureHealthAsync(InfrastructureHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get health status of all services
    /// </summary>

    /// <remarks>
    /// Retrieves health information from all services via Redis heartbeat monitoring.
    /// <br/>Uses existing ServiceHeartbeatEvent schema from common-events.yaml.
    /// </remarks>

    /// <returns>Service health report</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceHealthReport>> GetServicesHealthAsync(ServiceHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Restart service with optional configuration
    /// </summary>

    /// <remarks>
    /// Performs intelligent service restart based on health metrics.
    /// <br/>Only restarts if truly necessary (e.g., 5+ minute degradation).
    /// <br/>
    /// <br/>Supports optional environment variable updates during restart.
    /// </remarks>

    /// <returns>Service restarted successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRestartResult>> RestartServiceAsync(ServiceRestartRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Check if service needs restart
    /// </summary>

    /// <remarks>
    /// Evaluates service health and determines if restart is necessary.
    /// <br/>
    /// <br/>Restart logic:
    /// <br/>- Healthy: No restart needed
    /// <br/>- Degraded &lt; 5 min: No restart needed
    /// <br/>- Degraded &gt; 5 min: Restart recommended
    /// <br/>- Unavailable: Restart needed
    /// </remarks>

    /// <returns>Restart recommendation</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestartRecommendation>> ShouldRestartServiceAsync(ShouldRestartServiceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Detect available container orchestration backends
    /// </summary>

    /// <remarks>
    /// Detects which container orchestration backends are available on this system.
    /// <br/>Returns availability status and capabilities for each backend.
    /// <br/>
    /// <br/>**Priority Order** (for automatic selection):
    /// <br/>1. Kubernetes - Full cluster orchestration with operators
    /// <br/>2. Portainer - API abstraction over Compose/Swarm with web UI
    /// <br/>3. Docker Swarm - Native Docker cluster orchestration
    /// <br/>4. Docker Compose - Single-host container management
    /// <br/>
    /// <br/>Detection methods:
    /// <br/>- Kubernetes: Check for kubectl and cluster connectivity
    /// <br/>- Portainer: Check for Portainer API endpoint
    /// <br/>- Swarm: Check `docker info` for swarm mode
    /// <br/>- Compose: Check for docker compose v2 availability
    /// </remarks>

    /// <returns>Available backends with capabilities</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BackendsResponse>> GetBackendsAsync(ListBackendsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List available deployment presets
    /// </summary>

    /// <remarks>
    /// Returns all available deployment presets from the orchestrator's preset directory.
    /// <br/>Presets define service combinations and configuration for specific use cases.
    /// <br/>
    /// <br/>Built-in presets:
    /// <br/>- `local-development`: All services in single container with mesh infrastructure
    /// <br/>- `local-testing`: Test environment with infrastructure services
    /// <br/>- `integration-http`: HTTP integration testing preset
    /// <br/>- `integration-edge`: WebSocket/edge testing preset
    /// <br/>- `split-auth-accounts`: Auth and Accounts in separate containers
    /// <br/>- `distributed-npc`: NPC processing distributed across nodes
    /// </remarks>

    /// <returns>Available deployment presets</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PresetsResponse>> GetPresetsAsync(ListPresetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Deploy or update an environment
    /// </summary>

    /// <remarks>
    /// Deploys a complete environment using a preset or custom configuration.
    /// <br/>Supports graceful transitions, forced deployments, and clean rebuilds.
    /// <br/>
    /// <br/>**Deployment Modes**:
    /// <br/>- `graceful`: Wait for existing connections to drain before changing topology
    /// <br/>- `force`: Immediately apply changes (may interrupt active connections)
    /// <br/>- `clean`: Tear down completely and rebuild from scratch
    /// <br/>
    /// <br/>**Backend Selection**:
    /// <br/>- If `backend` not specified, uses highest-priority available backend
    /// <br/>- If `backend` specified but unavailable, returns error (no fallback)
    /// <br/>
    /// <br/>**Live Topology Changes**:
    /// <br/>Supports changing service distribution without full restart:
    /// <br/>- Move auth/accounts to separate container while keeping other services together
    /// <br/>- Scale specific services to additional nodes
    /// <br/>- Update environment variables without restart (where supported)
    /// </remarks>

    /// <returns>Deployment initiated successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeployResponse>> DeployAsync(DeployRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get current service-to-app-id routing mappings
    /// </summary>

    /// <remarks>
    /// Returns the current service-to-app-id routing mappings used for mesh service invocation through lib-mesh.
    /// <br/>This is the authoritative source of truth for how services are routed in the current deployment.
    /// <br/>
    /// <br/>In development, all services route to "bannou" by default. In production, services may be
    /// <br/>distributed across multiple app-ids based on deployment topology.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Services querying routing on startup
    /// <br/>- Debugging service communication issues
    /// <br/>- Monitoring deployment topology
    /// </remarks>

    /// <returns>Service routing mappings</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRoutingResponse>> GetServiceRoutingAsync(GetServiceRoutingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get current environment status
    /// </summary>

    /// <remarks>
    /// Returns comprehensive status of the current deployment including:
    /// <br/>- Active backend and deployment configuration
    /// <br/>- Service topology (which services on which containers)
    /// <br/>- Container health and resource usage
    /// <br/>- Infrastructure component status
    /// <br/>- Active preset and any customizations
    /// </remarks>

    /// <returns>Current environment status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EnvironmentStatus>> GetStatusAsync(GetStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Tear down the current environment
    /// </summary>

    /// <remarks>
    /// Tears down all containers and services in the current deployment.
    /// <br/>Optionally preserves volumes and networks for faster redeployment.
    /// <br/>
    /// <br/>**Teardown Modes**:
    /// <br/>- `graceful`: Signal shutdown and wait for clean exit
    /// <br/>- `force`: Immediately stop all containers (SIGKILL)
    /// <br/>- `preserve-data`: Keep volumes and networks, only remove containers
    /// </remarks>

    /// <returns>Teardown completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TeardownResponse>> TeardownAsync(TeardownRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Clean up unused resources
    /// </summary>

    /// <remarks>
    /// Prunes unused Docker resources to reclaim disk space and clean up
    /// <br/>orphaned containers, networks, volumes, and images.
    /// <br/>
    /// <br/>Equivalent to running various `docker system prune` commands.
    /// <br/>
    /// <br/>**Clean Targets**:
    /// <br/>- `containers`: Remove stopped containers
    /// <br/>- `networks`: Remove unused networks
    /// <br/>- `volumes`: Remove unused volumes (CAUTION: data loss)
    /// <br/>- `images`: Remove dangling images
    /// <br/>- `all`: All of the above
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanResponse>> CleanAsync(CleanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get service/container logs
    /// </summary>

    /// <remarks>
    /// Retrieves logs from services or containers with filtering options.
    /// <br/>Supports real-time streaming via WebSocket upgrade.
    /// </remarks>

    /// <returns>Log output</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LogsResponse>> GetLogsAsync(GetLogsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update service topology without full redeploy
    /// </summary>

    /// <remarks>
    /// Changes which services run on which containers without tearing down
    /// <br/>the entire environment. Enables live topology changes.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Move auth service to dedicated container for scaling
    /// <br/>- Consolidate services during low-traffic periods
    /// <br/>- Split services for debugging/isolation
    /// <br/>- Add new service nodes to running environment
    /// </remarks>

    /// <returns>Topology update applied</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TopologyUpdateResponse>> UpdateTopologyAsync(TopologyUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Request container restart (self-service pattern)
    /// </summary>

    /// <remarks>
    /// Plugins call this endpoint to request restart of their own container.
    /// <br/>This is part of the self-service configuration update pattern where
    /// <br/>plugins decide if they care about config changes and request restarts.
    /// <br/>
    /// <br/>**Flow**:
    /// <br/>1. Orchestrator publishes ConfigurationChangedEvent with changed keys
    /// <br/>2. Plugins check if any changed keys match their dependencies
    /// <br/>3. Plugins that care call this endpoint to request restart
    /// <br/>4. Orchestrator performs rolling restart of requested containers
    /// <br/>
    /// <br/>**Priority Levels**:
    /// <br/>- `graceful`: Rolling update, wait for healthy before cycling next instance
    /// <br/>- `immediate`: Rolling update but don't wait for connection drain
    /// <br/>- `force`: Kill all instances simultaneously (causes downtime)
    /// </remarks>

    /// <returns>Restart request accepted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerRestartResponse>> RequestContainerRestartAsync(ContainerRestartRequestBody body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get container health and restart history
    /// </summary>

    /// <remarks>
    /// Returns detailed status of a container including health, restart history,
    /// <br/>running plugins, and current configuration.
    /// </remarks>

    /// <returns>Container status</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerStatus>> GetContainerStatusAsync(GetContainerStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Rollback to previous configuration
    /// </summary>

    /// <remarks>
    /// Quickly rollback to the previous configuration without waiting for CI.
    /// <br/>Swaps currentConfig with previousConfig and publishes ConfigurationChangedEvent
    /// <br/>with the reverted keys so services can request restart.
    /// <br/>
    /// <br/>**Note**: This is a quick fix. GitHub secrets should still be corrected
    /// <br/>to prevent re-breaking on next orchestrator deploy.
    /// </remarks>

    /// <returns>Rollback completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigRollbackResponse>> RollbackConfigurationAsync(ConfigRollbackRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get current configuration version and metadata
    /// </summary>

    /// <remarks>
    /// Returns the current configuration version, last update time,
    /// <br/>and summary of configuration state (not actual values for security).
    /// </remarks>

    /// <returns>Configuration version info</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigVersionResponse>> GetConfigVersionAsync(GetConfigVersionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Acquire a processor from a pool
    /// </summary>

    /// <remarks>
    /// Requests an available processor instance from the specified pool type.
    /// <br/>Returns the app-id of an available processor or 429 if none available.
    /// <br/>The processor is marked as busy until explicitly released.
    /// </remarks>

    /// <returns>Processor acquired successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AcquireProcessorResponse>> AcquireProcessorAsync(AcquireProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Release a processor back to the pool
    /// </summary>

    /// <remarks>
    /// Releases a previously acquired processor, making it available for other requests.
    /// <br/>Should be called when processing is complete or on error cleanup.
    /// </remarks>

    /// <returns>Processor released successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseProcessorResponse>> ReleaseProcessorAsync(ReleaseProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get processing pool status
    /// </summary>

    /// <remarks>
    /// Returns current status of a processing pool including:
    /// <br/>- Total instances (running and available)
    /// <br/>- Current utilization
    /// <br/>- Queue depth (waiting requests)
    /// <br/>- Recent processing metrics
    /// </remarks>

    /// <returns>Pool status retrieved</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PoolStatusResponse>> GetPoolStatusAsync(GetPoolStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Scale a processing pool
    /// </summary>

    /// <remarks>
    /// Manually adjust the size of a processing pool.
    /// <br/>Can scale up (add instances) or scale down (remove idle instances).
    /// <br/>Respects min/max constraints from pool configuration.
    /// </remarks>

    /// <returns>Pool scaled successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ScalePoolResponse>> ScalePoolAsync(ScalePoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Cleanup idle processing pool instances
    /// </summary>

    /// <remarks>
    /// Scales pool back to minimum instances by removing idle processors.
    /// <br/>Used for resource reclamation during low-activity periods.
    /// </remarks>

    /// <returns>Cleanup completed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupPoolResponse>> CleanupPoolAsync(CleanupPoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class OrchestratorController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IOrchestratorService _implementation;

    public OrchestratorController(IOrchestratorService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.Created => Created("", result),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.Created => result != null ? Created("", result) : Created("", null),
            BeyondImmersion.BannouService.StatusCodes.NoContent => NoContent(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Check infrastructure component health
    /// </summary>
    /// <remarks>
    /// Validates connectivity and health of core infrastructure components:
    /// <br/>- Redis (direct connection via StackExchange.Redis)
    /// <br/>- RabbitMQ (direct connection via RabbitMQ.Client)
    /// <br/>-
    /// </remarks>
    /// <returns>Infrastructure health status (check response body for component health)</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/infrastructure")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<InfrastructureHealthResponse>> GetInfrastructureHealth([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] InfrastructureHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetInfrastructureHealthAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get health status of all services
    /// </summary>
    /// <remarks>
    /// Retrieves health information from all services via Redis heartbeat monitoring.
    /// <br/>Uses existing ServiceHeartbeatEvent schema from common-events.yaml.
    /// </remarks>
    /// <returns>Service health report</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/services")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceHealthReport>> GetServicesHealth([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ServiceHealthRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetServicesHealthAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Restart service with optional configuration
    /// </summary>
    /// <remarks>
    /// Performs intelligent service restart based on health metrics.
    /// <br/>Only restarts if truly necessary (e.g., 5+ minute degradation).
    /// <br/>
    /// <br/>Supports optional environment variable updates during restart.
    /// </remarks>
    /// <returns>Service restarted successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/restart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRestartResult>> RestartService([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ServiceRestartRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RestartServiceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Check if service needs restart
    /// </summary>
    /// <remarks>
    /// Evaluates service health and determines if restart is necessary.
    /// <br/>
    /// <br/>Restart logic:
    /// <br/>- Healthy: No restart needed
    /// <br/>- Degraded &lt; 5 min: No restart needed
    /// <br/>- Degraded &gt; 5 min: Restart recommended
    /// <br/>- Unavailable: Restart needed
    /// </remarks>
    /// <returns>Restart recommendation</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/should-restart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RestartRecommendation>> ShouldRestartService([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ShouldRestartServiceRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ShouldRestartServiceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Detect available container orchestration backends
    /// </summary>
    /// <remarks>
    /// Detects which container orchestration backends are available on this system.
    /// <br/>Returns availability status and capabilities for each backend.
    /// <br/>
    /// <br/>**Priority Order** (for automatic selection):
    /// <br/>1. Kubernetes - Full cluster orchestration with operators
    /// <br/>2. Portainer - API abstraction over Compose/Swarm with web UI
    /// <br/>3. Docker Swarm - Native Docker cluster orchestration
    /// <br/>4. Docker Compose - Single-host container management
    /// <br/>
    /// <br/>Detection methods:
    /// <br/>- Kubernetes: Check for kubectl and cluster connectivity
    /// <br/>- Portainer: Check for Portainer API endpoint
    /// <br/>- Swarm: Check `docker info` for swarm mode
    /// <br/>- Compose: Check for docker compose v2 availability
    /// </remarks>
    /// <returns>Available backends with capabilities</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/backends/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<BackendsResponse>> GetBackends([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListBackendsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetBackendsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List available deployment presets
    /// </summary>
    /// <remarks>
    /// Returns all available deployment presets from the orchestrator's preset directory.
    /// <br/>Presets define service combinations and configuration for specific use cases.
    /// <br/>
    /// <br/>Built-in presets:
    /// <br/>- `local-development`: All services in single container with mesh infrastructure
    /// <br/>- `local-testing`: Test environment with infrastructure services
    /// <br/>- `integration-http`: HTTP integration testing preset
    /// <br/>- `integration-edge`: WebSocket/edge testing preset
    /// <br/>- `split-auth-accounts`: Auth and Accounts in separate containers
    /// <br/>- `distributed-npc`: NPC processing distributed across nodes
    /// </remarks>
    /// <returns>Available deployment presets</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/presets/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PresetsResponse>> GetPresets([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListPresetsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetPresetsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Deploy or update an environment
    /// </summary>
    /// <remarks>
    /// Deploys a complete environment using a preset or custom configuration.
    /// <br/>Supports graceful transitions, forced deployments, and clean rebuilds.
    /// <br/>
    /// <br/>**Deployment Modes**:
    /// <br/>- `graceful`: Wait for existing connections to drain before changing topology
    /// <br/>- `force`: Immediately apply changes (may interrupt active connections)
    /// <br/>- `clean`: Tear down completely and rebuild from scratch
    /// <br/>
    /// <br/>**Backend Selection**:
    /// <br/>- If `backend` not specified, uses highest-priority available backend
    /// <br/>- If `backend` specified but unavailable, returns error (no fallback)
    /// <br/>
    /// <br/>**Live Topology Changes**:
    /// <br/>Supports changing service distribution without full restart:
    /// <br/>- Move auth/accounts to separate container while keeping other services together
    /// <br/>- Scale specific services to additional nodes
    /// <br/>- Update environment variables without restart (where supported)
    /// </remarks>
    /// <returns>Deployment initiated successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/deploy")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeployResponse>> Deploy([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeployRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeployAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get current service-to-app-id routing mappings
    /// </summary>
    /// <remarks>
    /// Returns the current service-to-app-id routing mappings used for mesh service invocation through lib-mesh.
    /// <br/>This is the authoritative source of truth for how services are routed in the current deployment.
    /// <br/>
    /// <br/>In development, all services route to "bannou" by default. In production, services may be
    /// <br/>distributed across multiple app-ids based on deployment topology.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Services querying routing on startup
    /// <br/>- Debugging service communication issues
    /// <br/>- Monitoring deployment topology
    /// </remarks>
    /// <returns>Service routing mappings</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/service-routing")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ServiceRoutingResponse>> GetServiceRouting([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetServiceRoutingRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetServiceRoutingAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get current environment status
    /// </summary>
    /// <remarks>
    /// Returns comprehensive status of the current deployment including:
    /// <br/>- Active backend and deployment configuration
    /// <br/>- Service topology (which services on which containers)
    /// <br/>- Container health and resource usage
    /// <br/>- Infrastructure component status
    /// <br/>- Active preset and any customizations
    /// </remarks>
    /// <returns>Current environment status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<EnvironmentStatus>> GetStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Tear down the current environment
    /// </summary>
    /// <remarks>
    /// Tears down all containers and services in the current deployment.
    /// <br/>Optionally preserves volumes and networks for faster redeployment.
    /// <br/>
    /// <br/>**Teardown Modes**:
    /// <br/>- `graceful`: Signal shutdown and wait for clean exit
    /// <br/>- `force`: Immediately stop all containers (SIGKILL)
    /// <br/>- `preserve-data`: Keep volumes and networks, only remove containers
    /// </remarks>
    /// <returns>Teardown completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/teardown")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TeardownResponse>> Teardown([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TeardownRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.TeardownAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Clean up unused resources
    /// </summary>
    /// <remarks>
    /// Prunes unused Docker resources to reclaim disk space and clean up
    /// <br/>orphaned containers, networks, volumes, and images.
    /// <br/>
    /// <br/>Equivalent to running various `docker system prune` commands.
    /// <br/>
    /// <br/>**Clean Targets**:
    /// <br/>- `containers`: Remove stopped containers
    /// <br/>- `networks`: Remove unused networks
    /// <br/>- `volumes`: Remove unused volumes (CAUTION: data loss)
    /// <br/>- `images`: Remove dangling images
    /// <br/>- `all`: All of the above
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/clean")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanResponse>> Clean([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CleanAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get service/container logs
    /// </summary>
    /// <remarks>
    /// Retrieves logs from services or containers with filtering options.
    /// <br/>Supports real-time streaming via WebSocket upgrade.
    /// </remarks>
    /// <returns>Log output</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/logs")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<LogsResponse>> GetLogs([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetLogsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetLogsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update service topology without full redeploy
    /// </summary>
    /// <remarks>
    /// Changes which services run on which containers without tearing down
    /// <br/>the entire environment. Enables live topology changes.
    /// <br/>
    /// <br/>**Use Cases**:
    /// <br/>- Move auth service to dedicated container for scaling
    /// <br/>- Consolidate services during low-traffic periods
    /// <br/>- Split services for debugging/isolation
    /// <br/>- Add new service nodes to running environment
    /// </remarks>
    /// <returns>Topology update applied</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/topology")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<TopologyUpdateResponse>> UpdateTopology([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] TopologyUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateTopologyAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Request container restart (self-service pattern)
    /// </summary>
    /// <remarks>
    /// Plugins call this endpoint to request restart of their own container.
    /// <br/>This is part of the self-service configuration update pattern where
    /// <br/>plugins decide if they care about config changes and request restarts.
    /// <br/>
    /// <br/>**Flow**:
    /// <br/>1. Orchestrator publishes ConfigurationChangedEvent with changed keys
    /// <br/>2. Plugins check if any changed keys match their dependencies
    /// <br/>3. Plugins that care call this endpoint to request restart
    /// <br/>4. Orchestrator performs rolling restart of requested containers
    /// <br/>
    /// <br/>**Priority Levels**:
    /// <br/>- `graceful`: Rolling update, wait for healthy before cycling next instance
    /// <br/>- `immediate`: Rolling update but don't wait for connection drain
    /// <br/>- `force`: Kill all instances simultaneously (causes downtime)
    /// </remarks>
    /// <returns>Restart request accepted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/request-restart")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerRestartResponse>> RequestContainerRestart([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ContainerRestartRequestBody body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestContainerRestartAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get container health and restart history
    /// </summary>
    /// <remarks>
    /// Returns detailed status of a container including health, restart history,
    /// <br/>running plugins, and current configuration.
    /// </remarks>
    /// <returns>Container status</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ContainerStatus>> GetContainerStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetContainerStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetContainerStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Rollback to previous configuration
    /// </summary>
    /// <remarks>
    /// Quickly rollback to the previous configuration without waiting for CI.
    /// <br/>Swaps currentConfig with previousConfig and publishes ConfigurationChangedEvent
    /// <br/>with the reverted keys so services can request restart.
    /// <br/>
    /// <br/>**Note**: This is a quick fix. GitHub secrets should still be corrected
    /// <br/>to prevent re-breaking on next orchestrator deploy.
    /// </remarks>
    /// <returns>Rollback completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/rollback")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigRollbackResponse>> RollbackConfiguration([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ConfigRollbackRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RollbackConfigurationAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get current configuration version and metadata
    /// </summary>
    /// <remarks>
    /// Returns the current configuration version, last update time,
    /// <br/>and summary of configuration state (not actual values for security).
    /// </remarks>
    /// <returns>Configuration version info</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/version")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ConfigVersionResponse>> GetConfigVersion([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetConfigVersionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetConfigVersionAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Acquire a processor from a pool
    /// </summary>
    /// <remarks>
    /// Requests an available processor instance from the specified pool type.
    /// <br/>Returns the app-id of an available processor or 429 if none available.
    /// <br/>The processor is marked as busy until explicitly released.
    /// </remarks>
    /// <returns>Processor acquired successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/acquire")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AcquireProcessorResponse>> AcquireProcessor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AcquireProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.AcquireProcessorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Release a processor back to the pool
    /// </summary>
    /// <remarks>
    /// Releases a previously acquired processor, making it available for other requests.
    /// <br/>Should be called when processing is complete or on error cleanup.
    /// </remarks>
    /// <returns>Processor released successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/release")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseProcessorResponse>> ReleaseProcessor([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ReleaseProcessorRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ReleaseProcessorAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get processing pool status
    /// </summary>
    /// <remarks>
    /// Returns current status of a processing pool including:
    /// <br/>- Total instances (running and available)
    /// <br/>- Current utilization
    /// <br/>- Queue depth (waiting requests)
    /// <br/>- Recent processing metrics
    /// </remarks>
    /// <returns>Pool status retrieved</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/status")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PoolStatusResponse>> GetPoolStatus([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetPoolStatusRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetPoolStatusAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Scale a processing pool
    /// </summary>
    /// <remarks>
    /// Manually adjust the size of a processing pool.
    /// <br/>Can scale up (add instances) or scale down (remove idle instances).
    /// <br/>Respects min/max constraints from pool configuration.
    /// </remarks>
    /// <returns>Pool scaled successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/scale")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ScalePoolResponse>> ScalePool([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ScalePoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ScalePoolAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Cleanup idle processing pool instances
    /// </summary>
    /// <remarks>
    /// Scales pool back to minimum instances by removing idle processors.
    /// <br/>Used for resource reclamation during low-activity periods.
    /// </remarks>
    /// <returns>Cleanup completed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/cleanup")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<CleanupPoolResponse>> CleanupPool([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CleanupPoolRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CleanupPoolAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for GetInfrastructureHealth

    private static readonly string _GetInfrastructureHealth_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/InfrastructureHealthRequest",
  "$defs": {
    "InfrastructureHealthRequest": {
      "type": "object",
      "additionalProperties": false,
      "description": "Request to check infrastructure health (empty body allowed)",
      "properties": {
        "components": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Optional filter for specific components (redis, rabbitmq, placement)",
          "nullable": true
        }
      }
    }
  }
}
""";

    private static readonly string _GetInfrastructureHealth_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/InfrastructureHealthResponse",
  "$defs": {
    "InfrastructureHealthResponse": {
      "description": "Response containing overall infrastructure health status and individual component details",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "healthy",
        "timestamp",
        "components"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Overall infrastructure health status"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When health check was performed"
        },
        "components": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ComponentHealth"
          },
          "description": "Individual component health status"
        }
      }
    },
    "ComponentHealth": {
      "description": "Health status information for a single infrastructure component (Redis, RabbitMQ, etc.)",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "status",
        "lastSeen"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Component name (redis, rabbitmq, placement)"
        },
        "status": {
          "type": "string",
          "enum": [
            "healthy",
            "degraded",
            "unavailable"
          ],
          "description": "Component health status"
        },
        "lastSeen": {
          "type": "string",
          "format": "date-time",
          "description": "Last successful connection time"
        },
        "message": {
          "type": "string",
          "description": "Additional status information"
        },
        "metrics": {
          "type": "object",
          "additionalProperties": true,
          "description": "Component-specific metrics (e.g., ping time)"
        }
      }
    }
  }
}
""";

    private static readonly string _GetInfrastructureHealth_Info = """
{
  "summary": "Check infrastructure component health",
  "description": "Validates connectivity and health of core infrastructure components:\n- Redis (direct connection via StackExchange.Redis)\ n- RabbitMQ (direct connection via RabbitMQ.Client)\n- \n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetInfrastructureHealth"
}
""";

    /// <summary>Returns endpoint information for GetInfrastructureHealth</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/infrastructure/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetInfrastructureHealth_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/health/infrastructure",
            _GetInfrastructureHealth_Info));

    /// <summary>Returns request schema for GetInfrastructureHealth</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/infrastructure/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetInfrastructureHealth_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/health/infrastructure",
            "request-schema",
            _GetInfrastructureHealth_RequestSchema));

    /// <summary>Returns response schema for GetInfrastructureHealth</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/infrastructure/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetInfrastructureHealth_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/health/infrastructure",
            "response-schema",
            _GetInfrastructureHealth_ResponseSchema));

    /// <summary>Returns full schema for GetInfrastructureHealth</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/infrastructure/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetInfrastructureHealth_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/health/infrastructure",
            _GetInfrastructureHealth_Info,
            _GetInfrastructureHealth_RequestSchema,
            _GetInfrastructureHealth_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetServicesHealth

    private static readonly string _GetServicesHealth_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ServiceHealthRequest",
  "$defs": {
    "ServiceHealthRequest": {
      "type": "object",
      "additionalProperties": false,
      "description": "Request to get service health status (empty body allowed)",
      "properties": {
        "serviceFilter": {
          "type": "string",
          "description": "Optional filter by service name",
          "nullable": true
        }
      }
    }
  }
}
""";

    private static readonly string _GetServicesHealth_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ServiceHealthReport",
  "$defs": {
    "ServiceHealthReport": {
      "description": "Aggregated health report for all services based on heartbeat monitoring",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "timestamp",
        "totalServices",
        "healthPercentage",
        "healthyServices",
        "unhealthyServices"
      ],
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When report was generated"
        },
        "totalServices": {
          "type": "integer",
          "description": "Total number of services"
        },
        "healthPercentage": {
          "type": "number",
          "format": "float",
          "description": "Percentage of healthy services (0-100)"
        },
        "healthyServices": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ServiceHealthStatus"
          },
          "description": "Services with recent heartbeats"
        },
        "unhealthyServices": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ServiceHealthStatus"
          },
          "description": "Services with expired heartbeats"
        }
      }
    },
    "ServiceHealthStatus": {
      "type": "object",
      "additionalProperties": false,
      "description": "Service health status from heartbeat monitoring.\nUses ServiceHeartbeatEvent schema from common-events.yaml.\n",
      "required": [
        "serviceId",
        "appId",
        "status",
        "lastSeen"
      ],
      "properties": {
        "serviceId": {
          "type": "string",
          "description": "Service ID (e.g., \"behavior\", \"accounts\")"
        },
        "appId": {
          "type": "string",
          "description": "App-id for mesh routing (e.g., \"bannou\", \"npc-omega-01\")"
        },
        "status": {
          "type": "string",
          "description": "Service status from heartbeat"
        },
        "lastSeen": {
          "type": "string",
          "format": "date-time",
          "description": "Last heartbeat timestamp"
        },
        "capacity": {
          "description": "Current capacity metrics including load and available slots",
          "$ref": "#/$defs/Capacity",
          "nullable": true
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Additional service metadata (null if not provided)"
        }
      }
    },
    "Capacity": {
      "type": "object",
      "additionalProperties": false,
      "description": "Service capacity metrics from heartbeat monitoring including connection counts and resource usage",
      "properties": {
        "maxConnections": {
          "type": "integer",
          "description": "Maximum number of connections this service can handle"
        },
        "currentConnections": {
          "type": "integer",
          "description": "Current number of active connections"
        },
        "cpuUsage": {
          "type": "number",
          "format": "float",
          "description": "CPU usage as a percentage (0.0 to 1.0)"
        },
        "memoryUsage": {
          "type": "number",
          "format": "float",
          "description": "Memory usage as a percentage (0.0 to 1.0)"
        }
      }
    }
  }
}
""";

    private static readonly string _GetServicesHealth_Info = """
{
  "summary": "Get health status of all services",
  "description": "Retrieves health information from all services via Redis heartbeat monitoring.\nUses existing ServiceHeartbeatEvent schema from common-events.yaml.\n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetServicesHealth"
}
""";

    /// <summary>Returns endpoint information for GetServicesHealth</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/services/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetServicesHealth_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/health/services",
            _GetServicesHealth_Info));

    /// <summary>Returns request schema for GetServicesHealth</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/services/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetServicesHealth_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/health/services",
            "request-schema",
            _GetServicesHealth_RequestSchema));

    /// <summary>Returns response schema for GetServicesHealth</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/services/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetServicesHealth_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/health/services",
            "response-schema",
            _GetServicesHealth_ResponseSchema));

    /// <summary>Returns full schema for GetServicesHealth</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/health/services/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetServicesHealth_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/health/services",
            _GetServicesHealth_Info,
            _GetServicesHealth_RequestSchema,
            _GetServicesHealth_ResponseSchema));

    #endregion

    #region Meta Endpoints for RestartService

    private static readonly string _RestartService_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ServiceRestartRequest",
  "$defs": {
    "ServiceRestartRequest": {
      "description": "Request to restart a specific service with optional configuration updates",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "serviceName"
      ],
      "properties": {
        "serviceName": {
          "type": "string",
          "description": "Name of service to restart"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional environment variable updates"
        },
        "force": {
          "type": "boolean",
          "description": "Force restart even if healthy (default false)"
        },
        "timeout": {
          "type": "integer",
          "description": "Timeout for service to become healthy (seconds, default 120)"
        }
      }
    }
  }
}
""";

    private static readonly string _RestartService_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ServiceRestartResult",
  "$defs": {
    "ServiceRestartResult": {
      "description": "Result of a service restart operation including timing and status information",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "success",
        "serviceName",
        "duration"
      ],
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Restart success status"
        },
        "serviceName": {
          "type": "string",
          "description": "Service that was restarted"
        },
        "duration": {
          "type": "string",
          "description": "Time taken to restart and become healthy"
        },
        "previousStatus": {
          "type": "string",
          "description": "Service status before restart"
        },
        "currentStatus": {
          "type": "string",
          "description": "Service status after restart"
        },
        "message": {
          "type": "string",
          "description": "Restart result message"
        }
      }
    }
  }
}
""";

    private static readonly string _RestartService_Info = """
{
  "summary": "Restart service with optional configuration",
  "description": "Performs intelligent service restart based on health metrics.\nOnly restarts if truly necessary (e.g., 5+ minute degradation).\ n\nSupports optional environment variable updates during restart.\n",
  "tags": [],
  "deprecated": false,
  "operationId": "RestartService"
}
""";

    /// <summary>Returns endpoint information for RestartService</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/restart/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestartService_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/services/restart",
            _RestartService_Info));

    /// <summary>Returns request schema for RestartService</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/restart/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestartService_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/services/restart",
            "request-schema",
            _RestartService_RequestSchema));

    /// <summary>Returns response schema for RestartService</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/restart/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestartService_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/services/restart",
            "response-schema",
            _RestartService_ResponseSchema));

    /// <summary>Returns full schema for RestartService</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/restart/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RestartService_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/services/restart",
            _RestartService_Info,
            _RestartService_RequestSchema,
            _RestartService_ResponseSchema));

    #endregion

    #region Meta Endpoints for ShouldRestartService

    private static readonly string _ShouldRestartService_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ShouldRestartServiceRequest",
  "$defs": {
    "ShouldRestartServiceRequest": {
      "description": "Request to evaluate whether a service should be restarted based on health metrics",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "serviceName"
      ],
      "properties": {
        "serviceName": {
          "type": "string",
          "description": "Name of service to evaluate"
        }
      }
    }
  }
}
""";

    private static readonly string _ShouldRestartService_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/RestartRecommendation",
  "$defs": {
    "RestartRecommendation": {
      "description": "Recommendation on whether a service should be restarted with supporting rationale",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "shouldRestart",
        "serviceName",
        "currentStatus",
        "reason"
      ],
      "properties": {
        "shouldRestart": {
          "type": "boolean",
          "description": "Whether restart is recommended"
        },
        "serviceName": {
          "type": "string",
          "description": "Service being evaluated"
        },
        "currentStatus": {
          "type": "string",
          "description": "Current service health status"
        },
        "lastSeen": {
          "type": "string",
          "format": "date-time",
          "description": "Last heartbeat timestamp"
        },
        "degradedDuration": {
          "type": "string",
          "description": "How long service has been degraded"
        },
        "reason": {
          "type": "string",
          "description": "Explanation for recommendation"
        }
      }
    }
  }
}
""";

    private static readonly string _ShouldRestartService_Info = """
{
  "summary": "Check if service needs restart",
  "description": "Evaluates service health and determines if restart is necessary.\n\nRestart logic:\n- Healthy: No restart needed\n- Degraded < 5 min: No restart needed\n- Degraded > 5 min: Restart recommended\n- Unavailable: Restart needed\n",
  "tags": [],
  "deprecated": false,
  "operationId": "ShouldRestartService"
}
""";

    /// <summary>Returns endpoint information for ShouldRestartService</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/should-restart/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ShouldRestartService_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/services/should-restart",
            _ShouldRestartService_Info));

    /// <summary>Returns request schema for ShouldRestartService</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/should-restart/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ShouldRestartService_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/services/should-restart",
            "request-schema",
            _ShouldRestartService_RequestSchema));

    /// <summary>Returns response schema for ShouldRestartService</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/should-restart/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ShouldRestartService_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/services/should-restart",
            "response-schema",
            _ShouldRestartService_ResponseSchema));

    /// <summary>Returns full schema for ShouldRestartService</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/services/should-restart/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ShouldRestartService_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/services/should-restart",
            _ShouldRestartService_Info,
            _ShouldRestartService_RequestSchema,
            _ShouldRestartService_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetBackends

    private static readonly string _GetBackends_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListBackendsRequest",
  "$defs": {
    "ListBackendsRequest": {
      "type": "object",
      "additionalProperties": false,
      "description": "Request to list available backends (empty body allowed)",
      "properties": {
        "refresh": {
          "type": "boolean",
          "default": false,
          "description": "Force refresh detection instead of using cached results"
        }
      }
    }
  }
}
""";

    private static readonly string _GetBackends_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/BackendsResponse",
  "$defs": {
    "BackendsResponse": {
      "description": "Response listing all detected container orchestration backends with recommended selection",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "timestamp",
        "backends",
        "recommended"
      ],
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When detection was performed"
        },
        "backends": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/BackendInfo"
          },
          "description": "All detected backends with status"
        },
        "recommended": {
          "$ref": "#/$defs/BackendType",
          "description": "Highest priority available backend"
        },
        "activeBackend": {
          "$ref": "#/$defs/BackendType",
          "description": "Currently active backend (if environment deployed)"
        }
      }
    },
    "BackendInfo": {
      "description": "Information about a container orchestration backend including availability and capabilities",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "type",
        "available",
        "priority"
      ],
      "properties": {
        "type": {
          "$ref": "#/$defs/BackendType",
          "description": "Backend type identifier"
        },
        "available": {
          "type": "boolean",
          "description": "Whether this backend is currently available"
        },
        "priority": {
          "type": "integer",
          "description": "Selection priority (1 = highest)"
        },
        "version": {
          "type": "string",
          "description": "Backend version (e.g., \"1.28.0\" for Docker)"
        },
        "endpoint": {
          "type": "string",
          "description": "Backend API endpoint (if applicable)"
        },
        "capabilities": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Supported capabilities for this backend:\ n- live-topology: Can change service distribution without restart\n- scaling: Can scale services horizontally\n- rolling-update: Supports rolling deployments\n- secrets: Native secrets management\n- volumes: Persistent volume support\n- networks: Custom network creation\n"
        },
        "error": {
          "type": "string",
          "description": "Error message if detection failed"
        }
      }
    },
    "BackendType": {
      "type": "string",
      "enum": [
        "kubernetes",
        "portainer",
        "swarm",
        "compose"
      ],
      "description": "Container orchestration backend type.\nPriority order: kubernetes > portainer > swarm > compose\n"
    }
  }
}
""";

    private static readonly string _GetBackends_Info = """
{
  "summary": "Detect available container orchestration backends",
  "description": "Detects which container orchestration backends are available on this system.\nReturns availability status and capabilities for each backend.\n\n**Priority Order** (for automatic selection):\n1. Kubernetes - Full cluster orchestration with operators\n2. Portainer - API abstraction over Compose/Swarm with web UI\n3. Docker Swarm - Native Docker cluster orchestration\n4. Docker Compose - Single-host container management\n\nDetection methods:\n- Kubernetes: Check for kubectl and cluster connectivity\n- Portainer: Check for Portainer API endpoint\n- Swarm: Check `docker info` for swarm mode\n- Compose: Check for docker compose v2 availability\n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetBackends"
}
""";

    /// <summary>Returns endpoint information for GetBackends</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/backends/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBackends_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/backends/list",
            _GetBackends_Info));

    /// <summary>Returns request schema for GetBackends</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/backends/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBackends_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/backends/list",
            "request-schema",
            _GetBackends_RequestSchema));

    /// <summary>Returns response schema for GetBackends</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/backends/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBackends_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/backends/list",
            "response-schema",
            _GetBackends_ResponseSchema));

    /// <summary>Returns full schema for GetBackends</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/backends/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetBackends_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/backends/list",
            _GetBackends_Info,
            _GetBackends_RequestSchema,
            _GetBackends_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetPresets

    private static readonly string _GetPresets_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ListPresetsRequest",
  "$defs": {
    "ListPresetsRequest": {
      "type": "object",
      "additionalProperties": false,
      "description": "Request to list available presets (empty body allowed)",
      "properties": {
        "category": {
          "type": "string",
          "enum": [
            "development",
            "testing",
            "production",
            "custom"
          ],
          "description": "Optional filter by category",
          "nullable": true
        }
      }
    }
  }
}
""";

    private static readonly string _GetPresets_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/PresetsResponse",
  "$defs": {
    "PresetsResponse": {
      "description": "Response containing available deployment presets and the currently active preset",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "presets"
      ],
      "properties": {
        "presets": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/DeploymentPreset"
          },
          "description": "Available deployment presets"
        },
        "activePreset": {
          "type": "string",
          "description": "Currently active preset name (if any)"
        }
      }
    },
    "DeploymentPreset": {
      "description": "Predefined deployment configuration defining service topology and environment settings",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "description",
        "topology"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique preset identifier (e.g., \"local-development\")"
        },
        "description": {
          "type": "string",
          "description": "Human-readable preset description"
        },
        "category": {
          "type": "string",
          "enum": [
            "development",
            "testing",
            "production",
            "custom"
          ],
          "description": "Preset category"
        },
        "topology": {
          "$ref": "#/$defs/ServiceTopology",
          "description": "Service topology defined by this preset"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Default environment variables for this preset"
        },
        "requiredBackends": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/BackendType"
          },
          "description": "Backends that support this preset (empty = all)"
        },
        "builtIn": {
          "type": "boolean",
          "description": "Whether this is a built-in preset"
        },
        "filePath": {
          "type": "string",
          "description": "Path to preset configuration file"
        }
      }
    },
    "ServiceTopology": {
      "description": "Service distribution topology defining which services run on which nodes",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TopologyNode"
          },
          "description": "Container/pod definitions with service assignments"
        },
        "infrastructure": {
          "$ref": "#/$defs/InfrastructureConfig",
          "description": "Infrastructure service configuration"
        }
      }
    },
    "TopologyNode": {
      "description": "A container or pod in the service topology with its assigned services and configuration",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "services"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Node/container name (e.g., \"bannou-main\", \"bannou-auth\")"
        },
        "services": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Services enabled on this node.\nUses {SERVICE}_SERVICE_ENABLED=true pattern.\nExample: [\"accounts\", \"auth\", \"permissions\"]\n"
        },
        "replicas": {
          "type": "integer",
          "default": 1,
          "description": "Number of replicas for this node"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests for this node"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Node-specific environment overrides"
        },
        "meshEnabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether mesh routing is enabled"
        },
        "appId": {
          "type": "string",
          "description": "App-id override for mesh routing (default derives from node name)"
        }
      }
    },
    "ResourceLimits": {
      "type": "object",
      "additionalProperties": false,
      "description": "Resource limits and requests for container scheduling",
      "properties": {
        "cpuLimit": {
          "type": "string",
          "description": "CPU limit (e.g., \"0.5\", \"2\")"
        },
        "memoryLimit": {
          "type": "string",
          "description": "Memory limit (e.g., \"512m\", \"2g\")"
        },
        "cpuRequest": {
          "type": "string",
          "description": "CPU request (Kubernetes)"
        },
        "memoryRequest": {
          "type": "string",
          "description": "Memory request (Kubernetes)"
        }
      }
    },
    "InfrastructureConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for infrastructure services",
      "properties": {
        "redis": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "Redis configuration"
        },
        "rabbitmq": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "RabbitMQ configuration"
        },
        "mysql": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "MySQL configuration"
        },
        "ingress": {
          "$ref": "#/$defs/IngressConfig",
          "description": "Ingress/reverse proxy configuration"
        }
      }
    },
    "InfraServiceConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for an infrastructure service",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether this infrastructure service is enabled"
        },
        "image": {
          "type": "string",
          "description": "Docker image override"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Environment variables for this service"
        },
        "volumes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Volume mounts"
        }
      }
    },
    "IngressConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Ingress/reverse proxy configuration",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether ingress is enabled"
        },
        "type": {
          "type": "string",
          "enum": [
            "openresty",
            "nginx",
            "traefik",
            "none"
          ],
          "default": "openresty",
          "description": "Type of ingress/reverse proxy to use"
        },
        "ports": {
          "description": "Port configuration for HTTP and HTTPS traffic",
          "$ref": "#/$defs/Ports"
        },
        "ssl": {
          "type": "boolean",
          "default": false,
          "description": "Whether SSL/TLS is enabled"
        }
      }
    },
    "Ports": {
      "type": "object",
      "additionalProperties": false,
      "description": "Port configuration for ingress specifying HTTP and HTTPS port numbers",
      "properties": {
        "http": {
          "type": "integer",
          "default": 80,
          "description": "HTTP port number"
        },
        "https": {
          "type": "integer",
          "default": 443,
          "description": "HTTPS port number"
        }
      }
    },
    "BackendType": {
      "type": "string",
      "enum": [
        "kubernetes",
        "portainer",
        "swarm",
        "compose"
      ],
      "description": "Container orchestration backend type.\nPriority order: kubernetes > portainer > swarm > compose\n"
    }
  }
}
""";

    private static readonly string _GetPresets_Info = """
{
  "summary": "List available deployment presets",
  "description": "Returns all available deployment presets from the orchestrator's preset directory.\nPresets define service combinations and configuration for specific use cases.\n\nBuilt-in presets:\n- `local-development`: All services in single container with mesh infrastructure\n- `local-testing`: Test environment with infrastructure services\n- `integration-http`: HTTP integration testing preset\n- `integration-edge`: WebSocket/edge testing preset\n- `split-auth-accounts`: Auth and Accounts in separate containers\n- `distributed-npc`: NPC processing distributed across nodes\n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetPresets"
}
""";

    /// <summary>Returns endpoint information for GetPresets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/presets/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetPresets_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/presets/list",
            _GetPresets_Info));

    /// <summary>Returns request schema for GetPresets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/presets/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetPresets_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/presets/list",
            "request-schema",
            _GetPresets_RequestSchema));

    /// <summary>Returns response schema for GetPresets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/presets/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetPresets_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/presets/list",
            "response-schema",
            _GetPresets_ResponseSchema));

    /// <summary>Returns full schema for GetPresets</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/presets/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetPresets_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/presets/list",
            _GetPresets_Info,
            _GetPresets_RequestSchema,
            _GetPresets_ResponseSchema));

    #endregion

    #region Meta Endpoints for Deploy

    private static readonly string _Deploy_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/DeployRequest",
  "$defs": {
    "DeployRequest": {
      "description": "Request to deploy or update an environment using a preset or custom topology",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "preset": {
          "type": "string",
          "description": "Preset name to deploy (mutually exclusive with topology)"
        },
        "topology": {
          "$ref": "#/$defs/ServiceTopology",
          "description": "Custom topology (mutually exclusive with preset)"
        },
        "backend": {
          "$ref": "#/$defs/BackendType",
          "description": "Specific backend to use (fails if unavailable)"
        },
        "mode": {
          "$ref": "#/$defs/DeploymentMode",
          "default": "graceful",
          "description": "How the deployment should be performed"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Environment variable overrides"
        },
        "timeout": {
          "type": "integer",
          "default": 300,
          "description": "Deployment timeout in seconds"
        },
        "waitForHealthy": {
          "type": "boolean",
          "default": true,
          "description": "Wait for all services to report healthy"
        }
      }
    },
    "ServiceTopology": {
      "description": "Service distribution topology defining which services run on which nodes",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TopologyNode"
          },
          "description": "Container/pod definitions with service assignments"
        },
        "infrastructure": {
          "$ref": "#/$defs/InfrastructureConfig",
          "description": "Infrastructure service configuration"
        }
      }
    },
    "TopologyNode": {
      "description": "A container or pod in the service topology with its assigned services and configuration",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "services"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Node/container name (e.g., \"bannou-main\", \"bannou-auth\")"
        },
        "services": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Services enabled on this node.\nUses {SERVICE}_SERVICE_ENABLED=true pattern.\nExample: [\"accounts\", \"auth\", \"permissions\"]\n"
        },
        "replicas": {
          "type": "integer",
          "default": 1,
          "description": "Number of replicas for this node"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests for this node"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Node-specific environment overrides"
        },
        "meshEnabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether mesh routing is enabled"
        },
        "appId": {
          "type": "string",
          "description": "App-id override for mesh routing (default derives from node name)"
        }
      }
    },
    "ResourceLimits": {
      "type": "object",
      "additionalProperties": false,
      "description": "Resource limits and requests for container scheduling",
      "properties": {
        "cpuLimit": {
          "type": "string",
          "description": "CPU limit (e.g., \"0.5\", \"2\")"
        },
        "memoryLimit": {
          "type": "string",
          "description": "Memory limit (e.g., \"512m\", \"2g\")"
        },
        "cpuRequest": {
          "type": "string",
          "description": "CPU request (Kubernetes)"
        },
        "memoryRequest": {
          "type": "string",
          "description": "Memory request (Kubernetes)"
        }
      }
    },
    "InfrastructureConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for infrastructure services",
      "properties": {
        "redis": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "Redis configuration"
        },
        "rabbitmq": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "RabbitMQ configuration"
        },
        "mysql": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "MySQL configuration"
        },
        "ingress": {
          "$ref": "#/$defs/IngressConfig",
          "description": "Ingress/reverse proxy configuration"
        }
      }
    },
    "InfraServiceConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for an infrastructure service",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether this infrastructure service is enabled"
        },
        "image": {
          "type": "string",
          "description": "Docker image override"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Environment variables for this service"
        },
        "volumes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Volume mounts"
        }
      }
    },
    "IngressConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Ingress/reverse proxy configuration",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether ingress is enabled"
        },
        "type": {
          "type": "string",
          "enum": [
            "openresty",
            "nginx",
            "traefik",
            "none"
          ],
          "default": "openresty",
          "description": "Type of ingress/reverse proxy to use"
        },
        "ports": {
          "description": "Port configuration for HTTP and HTTPS traffic",
          "$ref": "#/$defs/Ports"
        },
        "ssl": {
          "type": "boolean",
          "default": false,
          "description": "Whether SSL/TLS is enabled"
        }
      }
    },
    "Ports": {
      "type": "object",
      "additionalProperties": false,
      "description": "Port configuration for ingress specifying HTTP and HTTPS port numbers",
      "properties": {
        "http": {
          "type": "integer",
          "default": 80,
          "description": "HTTP port number"
        },
        "https": {
          "type": "integer",
          "default": 443,
          "description": "HTTPS port number"
        }
      }
    },
    "BackendType": {
      "type": "string",
      "enum": [
        "kubernetes",
        "portainer",
        "swarm",
        "compose"
      ],
      "description": "Container orchestration backend type.\nPriority order: kubernetes > portainer > swarm > compose\n"
    },
    "DeploymentMode": {
      "type": "string",
      "enum": [
        "graceful",
        "force",
        "clean"
      ],
      "description": "Deployment mode:\n- graceful: Wait for connections to drain\n- force: Apply immediately\n- clean: Tear down and rebuild\n"
    }
  }
}
""";

    private static readonly string _Deploy_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/DeployResponse",
  "$defs": {
    "DeployResponse": {
      "description": "Result of a deployment operation including status and deployed service information",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "success",
        "deploymentId",
        "backend",
        "duration"
      ],
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Deployment succeeded"
        },
        "deploymentId": {
          "type": "string",
          "description": "Unique deployment identifier for tracking"
        },
        "backend": {
          "$ref": "#/$defs/BackendType",
          "description": "Container orchestration backend used for deployment"
        },
        "preset": {
          "type": "string",
          "description": "Preset used (if applicable)"
        },
        "duration": {
          "type": "string",
          "description": "Time taken to deploy"
        },
        "topology": {
          "$ref": "#/$defs/ServiceTopology",
          "description": "Final applied topology"
        },
        "services": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/DeployedService"
          },
          "description": "Status of deployed services"
        },
        "warnings": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Non-fatal warnings during deployment"
        },
        "message": {
          "type": "string",
          "description": "Human-readable deployment summary"
        }
      }
    },
    "BackendType": {
      "type": "string",
      "enum": [
        "kubernetes",
        "portainer",
        "swarm",
        "compose"
      ],
      "description": "Container orchestration backend type.\nPriority order: kubernetes > portainer > swarm > compose\n"
    },
    "ServiceTopology": {
      "description": "Service distribution topology defining which services run on which nodes",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TopologyNode"
          },
          "description": "Container/pod definitions with service assignments"
        },
        "infrastructure": {
          "$ref": "#/$defs/InfrastructureConfig",
          "description": "Infrastructure service configuration"
        }
      }
    },
    "TopologyNode": {
      "description": "A container or pod in the service topology with its assigned services and configuration",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "services"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Node/container name (e.g., \"bannou-main\", \"bannou-auth\")"
        },
        "services": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Services enabled on this node.\nUses {SERVICE}_SERVICE_ENABLED=true pattern.\nExample: [\"accounts\", \"auth\", \"permissions\"]\n"
        },
        "replicas": {
          "type": "integer",
          "default": 1,
          "description": "Number of replicas for this node"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests for this node"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Node-specific environment overrides"
        },
        "meshEnabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether mesh routing is enabled"
        },
        "appId": {
          "type": "string",
          "description": "App-id override for mesh routing (default derives from node name)"
        }
      }
    },
    "ResourceLimits": {
      "type": "object",
      "additionalProperties": false,
      "description": "Resource limits and requests for container scheduling",
      "properties": {
        "cpuLimit": {
          "type": "string",
          "description": "CPU limit (e.g., \"0.5\", \"2\")"
        },
        "memoryLimit": {
          "type": "string",
          "description": "Memory limit (e.g., \"512m\", \"2g\")"
        },
        "cpuRequest": {
          "type": "string",
          "description": "CPU request (Kubernetes)"
        },
        "memoryRequest": {
          "type": "string",
          "description": "Memory request (Kubernetes)"
        }
      }
    },
    "InfrastructureConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for infrastructure services",
      "properties": {
        "redis": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "Redis configuration"
        },
        "rabbitmq": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "RabbitMQ configuration"
        },
        "mysql": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "MySQL configuration"
        },
        "ingress": {
          "$ref": "#/$defs/IngressConfig",
          "description": "Ingress/reverse proxy configuration"
        }
      }
    },
    "InfraServiceConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for an infrastructure service",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether this infrastructure service is enabled"
        },
        "image": {
          "type": "string",
          "description": "Docker image override"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Environment variables for this service"
        },
        "volumes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Volume mounts"
        }
      }
    },
    "IngressConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Ingress/reverse proxy configuration",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether ingress is enabled"
        },
        "type": {
          "type": "string",
          "enum": [
            "openresty",
            "nginx",
            "traefik",
            "none"
          ],
          "default": "openresty",
          "description": "Type of ingress/reverse proxy to use"
        },
        "ports": {
          "description": "Port configuration for HTTP and HTTPS traffic",
          "$ref": "#/$defs/Ports"
        },
        "ssl": {
          "type": "boolean",
          "default": false,
          "description": "Whether SSL/TLS is enabled"
        }
      }
    },
    "Ports": {
      "type": "object",
      "additionalProperties": false,
      "description": "Port configuration for ingress specifying HTTP and HTTPS port numbers",
      "properties": {
        "http": {
          "type": "integer",
          "default": 80,
          "description": "HTTP port number"
        },
        "https": {
          "type": "integer",
          "default": 443,
          "description": "HTTPS port number"
        }
      }
    },
    "DeployedService": {
      "description": "Status information for a single deployed service instance",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "status",
        "node"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Service name"
        },
        "status": {
          "type": "string",
          "enum": [
            "starting",
            "running",
            "healthy",
            "unhealthy",
            "stopped"
          ],
          "description": "Current status of the deployed service"
        },
        "node": {
          "type": "string",
          "description": "Node/container hosting this service"
        },
        "containerId": {
          "type": "string",
          "description": "Container ID (Compose/Swarm)"
        },
        "podName": {
          "type": "string",
          "description": "Pod name (Kubernetes)"
        },
        "endpoints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Exposed endpoints"
        }
      }
    }
  }
}
""";

    private static readonly string _Deploy_Info = """
{
  "summary": "Deploy or update an environment",
  "description": "Deploys a complete environment using a preset or custom configuration.\nSupports graceful transitions, forced deployments, and clean rebuilds.\n\n**Deployment Modes**:\n- `graceful`: Wait for existing connections to drain before changing topology\ n- `force`: Immediately apply changes (may interrupt active connections)\n- `clean`: Tear down completely and rebuild from scratch\n\n**Backend Selection**:\n- If `backend` not specified, uses highest-priority available backend\ n- If `backend` specified but unavailable, returns error (no fallback)\n\n**Live Topology Changes**:\nSupports changing service distribution without full restart:\n- Move auth/accounts to separate container while keeping other services together\n- Scale specific services to additional nodes\n- Update environment variables without restart (where supported)\n",
  "tags": [],
  "deprecated": false,
  "operationId": "Deploy"
}
""";

    /// <summary>Returns endpoint information for Deploy</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/deploy/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Deploy_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/deploy",
            _Deploy_Info));

    /// <summary>Returns request schema for Deploy</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/deploy/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Deploy_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/deploy",
            "request-schema",
            _Deploy_RequestSchema));

    /// <summary>Returns response schema for Deploy</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/deploy/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Deploy_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/deploy",
            "response-schema",
            _Deploy_ResponseSchema));

    /// <summary>Returns full schema for Deploy</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/deploy/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Deploy_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/deploy",
            _Deploy_Info,
            _Deploy_RequestSchema,
            _Deploy_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetServiceRouting

    private static readonly string _GetServiceRouting_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetServiceRoutingRequest",
  "$defs": {
    "GetServiceRoutingRequest": {
      "type": "object",
      "additionalProperties": false,
      "description": "Request to get service routing mappings (empty body allowed)",
      "properties": {
        "serviceFilter": {
          "type": "string",
          "description": "Optional filter by service name prefix",
          "nullable": true
        }
      }
    }
  }
}
""";

    private static readonly string _GetServiceRouting_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ServiceRoutingResponse",
  "$defs": {
    "ServiceRoutingResponse": {
      "description": "Response containing service-to-app-id routing mappings for mesh invocation",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "mappings",
        "defaultAppId",
        "generatedAt"
      ],
      "properties": {
        "mappings": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Map of service names to Bannou app-id routing destinations.\nExample: { \"accounts\": \"bannou\", \"behavior\": \"npc-processing-01\" }\n"
        },
        "defaultAppId": {
          "type": "string",
          "description": "Default app-id used when no specific mapping exists",
          "default": "bannou"
        },
        "generatedAt": {
          "type": "string",
          "format": "date-time",
          "description": "When this routing information was generated"
        },
        "totalServices": {
          "type": "integer",
          "description": "Total number of services with routing mappings",
          "minimum": 0
        },
        "deploymentId": {
          "type": "string",
          "description": "Current deployment identifier (if environment is deployed)",
          "nullable": true
        }
      }
    }
  }
}
""";

    private static readonly string _GetServiceRouting_Info = """
{
  "summary": "Get current service-to-app-id routing mappings",
  "description": "Returns the current service-to-app-id routing mappings used for mesh service invocation through lib-mesh.\nThis is the authoritative source of truth for how services are routed in the current deployment.\n\nIn development, all services route to \"bannou\" by default. In production, services may be\ndistributed across multiple app-ids based on deployment topology.\n\n**Use Cases**:\n- Services querying routing on startup\n- Debugging service communication issues\n- Monitoring deployment topology\n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetServiceRouting"
}
""";

    /// <summary>Returns endpoint information for GetServiceRouting</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/service-routing/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetServiceRouting_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/service-routing",
            _GetServiceRouting_Info));

    /// <summary>Returns request schema for GetServiceRouting</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/service-routing/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetServiceRouting_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/service-routing",
            "request-schema",
            _GetServiceRouting_RequestSchema));

    /// <summary>Returns response schema for GetServiceRouting</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/service-routing/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetServiceRouting_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/service-routing",
            "response-schema",
            _GetServiceRouting_ResponseSchema));

    /// <summary>Returns full schema for GetServiceRouting</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/service-routing/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetServiceRouting_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/service-routing",
            _GetServiceRouting_Info,
            _GetServiceRouting_RequestSchema,
            _GetServiceRouting_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetStatus

    private static readonly string _GetStatus_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetStatusRequest",
  "$defs": {
    "GetStatusRequest": {
      "type": "object",
      "additionalProperties": false,
      "description": "Request to get environment status (empty body allowed)",
      "properties": {
        "includeResources": {
          "type": "boolean",
          "default": true,
          "description": "Include resource usage metrics"
        }
      }
    }
  }
}
""";

    private static readonly string _GetStatus_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/EnvironmentStatus",
  "$defs": {
    "EnvironmentStatus": {
      "description": "Current status of the deployed environment including topology and resource usage",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "deployed",
        "timestamp"
      ],
      "properties": {
        "deployed": {
          "type": "boolean",
          "description": "Whether an environment is currently deployed"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When this status was generated"
        },
        "deploymentId": {
          "type": "string",
          "description": "Current deployment identifier"
        },
        "backend": {
          "$ref": "#/$defs/BackendType",
          "description": "Container orchestration backend in use"
        },
        "preset": {
          "type": "string",
          "description": "Active preset name"
        },
        "topology": {
          "$ref": "#/$defs/ServiceTopology",
          "description": "Current topology configuration"
        },
        "services": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/DeployedService"
          },
          "description": "All deployed services with status"
        },
        "infrastructure": {
          "$ref": "#/$defs/InfrastructureHealthResponse",
          "description": "Infrastructure component health"
        },
        "resources": {
          "$ref": "#/$defs/ResourceUsage",
          "description": "Overall resource usage"
        },
        "uptime": {
          "type": "string",
          "description": "Time since deployment"
        }
      }
    },
    "BackendType": {
      "type": "string",
      "enum": [
        "kubernetes",
        "portainer",
        "swarm",
        "compose"
      ],
      "description": "Container orchestration backend type.\nPriority order: kubernetes > portainer > swarm > compose\n"
    },
    "ServiceTopology": {
      "description": "Service distribution topology defining which services run on which nodes",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TopologyNode"
          },
          "description": "Container/pod definitions with service assignments"
        },
        "infrastructure": {
          "$ref": "#/$defs/InfrastructureConfig",
          "description": "Infrastructure service configuration"
        }
      }
    },
    "TopologyNode": {
      "description": "A container or pod in the service topology with its assigned services and configuration",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "services"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Node/container name (e.g., \"bannou-main\", \"bannou-auth\")"
        },
        "services": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Services enabled on this node.\nUses {SERVICE}_SERVICE_ENABLED=true pattern.\nExample: [\"accounts\", \"auth\", \"permissions\"]\n"
        },
        "replicas": {
          "type": "integer",
          "default": 1,
          "description": "Number of replicas for this node"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests for this node"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Node-specific environment overrides"
        },
        "meshEnabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether mesh routing is enabled"
        },
        "appId": {
          "type": "string",
          "description": "App-id override for mesh routing (default derives from node name)"
        }
      }
    },
    "ResourceLimits": {
      "type": "object",
      "additionalProperties": false,
      "description": "Resource limits and requests for container scheduling",
      "properties": {
        "cpuLimit": {
          "type": "string",
          "description": "CPU limit (e.g., \"0.5\", \"2\")"
        },
        "memoryLimit": {
          "type": "string",
          "description": "Memory limit (e.g., \"512m\", \"2g\")"
        },
        "cpuRequest": {
          "type": "string",
          "description": "CPU request (Kubernetes)"
        },
        "memoryRequest": {
          "type": "string",
          "description": "Memory request (Kubernetes)"
        }
      }
    },
    "InfrastructureConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for infrastructure services",
      "properties": {
        "redis": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "Redis configuration"
        },
        "rabbitmq": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "RabbitMQ configuration"
        },
        "mysql": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "MySQL configuration"
        },
        "ingress": {
          "$ref": "#/$defs/IngressConfig",
          "description": "Ingress/reverse proxy configuration"
        }
      }
    },
    "InfraServiceConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for an infrastructure service",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether this infrastructure service is enabled"
        },
        "image": {
          "type": "string",
          "description": "Docker image override"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Environment variables for this service"
        },
        "volumes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Volume mounts"
        }
      }
    },
    "IngressConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Ingress/reverse proxy configuration",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether ingress is enabled"
        },
        "type": {
          "type": "string",
          "enum": [
            "openresty",
            "nginx",
            "traefik",
            "none"
          ],
          "default": "openresty",
          "description": "Type of ingress/reverse proxy to use"
        },
        "ports": {
          "description": "Port configuration for HTTP and HTTPS traffic",
          "$ref": "#/$defs/Ports"
        },
        "ssl": {
          "type": "boolean",
          "default": false,
          "description": "Whether SSL/TLS is enabled"
        }
      }
    },
    "Ports": {
      "type": "object",
      "additionalProperties": false,
      "description": "Port configuration for ingress specifying HTTP and HTTPS port numbers",
      "properties": {
        "http": {
          "type": "integer",
          "default": 80,
          "description": "HTTP port number"
        },
        "https": {
          "type": "integer",
          "default": 443,
          "description": "HTTPS port number"
        }
      }
    },
    "DeployedService": {
      "description": "Status information for a single deployed service instance",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "status",
        "node"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Service name"
        },
        "status": {
          "type": "string",
          "enum": [
            "starting",
            "running",
            "healthy",
            "unhealthy",
            "stopped"
          ],
          "description": "Current status of the deployed service"
        },
        "node": {
          "type": "string",
          "description": "Node/container hosting this service"
        },
        "containerId": {
          "type": "string",
          "description": "Container ID (Compose/Swarm)"
        },
        "podName": {
          "type": "string",
          "description": "Pod name (Kubernetes)"
        },
        "endpoints": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Exposed endpoints"
        }
      }
    },
    "InfrastructureHealthResponse": {
      "description": "Response containing overall infrastructure health status and individual component details",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "healthy",
        "timestamp",
        "components"
      ],
      "properties": {
        "healthy": {
          "type": "boolean",
          "description": "Overall infrastructure health status"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When health check was performed"
        },
        "components": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/ComponentHealth"
          },
          "description": "Individual component health status"
        }
      }
    },
    "ComponentHealth": {
      "description": "Health status information for a single infrastructure component (Redis, RabbitMQ, etc.)",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "status",
        "lastSeen"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Component name (redis, rabbitmq, placement)"
        },
        "status": {
          "type": "string",
          "enum": [
            "healthy",
            "degraded",
            "unavailable"
          ],
          "description": "Component health status"
        },
        "lastSeen": {
          "type": "string",
          "format": "date-time",
          "description": "Last successful connection time"
        },
        "message": {
          "type": "string",
          "description": "Additional status information"
        },
        "metrics": {
          "type": "object",
          "additionalProperties": true,
          "description": "Component-specific metrics (e.g., ping time)"
        }
      }
    },
    "ResourceUsage": {
      "description": "System resource utilization metrics including CPU, memory, disk, and network",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "cpuPercent": {
          "type": "number",
          "format": "float",
          "description": "Total CPU usage percentage"
        },
        "memoryUsedMb": {
          "type": "integer",
          "description": "Total memory used (MB)"
        },
        "memoryTotalMb": {
          "type": "integer",
          "description": "Total memory available (MB)"
        },
        "diskUsedGb": {
          "type": "number",
          "format": "float",
          "description": "Disk space used (GB)"
        },
        "networkInMb": {
          "type": "number",
          "format": "float",
          "description": "Network input (MB)"
        },
        "networkOutMb": {
          "type": "number",
          "format": "float",
          "description": "Network output (MB)"
        }
      }
    }
  }
}
""";

    private static readonly string _GetStatus_Info = """
{
  "summary": "Get current environment status",
  "description": "Returns comprehensive status of the current deployment including:\n- Active backend and deployment configuration\n- Service topology (which services on which containers)\n- Container health and resource usage\n- Infrastructure component status\n- Active preset and any customizations\n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetStatus"
}
""";

    /// <summary>Returns endpoint information for GetStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/status/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetStatus_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/status",
            _GetStatus_Info));

    /// <summary>Returns request schema for GetStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/status/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetStatus_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/status",
            "request-schema",
            _GetStatus_RequestSchema));

    /// <summary>Returns response schema for GetStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/status/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetStatus_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/status",
            "response-schema",
            _GetStatus_ResponseSchema));

    /// <summary>Returns full schema for GetStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/status/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetStatus_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/status",
            _GetStatus_Info,
            _GetStatus_RequestSchema,
            _GetStatus_ResponseSchema));

    #endregion

    #region Meta Endpoints for Teardown

    private static readonly string _Teardown_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/TeardownRequest",
  "$defs": {
    "TeardownRequest": {
      "description": "Request to tear down a deployed environment with options for data preservation",
      "type": "object",
      "additionalProperties": false,
      "properties": {
        "dryRun": {
          "type": "boolean",
          "default": false,
          "description": "When true, simulates teardown without actually stopping or removing containers.\nReturns what would be torn down. ALWAYS use dryRun=true first to preview the impact.\n"
        },
        "mode": {
          "$ref": "#/$defs/TeardownMode",
          "default": "graceful",
          "description": "How the teardown should be performed"
        },
        "timeout": {
          "type": "integer",
          "default": 60,
          "description": "Graceful shutdown timeout in seconds"
        },
        "removeVolumes": {
          "type": "boolean",
          "default": false,
          "description": "Also remove associated volumes"
        },
        "removeNetworks": {
          "type": "boolean",
          "default": false,
          "description": "Also remove associated networks"
        },
        "includeInfrastructure": {
          "type": "boolean",
          "default": false,
          "description": "When true, also removes support infrastructure (Redis, RabbitMQ, MySQL, etc.).\nThis is determined by scanning compose files or finding containers in the same\nDocker swarm/Kubernetes namespace as bannou services. USE WITH EXTREME CAUTION -\nthis will destroy all data and require a full re-deployment.\n"
        }
      }
    },
    "TeardownMode": {
      "type": "string",
      "enum": [
        "graceful",
        "force",
        "preserve-data"
      ],
      "description": "Teardown mode:\n- graceful: Signal shutdown, wait for clean exit\n- force: Immediately stop (SIGKILL)\n- preserve-data: Keep volumes/networks, remove containers\n"
    }
  }
}
""";

    private static readonly string _Teardown_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/TeardownResponse",
  "$defs": {
    "TeardownResponse": {
      "description": "Result of an environment teardown including removed resources and any errors",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "success",
        "duration"
      ],
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether teardown completed successfully"
        },
        "duration": {
          "type": "string",
          "description": "Time taken to complete teardown"
        },
        "stoppedContainers": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Container IDs that were stopped"
        },
        "removedVolumes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Volumes that were removed"
        },
        "removedNetworks": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Networks that were removed"
        },
        "removedInfrastructure": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Infrastructure services that were removed (Redis, RabbitMQ, MySQL, etc.)"
        },
        "errors": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Non-fatal errors during teardown"
        },
        "message": {
          "type": "string",
          "description": "Human-readable teardown summary"
        }
      }
    }
  }
}
""";

    private static readonly string _Teardown_Info = """
{
  "summary": "Tear down the current environment",
  "description": "Tears down all containers and services in the current deployment.\nOptionally preserves volumes and networks for faster redeployment.\ n\n**Teardown Modes**:\n- `graceful`: Signal shutdown and wait for clean exit\n- `force`: Immediately stop all containers (SIGKILL)\n- `preserve-data`: Keep volumes and networks, only remove containers\n",
  "tags": [],
  "deprecated": false,
  "operationId": "Teardown"
}
""";

    /// <summary>Returns endpoint information for Teardown</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/teardown/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Teardown_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/teardown",
            _Teardown_Info));

    /// <summary>Returns request schema for Teardown</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/teardown/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Teardown_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/teardown",
            "request-schema",
            _Teardown_RequestSchema));

    /// <summary>Returns response schema for Teardown</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/teardown/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Teardown_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/teardown",
            "response-schema",
            _Teardown_ResponseSchema));

    /// <summary>Returns full schema for Teardown</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/teardown/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Teardown_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/teardown",
            _Teardown_Info,
            _Teardown_RequestSchema,
            _Teardown_ResponseSchema));

    #endregion

    #region Meta Endpoints for Clean

    private static readonly string _Clean_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CleanRequest",
  "$defs": {
    "CleanRequest": {
      "description": "Request to clean up Docker resources such as containers, volumes, and images",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "targets"
      ],
      "properties": {
        "targets": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/CleanTarget"
          },
          "description": "Resources to clean (or \"all\")"
        },
        "force": {
          "type": "boolean",
          "default": false,
          "description": "Force removal without confirmation"
        },
        "olderThan": {
          "type": "string",
          "description": "Only clean resources older than (e.g., \"24h\", \"7d\")"
        },
        "labelFilter": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Only clean resources matching labels"
        }
      }
    },
    "CleanTarget": {
      "type": "string",
      "enum": [
        "containers",
        "networks",
        "volumes",
        "images",
        "all"
      ],
      "description": "Type of resource to clean"
    }
  }
}
""";

    private static readonly string _Clean_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CleanResponse",
  "$defs": {
    "CleanResponse": {
      "description": "Result of a cleanup operation including reclaimed space and removed resource counts",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "success"
      ],
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether cleanup completed successfully"
        },
        "reclaimedSpaceMb": {
          "type": "integer",
          "description": "Disk space reclaimed (MB)"
        },
        "removedContainers": {
          "type": "integer",
          "description": "Number of containers removed"
        },
        "removedNetworks": {
          "type": "integer",
          "description": "Number of networks removed"
        },
        "removedVolumes": {
          "type": "integer",
          "description": "Number of volumes removed"
        },
        "removedImages": {
          "type": "integer",
          "description": "Number of images removed"
        },
        "errors": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Non-fatal errors during cleanup"
        },
        "message": {
          "type": "string",
          "description": "Human-readable cleanup summary"
        }
      }
    }
  }
}
""";

    private static readonly string _Clean_Info = """
{
  "summary": "Clean up unused resources",
  "description": "Prunes unused Docker resources to reclaim disk space and clean up\norphaned containers, networks, volumes, and images.\n\nEquivalent to running various `docker system prune` commands.\n\n**Clean Targets**:\n- `containers`: Remove stopped containers\n- `networks`: Remove unused networks\n- `volumes`: Remove unused volumes (CAUTION: data loss)\n- `images`: Remove dangling images\ n- `all`: All of the above\n",
  "tags": [],
  "deprecated": false,
  "operationId": "Clean"
}
""";

    /// <summary>Returns endpoint information for Clean</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/clean/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Clean_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/clean",
            _Clean_Info));

    /// <summary>Returns request schema for Clean</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/clean/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Clean_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/clean",
            "request-schema",
            _Clean_RequestSchema));

    /// <summary>Returns response schema for Clean</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/clean/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Clean_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/clean",
            "response-schema",
            _Clean_ResponseSchema));

    /// <summary>Returns full schema for Clean</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/clean/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> Clean_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/clean",
            _Clean_Info,
            _Clean_RequestSchema,
            _Clean_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetLogs

    private static readonly string _GetLogs_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetLogsRequest",
  "$defs": {
    "GetLogsRequest": {
      "type": "object",
      "additionalProperties": false,
      "description": "Request to get service/container logs",
      "properties": {
        "service": {
          "type": "string",
          "description": "Service name to get logs for",
          "nullable": true
        },
        "container": {
          "type": "string",
          "description": "Container ID or name (alternative to service)",
          "nullable": true
        },
        "since": {
          "type": "string",
          "description": "Return logs since timestamp (RFC3339 or relative like \"5m\")",
          "nullable": true
        },
        "until": {
          "type": "string",
          "description": "Return logs until timestamp",
          "nullable": true
        },
        "tail": {
          "type": "integer",
          "default": 100,
          "description": "Number of lines from end of logs"
        },
        "follow": {
          "type": "boolean",
          "default": false,
          "description": "Stream logs in real-time (WebSocket upgrade)"
        }
      }
    }
  }
}
""";

    private static readonly string _GetLogs_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/LogsResponse",
  "$defs": {
    "LogsResponse": {
      "description": "Response containing log entries from a service or container",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "logs"
      ],
      "properties": {
        "service": {
          "type": "string",
          "description": "Service name (if queried by service)"
        },
        "container": {
          "type": "string",
          "description": "Container ID/name"
        },
        "logs": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/LogEntry"
          },
          "description": "Log entries matching the query"
        },
        "truncated": {
          "type": "boolean",
          "description": "Whether output was truncated"
        }
      }
    },
    "LogEntry": {
      "description": "A single log entry with timestamp, stream, and message content",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "timestamp",
        "message"
      ],
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When this log entry was recorded"
        },
        "stream": {
          "type": "string",
          "enum": [
            "stdout",
            "stderr"
          ],
          "description": "Output stream type (stdout or stderr)"
        },
        "message": {
          "type": "string",
          "description": "Log message content"
        }
      }
    }
  }
}
""";

    private static readonly string _GetLogs_Info = """
{
  "summary": "Get service/container logs",
  "description": "Retrieves logs from services or containers with filtering options.\nSupports real-time streaming via WebSocket upgrade.\n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetLogs"
}
""";

    /// <summary>Returns endpoint information for GetLogs</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/logs/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLogs_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/logs",
            _GetLogs_Info));

    /// <summary>Returns request schema for GetLogs</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/logs/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLogs_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/logs",
            "request-schema",
            _GetLogs_RequestSchema));

    /// <summary>Returns response schema for GetLogs</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/logs/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLogs_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/logs",
            "response-schema",
            _GetLogs_ResponseSchema));

    /// <summary>Returns full schema for GetLogs</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/logs/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetLogs_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/logs",
            _GetLogs_Info,
            _GetLogs_RequestSchema,
            _GetLogs_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateTopology

    private static readonly string _UpdateTopology_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/TopologyUpdateRequest",
  "$defs": {
    "TopologyUpdateRequest": {
      "description": "Request to apply incremental changes to the current service topology",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "changes"
      ],
      "properties": {
        "changes": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TopologyChange"
          },
          "description": "List of topology changes to apply"
        },
        "mode": {
          "$ref": "#/$defs/DeploymentMode",
          "default": "graceful",
          "description": "How the topology update should be performed"
        },
        "timeout": {
          "type": "integer",
          "default": 120,
          "description": "Timeout for topology update"
        }
      }
    },
    "TopologyChange": {
      "description": "A single topology modification such as adding a node, moving a service, or scaling",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "action"
      ],
      "properties": {
        "action": {
          "type": "string",
          "enum": [
            "add-node",
            "remove-node",
            "move-service",
            "scale",
            "update-env"
          ],
          "description": "Type of topology change"
        },
        "nodeName": {
          "type": "string",
          "description": "Target node name"
        },
        "services": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Services affected by this change"
        },
        "replicas": {
          "type": "integer",
          "description": "New replica count (for scale action)"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Environment updates (for update-env action)"
        },
        "nodeConfig": {
          "$ref": "#/$defs/TopologyNode",
          "description": "Full node config (for add-node action)"
        }
      }
    },
    "TopologyNode": {
      "description": "A container or pod in the service topology with its assigned services and configuration",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "services"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Node/container name (e.g., \"bannou-main\", \"bannou-auth\")"
        },
        "services": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Services enabled on this node.\ nUses {SERVICE}_SERVICE_ENABLED=true pattern.\nExample: [\"accounts\", \"auth\", \"permissions\"]\n"
        },
        "replicas": {
          "type": "integer",
          "default": 1,
          "description": "Number of replicas for this node"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests for this node"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Node-specific environment overrides"
        },
        "meshEnabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether mesh routing is enabled"
        },
        "appId": {
          "type": "string",
          "description": "App-id override for mesh routing (default derives from node name)"
        }
      }
    },
    "ResourceLimits": {
      "type": "object",
      "additionalProperties": false,
      "description": "Resource limits and requests for container scheduling",
      "properties": {
        "cpuLimit": {
          "type": "string",
          "description": "CPU limit (e.g., \"0.5\", \"2\")"
        },
        "memoryLimit": {
          "type": "string",
          "description": "Memory limit (e.g., \"512m\", \"2g\")"
        },
        "cpuRequest": {
          "type": "string",
          "description": "CPU request (Kubernetes)"
        },
        "memoryRequest": {
          "type": "string",
          "description": "Memory request (Kubernetes)"
        }
      }
    },
    "DeploymentMode": {
      "type": "string",
      "enum": [
        "graceful",
        "force",
        "clean"
      ],
      "description": "Deployment mode:\ n- graceful: Wait for connections to drain\n- force: Apply immediately\n- clean: Tear down and rebuild\n"
    }
  }
}
""";

    private static readonly string _UpdateTopology_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/TopologyUpdateResponse",
  "$defs": {
    "TopologyUpdateResponse": {
      "description": "Result of a topology update including applied changes and the new topology state",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "success",
        "appliedChanges"
      ],
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether all topology changes were applied successfully"
        },
        "appliedChanges": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/AppliedChange"
          },
          "description": "Details of each applied change"
        },
        "topology": {
          "$ref": "#/$defs/ServiceTopology",
          "description": "New topology after changes"
        },
        "duration": {
          "type": "string",
          "description": "Time taken to apply topology changes"
        },
        "warnings": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Non-fatal warnings during topology update"
        },
        "message": {
          "type": "string",
          "description": "Human-readable update summary"
        }
      }
    },
    "AppliedChange": {
      "description": "Details of a single topology change that was applied, including success status",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "action",
        "success"
      ],
      "properties": {
        "action": {
          "type": "string",
          "description": "Type of topology change that was applied"
        },
        "target": {
          "type": "string",
          "description": "Node or service affected"
        },
        "success": {
          "type": "boolean",
          "description": "Whether this specific change was applied successfully"
        },
        "error": {
          "type": "string",
          "description": "Error message if failed"
        }
      }
    },
    "ServiceTopology": {
      "description": "Service distribution topology defining which services run on which nodes",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "nodes"
      ],
      "properties": {
        "nodes": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/TopologyNode"
          },
          "description": "Container/pod definitions with service assignments"
        },
        "infrastructure": {
          "$ref": "#/$defs/InfrastructureConfig",
          "description": "Infrastructure service configuration"
        }
      }
    },
    "TopologyNode": {
      "description": "A container or pod in the service topology with its assigned services and configuration",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "name",
        "services"
      ],
      "properties": {
        "name": {
          "type": "string",
          "description": "Node/container name (e.g., \"bannou-main\", \"bannou-auth\")"
        },
        "services": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Services enabled on this node.\ nUses {SERVICE}_SERVICE_ENABLED=true pattern.\nExample: [\"accounts\", \"auth\", \"permissions\"]\n"
        },
        "replicas": {
          "type": "integer",
          "default": 1,
          "description": "Number of replicas for this node"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests for this node"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Node-specific environment overrides"
        },
        "meshEnabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether mesh routing is enabled"
        },
        "appId": {
          "type": "string",
          "description": "App-id override for mesh routing (default derives from node name)"
        }
      }
    },
    "ResourceLimits": {
      "type": "object",
      "additionalProperties": false,
      "description": "Resource limits and requests for container scheduling",
      "properties": {
        "cpuLimit": {
          "type": "string",
          "description": "CPU limit (e.g., \"0.5\", \"2\")"
        },
        "memoryLimit": {
          "type": "string",
          "description": "Memory limit (e.g., \"512m\", \"2g\")"
        },
        "cpuRequest": {
          "type": "string",
          "description": "CPU request (Kubernetes)"
        },
        "memoryRequest": {
          "type": "string",
          "description": "Memory request (Kubernetes)"
        }
      }
    },
    "InfrastructureConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for infrastructure services",
      "properties": {
        "redis": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "Redis configuration"
        },
        "rabbitmq": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "RabbitMQ configuration"
        },
        "mysql": {
          "$ref": "#/$defs/InfraServiceConfig",
          "description": "MySQL configuration"
        },
        "ingress": {
          "$ref": "#/$defs/IngressConfig",
          "description": "Ingress/reverse proxy configuration"
        }
      }
    },
    "InfraServiceConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Configuration for an infrastructure service",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether this infrastructure service is enabled"
        },
        "image": {
          "type": "string",
          "description": "Docker image override"
        },
        "resources": {
          "$ref": "#/$defs/ResourceLimits",
          "description": "Resource limits and requests"
        },
        "environment": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Environment variables for this service"
        },
        "volumes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Volume mounts"
        }
      }
    },
    "IngressConfig": {
      "type": "object",
      "additionalProperties": false,
      "description": "Ingress/reverse proxy configuration",
      "properties": {
        "enabled": {
          "type": "boolean",
          "default": true,
          "description": "Whether ingress is enabled"
        },
        "type": {
          "type": "string",
          "enum": [
            "openresty",
            "nginx",
            "traefik",
            "none"
          ],
          "default": "openresty",
          "description": "Type of ingress/reverse proxy to use"
        },
        "ports": {
          "description": "Port configuration for HTTP and HTTPS traffic",
          "$ref": "#/$defs/Ports"
        },
        "ssl": {
          "type": "boolean",
          "default": false,
          "description": "Whether SSL/TLS is enabled"
        }
      }
    },
    "Ports": {
      "type": "object",
      "additionalProperties": false,
      "description": "Port configuration for ingress specifying HTTP and HTTPS port numbers",
      "properties": {
        "http": {
          "type": "integer",
          "default": 80,
          "description": "HTTP port number"
        },
        "https": {
          "type": "integer",
          "default": 443,
          "description": "HTTPS port number"
        }
      }
    }
  }
}
""";

    private static readonly string _UpdateTopology_Info = """
{
  "summary": "Update service topology without full redeploy",
  "description": "Changes which services run on which containers without tearing down\nthe entire environment. Enables live topology changes.\ n\n**Use Cases**:\n- Move auth service to dedicated container for scaling\n- Consolidate services during low-traffic periods\n- Split services for debugging/isolation\n- Add new service nodes to running environment\n",
  "tags": [],
  "deprecated": false,
  "operationId": "UpdateTopology"
}
""";

    /// <summary>Returns endpoint information for UpdateTopology</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/topology/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateTopology_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/topology",
            _UpdateTopology_Info));

    /// <summary>Returns request schema for UpdateTopology</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/topology/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateTopology_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/topology",
            "request-schema",
            _UpdateTopology_RequestSchema));

    /// <summary>Returns response schema for UpdateTopology</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/topology/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateTopology_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/topology",
            "response-schema",
            _UpdateTopology_ResponseSchema));

    /// <summary>Returns full schema for UpdateTopology</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/topology/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateTopology_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/topology",
            _UpdateTopology_Info,
            _UpdateTopology_RequestSchema,
            _UpdateTopology_ResponseSchema));

    #endregion

    #region Meta Endpoints for RequestContainerRestart

    private static readonly string _RequestContainerRestart_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ContainerRestartRequestBody",
  "$defs": {
    "ContainerRestartRequestBody": {
      "description": "Request body for restarting a container by its app-id",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "appName",
        "reason"
      ],
      "properties": {
        "appName": {
          "type": "string",
          "description": "Container's app-id for mesh routing (e.g., \"bannou\", \"npc-omega\")"
        },
        "reason": {
          "type": "string",
          "description": "Why restart is needed (for logging/auditing)",
          "example": "configuration_change"
        },
        "priority": {
          "$ref": "#/$defs/RestartPriority",
          "description": "Urgency level for the restart"
        },
        "shutdownGracePeriod": {
          "type": "integer",
          "default": 30,
          "description": "Seconds to allow graceful shutdown before force-kill"
        }
      }
    },
    "RestartPriority": {
      "type": "string",
      "enum": [
        "graceful",
        "immediate",
        "force"
      ],
      "description": "Restart urgency level:\n- graceful: Rolling update, wait for healthy before cycling next instance\n- immediate: Rolling update but don't wait for connection drain\n- force: Kill all instances simultaneously (causes downtime)\n"
    }
  }
}
""";

    private static readonly string _RequestContainerRestart_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ContainerRestartResponse",
  "$defs": {
    "ContainerRestartResponse": {
      "description": "Response after accepting a container restart request with scheduling details",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "accepted",
        "appName"
      ],
      "properties": {
        "accepted": {
          "type": "boolean",
          "description": "Whether the restart request was accepted"
        },
        "appName": {
          "type": "string",
          "description": "Container that will be restarted"
        },
        "scheduledFor": {
          "type": "string",
          "format": "date-time",
          "description": "When restart is scheduled (may be queued)"
        },
        "currentInstances": {
          "type": "integer",
          "description": "Number of running instances"
        },
        "restartStrategy": {
          "type": "string",
          "enum": [
            "rolling",
            "simultaneous"
          ],
          "description": "How restart will be performed"
        },
        "message": {
          "type": "string",
          "description": "Additional information"
        }
      }
    }
  }
}
""";

    private static readonly string _RequestContainerRestart_Info = """
{
  "summary": "Request container restart (self-service pattern)",
  "description": "Plugins call this endpoint to request restart of their own container.\nThis is part of the self-service configuration update pattern where\nplugins decide if they care about config changes and request restarts.\n\n**Flow**:\n1. Orchestrator publishes ConfigurationChangedEvent with changed keys\n2. Plugins check if any changed keys match their dependencies\n3. Plugins that care call this endpoint to request restart\n4. Orchestrator performs rolling restart of requested containers\n\n**Priority Levels**:\n- `graceful`: Rolling update, wait for healthy before cycling next instance\n- `immediate`: Rolling update but don't wait for connection drain\n- `force`: Kill all instances simultaneously (causes downtime)\n",
  "tags": [],
  "deprecated": false,
  "operationId": "RequestContainerRestart"
}
""";

    /// <summary>Returns endpoint information for RequestContainerRestart</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/request-restart/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestContainerRestart_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/containers/request-restart",
            _RequestContainerRestart_Info));

    /// <summary>Returns request schema for RequestContainerRestart</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/request-restart/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestContainerRestart_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/containers/request-restart",
            "request-schema",
            _RequestContainerRestart_RequestSchema));

    /// <summary>Returns response schema for RequestContainerRestart</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/request-restart/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestContainerRestart_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/containers/request-restart",
            "response-schema",
            _RequestContainerRestart_ResponseSchema));

    /// <summary>Returns full schema for RequestContainerRestart</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/request-restart/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestContainerRestart_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/containers/request-restart",
            _RequestContainerRestart_Info,
            _RequestContainerRestart_RequestSchema,
            _RequestContainerRestart_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetContainerStatus

    private static readonly string _GetContainerStatus_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetContainerStatusRequest",
  "$defs": {
    "GetContainerStatusRequest": {
      "description": "Request to retrieve the current status of a specific container",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "appName"
      ],
      "properties": {
        "appName": {
          "type": "string",
          "description": "Container's app-id for mesh routing"
        }
      }
    }
  }
}
""";

    private static readonly string _GetContainerStatus_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ContainerStatus",
  "$defs": {
    "ContainerStatus": {
      "description": "Current status of a container including health, restart history, and running plugins",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "appName",
        "status",
        "timestamp"
      ],
      "properties": {
        "appName": {
          "type": "string",
          "description": "Container's app-id for mesh routing"
        },
        "status": {
          "type": "string",
          "enum": [
            "running",
            "starting",
            "stopping",
            "stopped",
            "unhealthy"
          ],
          "description": "Current container status"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When this status was captured"
        },
        "instances": {
          "type": "integer",
          "description": "Number of running instances"
        },
        "plugins": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Plugins running in this container"
        },
        "lastRestart": {
          "type": "string",
          "format": "date-time",
          "description": "When container was last restarted"
        },
        "restartCount": {
          "type": "integer",
          "description": "Number of restarts in last 24 hours"
        },
        "restartHistory": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/RestartHistoryEntry"
          },
          "description": "Recent restart history"
        },
        "healthChecks": {
          "description": "Health check configuration and current health status results",
          "$ref": "#/$defs/HealthChecks"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Container labels for metadata and management"
        }
      }
    },
    "RestartHistoryEntry": {
      "description": "Record of a past container restart including reason, timing, and outcome",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "timestamp",
        "reason"
      ],
      "properties": {
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When the restart occurred"
        },
        "reason": {
          "type": "string",
          "description": "Why the restart was triggered"
        },
        "priority": {
          "$ref": "#/$defs/RestartPriority",
          "description": "Priority level used for the restart"
        },
        "duration": {
          "type": "string",
          "description": "Time taken to restart"
        },
        "success": {
          "type": "boolean",
          "description": "Whether the restart completed successfully"
        },
        "error": {
          "type": "string",
          "description": "Error message if restart failed"
        }
      }
    },
    "RestartPriority": {
      "type": "string",
      "enum": [
        "graceful",
        "immediate",
        "force"
      ],
      "description": "Restart urgency level:\n- graceful: Rolling update, wait for healthy before cycling next instance\n- immediate: Rolling update but don't wait for connection drain\n- force: Kill all instances simultaneously (causes downtime)\n"
    },
    "HealthChecks": {
      "type": "object",
      "additionalProperties": false,
      "description": "Health check information for a container including last check status and failure tracking",
      "properties": {
        "lastCheck": {
          "type": "string",
          "format": "date-time",
          "description": "When the last health check was performed"
        },
        "status": {
          "type": "string",
          "description": "Result of the last health check"
        },
        "consecutiveFailures": {
          "type": "integer",
          "description": "Number of consecutive health check failures"
        }
      }
    }
  }
}
""";

    private static readonly string _GetContainerStatus_Info = """
{
  "summary": "Get container health and restart history",
  "description": "Returns detailed status of a container including health, restart history,\nrunning plugins, and current configuration.\n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetContainerStatus"
}
""";

    /// <summary>Returns endpoint information for GetContainerStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/status/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetContainerStatus_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/containers/status",
            _GetContainerStatus_Info));

    /// <summary>Returns request schema for GetContainerStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/status/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetContainerStatus_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/containers/status",
            "request-schema",
            _GetContainerStatus_RequestSchema));

    /// <summary>Returns response schema for GetContainerStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/status/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetContainerStatus_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/containers/status",
            "response-schema",
            _GetContainerStatus_ResponseSchema));

    /// <summary>Returns full schema for GetContainerStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/containers/status/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetContainerStatus_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/containers/status",
            _GetContainerStatus_Info,
            _GetContainerStatus_RequestSchema,
            _GetContainerStatus_ResponseSchema));

    #endregion

    #region Meta Endpoints for RollbackConfiguration

    private static readonly string _RollbackConfiguration_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ConfigRollbackRequest",
  "$defs": {
    "ConfigRollbackRequest": {
      "description": "Request to rollback configuration to the previous version",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "reason"
      ],
      "properties": {
        "reason": {
          "type": "string",
          "description": "Why rollback is needed (for auditing)",
          "example": "auth.jwt_secret broke authentication"
        }
      }
    }
  }
}
""";

    private static readonly string _RollbackConfiguration_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ConfigRollbackResponse",
  "$defs": {
    "ConfigRollbackResponse": {
      "description": "Result of a configuration rollback including version changes and affected keys",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "success",
        "previousVersion",
        "currentVersion"
      ],
      "properties": {
        "success": {
          "type": "boolean",
          "description": "Whether rollback completed successfully"
        },
        "previousVersion": {
          "type": "integer",
          "description": "Config version before rollback"
        },
        "currentVersion": {
          "type": "integer",
          "description": "Config version after rollback (now active)"
        },
        "changedKeys": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Keys that were reverted"
        },
        "message": {
          "type": "string",
          "description": "Human-readable rollback summary"
        }
      }
    }
  }
}
""";

    private static readonly string _RollbackConfiguration_Info = """
{
  "summary": "Rollback to previous configuration",
  "description": "Quickly rollback to the previous configuration without waiting for CI.\nSwaps currentConfig with previousConfig and publishes ConfigurationChangedEvent\ nwith the reverted keys so services can request restart.\n\n**Note**: This is a quick fix. GitHub secrets should still be corrected\nto prevent re-breaking on next orchestrator deploy.\n",
  "tags": [],
  "deprecated": false,
  "operationId": "RollbackConfiguration"
}
""";

    /// <summary>Returns endpoint information for RollbackConfiguration</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/rollback/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RollbackConfiguration_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/config/rollback",
            _RollbackConfiguration_Info));

    /// <summary>Returns request schema for RollbackConfiguration</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/rollback/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RollbackConfiguration_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/config/rollback",
            "request-schema",
            _RollbackConfiguration_RequestSchema));

    /// <summary>Returns response schema for RollbackConfiguration</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/rollback/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RollbackConfiguration_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/config/rollback",
            "response-schema",
            _RollbackConfiguration_ResponseSchema));

    /// <summary>Returns full schema for RollbackConfiguration</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/rollback/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RollbackConfiguration_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/config/rollback",
            _RollbackConfiguration_Info,
            _RollbackConfiguration_RequestSchema,
            _RollbackConfiguration_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetConfigVersion

    private static readonly string _GetConfigVersion_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetConfigVersionRequest",
  "$defs": {
    "GetConfigVersionRequest": {
      "type": "object",
      "additionalProperties": false,
      "description": "Request to get configuration version (empty body allowed)",
      "properties": {
        "includeKeyPrefixes": {
          "type": "boolean",
          "default": true,
          "description": "Include list of configuration key prefixes"
        }
      }
    }
  }
}
""";

    private static readonly string _GetConfigVersion_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ConfigVersionResponse",
  "$defs": {
    "ConfigVersionResponse": {
      "description": "Current configuration version information with metadata about available keys",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "version",
        "timestamp"
      ],
      "properties": {
        "version": {
          "type": "integer",
          "description": "Current configuration version number"
        },
        "timestamp": {
          "type": "string",
          "format": "date-time",
          "description": "When current config was applied"
        },
        "hasPreviousConfig": {
          "type": "boolean",
          "description": "Whether a previous config is available for rollback"
        },
        "keyCount": {
          "type": "integer",
          "description": "Number of configuration keys (not values for security)"
        },
        "keyPrefixes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Configuration key prefixes present (e.g., \"auth\", \"database\")"
        }
      }
    }
  }
}
""";

    private static readonly string _GetConfigVersion_Info = """
{
  "summary": "Get current configuration version and metadata",
  "description": "Returns the current configuration version, last update time,\nand summary of configuration state (not actual values for security).\n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetConfigVersion"
}
""";

    /// <summary>Returns endpoint information for GetConfigVersion</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/version/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetConfigVersion_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/config/version",
            _GetConfigVersion_Info));

    /// <summary>Returns request schema for GetConfigVersion</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/version/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetConfigVersion_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/config/version",
            "request-schema",
            _GetConfigVersion_RequestSchema));

    /// <summary>Returns response schema for GetConfigVersion</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/version/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetConfigVersion_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/config/version",
            "response-schema",
            _GetConfigVersion_ResponseSchema));

    /// <summary>Returns full schema for GetConfigVersion</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/config/version/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetConfigVersion_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/config/version",
            _GetConfigVersion_Info,
            _GetConfigVersion_RequestSchema,
            _GetConfigVersion_ResponseSchema));

    #endregion

    #region Meta Endpoints for AcquireProcessor

    private static readonly string _AcquireProcessor_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/AcquireProcessorRequest",
  "$defs": {
    "AcquireProcessorRequest": {
      "description": "Request to acquire a processor instance from a processing pool",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "poolType"
      ],
      "properties": {
        "poolType": {
          "type": "string",
          "description": "Type of processing pool (e.g., \"asset-processor\", \"texture-processor\")"
        },
        "priority": {
          "type": "integer",
          "default": 0,
          "description": "Request priority (higher = more urgent)"
        },
        "timeoutSeconds": {
          "type": "integer",
          "default": 300,
          "description": "How long the lease is valid for"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": true,
          "nullable": true,
          "description": "Optional metadata about the processing job (null if not needed)"
        }
      }
    }
  }
}
""";

    private static readonly string _AcquireProcessor_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/AcquireProcessorResponse",
  "$defs": {
    "AcquireProcessorResponse": {
      "description": "Response with acquired processor details including lease information",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "processorId",
        "appId",
        "leaseId",
        "expiresAt"
      ],
      "properties": {
        "processorId": {
          "type": "string",
          "description": "Unique identifier for this processor instance"
        },
        "appId": {
          "type": "string",
          "description": "App-id for mesh service invocation to this processor"
        },
        "leaseId": {
          "type": "string",
          "format": "uuid",
          "description": "Unique lease identifier (used for release)"
        },
        "expiresAt": {
          "type": "string",
          "format": "date-time",
          "description": "When the lease expires (must release before this)"
        }
      }
    }
  }
}
""";

    private static readonly string _AcquireProcessor_Info = """
{
  "summary": "Acquire a processor from a pool",
  "description": "Requests an available processor instance from the specified pool type.\nReturns the app-id of an available processor or 429 if none available.\ nThe processor is marked as busy until explicitly released.\n",
  "tags": [],
  "deprecated": false,
  "operationId": "AcquireProcessor"
}
""";

    /// <summary>Returns endpoint information for AcquireProcessor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/acquire/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AcquireProcessor_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/acquire",
            _AcquireProcessor_Info));

    /// <summary>Returns request schema for AcquireProcessor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/acquire/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AcquireProcessor_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/acquire",
            "request-schema",
            _AcquireProcessor_RequestSchema));

    /// <summary>Returns response schema for AcquireProcessor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/acquire/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AcquireProcessor_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/acquire",
            "response-schema",
            _AcquireProcessor_ResponseSchema));

    /// <summary>Returns full schema for AcquireProcessor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/acquire/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AcquireProcessor_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/acquire",
            _AcquireProcessor_Info,
            _AcquireProcessor_RequestSchema,
            _AcquireProcessor_ResponseSchema));

    #endregion

    #region Meta Endpoints for ReleaseProcessor

    private static readonly string _ReleaseProcessor_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ReleaseProcessorRequest",
  "$defs": {
    "ReleaseProcessorRequest": {
      "description": "Request to release a processor back to the pool after processing completes",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "leaseId"
      ],
      "properties": {
        "leaseId": {
          "type": "string",
          "format": "uuid",
          "description": "The lease ID returned from AcquireProcessor"
        },
        "success": {
          "type": "boolean",
          "default": true,
          "description": "Whether the processing completed successfully"
        },
        "metrics": {
          "type": "object",
          "additionalProperties": true,
          "description": "Optional processing metrics (duration, items processed, etc.)"
        }
      }
    }
  }
}
""";

    private static readonly string _ReleaseProcessor_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ReleaseProcessorResponse",
  "$defs": {
    "ReleaseProcessorResponse": {
      "description": "Confirmation that a processor was released back to the pool",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "released"
      ],
      "properties": {
        "released": {
          "type": "boolean",
          "description": "Whether the processor was successfully released"
        },
        "processorId": {
          "type": "string",
          "description": "ID of the released processor"
        }
      }
    }
  }
}
""";

    private static readonly string _ReleaseProcessor_Info = """
{
  "summary": "Release a processor back to the pool",
  "description": "Releases a previously acquired processor, making it available for other requests.\nShould be called when processing is complete or on error cleanup.\n",
  "tags": [],
  "deprecated": false,
  "operationId": "ReleaseProcessor"
}
""";

    /// <summary>Returns endpoint information for ReleaseProcessor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/release/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseProcessor_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/release",
            _ReleaseProcessor_Info));

    /// <summary>Returns request schema for ReleaseProcessor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/release/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseProcessor_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/release",
            "request-schema",
            _ReleaseProcessor_RequestSchema));

    /// <summary>Returns response schema for ReleaseProcessor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/release/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseProcessor_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/release",
            "response-schema",
            _ReleaseProcessor_ResponseSchema));

    /// <summary>Returns full schema for ReleaseProcessor</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/release/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseProcessor_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/release",
            _ReleaseProcessor_Info,
            _ReleaseProcessor_RequestSchema,
            _ReleaseProcessor_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetPoolStatus

    private static readonly string _GetPoolStatus_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/GetPoolStatusRequest",
  "$defs": {
    "GetPoolStatusRequest": {
      "description": "Request to retrieve status and metrics for a processing pool",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "poolType"
      ],
      "properties": {
        "poolType": {
          "type": "string",
          "description": "Type of processing pool to query"
        },
        "includeMetrics": {
          "type": "boolean",
          "default": true,
          "description": "Include recent processing metrics"
        }
      }
    }
  }
}
""";

    private static readonly string _GetPoolStatus_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/PoolStatusResponse",
  "$defs": {
    "PoolStatusResponse": {
      "description": "Current status of a processing pool including instance counts and utilization",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "poolType",
        "totalInstances",
        "availableInstances",
        "busyInstances",
        "utilization"
      ],
      "properties": {
        "poolType": {
          "type": "string",
          "description": "Pool type"
        },
        "totalInstances": {
          "type": "integer",
          "description": "Total processor instances in the pool"
        },
        "availableInstances": {
          "type": "integer",
          "description": "Instances ready to accept work"
        },
        "busyInstances": {
          "type": "integer",
          "description": "Instances currently processing"
        },
        "queueDepth": {
          "type": "integer",
          "description": "Number of requests waiting for a processor"
        },
        "utilization": {
          "type": "number",
          "format": "float",
          "description": "Current utilization percentage (0.0 to 1.0)"
        },
        "minInstances": {
          "type": "integer",
          "description": "Minimum configured instances"
        },
        "maxInstances": {
          "type": "integer",
          "description": "Maximum configured instances"
        },
        "scaleUpThreshold": {
          "type": "number",
          "format": "float",
          "description": "Utilization threshold for auto-scale-up"
        },
        "recentMetrics": {
          "$ref": "#/$defs/PoolMetrics",
          "description": "Recent processing statistics"
        }
      }
    },
    "PoolMetrics": {
      "type": "object",
      "additionalProperties": false,
      "description": "Processing pool performance metrics",
      "properties": {
        "jobsCompleted1h": {
          "type": "integer",
          "description": "Jobs completed in the last hour"
        },
        "jobsFailed1h": {
          "type": "integer",
          "description": "Jobs failed in the last hour"
        },
        "avgProcessingTimeMs": {
          "type": "integer",
          "description": "Average processing time in milliseconds"
        },
        "lastScaleEvent": {
          "type": "string",
          "format": "date-time",
          "description": "When the pool was last scaled"
        }
      }
    }
  }
}
""";

    private static readonly string _GetPoolStatus_Info = """
{
  "summary": "Get processing pool status",
  "description": "Returns current status of a processing pool including:\n- Total instances (running and available)\n- Current utilization\n- Queue depth (waiting requests)\n- Recent processing metrics\n",
  "tags": [],
  "deprecated": false,
  "operationId": "GetPoolStatus"
}
""";

    /// <summary>Returns endpoint information for GetPoolStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/status/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetPoolStatus_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/status",
            _GetPoolStatus_Info));

    /// <summary>Returns request schema for GetPoolStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/status/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetPoolStatus_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/status",
            "request-schema",
            _GetPoolStatus_RequestSchema));

    /// <summary>Returns response schema for GetPoolStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/status/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetPoolStatus_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/status",
            "response-schema",
            _GetPoolStatus_ResponseSchema));

    /// <summary>Returns full schema for GetPoolStatus</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/status/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetPoolStatus_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/status",
            _GetPoolStatus_Info,
            _GetPoolStatus_RequestSchema,
            _GetPoolStatus_ResponseSchema));

    #endregion

    #region Meta Endpoints for ScalePool

    private static readonly string _ScalePool_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ScalePoolRequest",
  "$defs": {
    "ScalePoolRequest": {
      "description": "Request to scale a processing pool to a target number of instances",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "poolType",
        "targetInstances"
      ],
      "properties": {
        "poolType": {
          "type": "string",
          "description": "Type of processing pool to scale"
        },
        "targetInstances": {
          "type": "integer",
          "minimum": 0,
          "description": "Desired number of instances"
        },
        "force": {
          "type": "boolean",
          "default": false,
          "description": "Force scale even if it would interrupt processing"
        }
      }
    }
  }
}
""";

    private static readonly string _ScalePool_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/ScalePoolResponse",
  "$defs": {
    "ScalePoolResponse": {
      "description": "Result of a pool scaling operation with before and after instance counts",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "poolType",
        "previousInstances",
        "currentInstances"
      ],
      "properties": {
        "poolType": {
          "type": "string",
          "description": "Pool type that was scaled"
        },
        "previousInstances": {
          "type": "integer",
          "description": "Instance count before scaling"
        },
        "currentInstances": {
          "type": "integer",
          "description": "Instance count after scaling"
        },
        "scaledUp": {
          "type": "integer",
          "description": "Number of instances added"
        },
        "scaledDown": {
          "type": "integer",
          "description": "Number of instances removed"
        },
        "message": {
          "type": "string",
          "description": "Status message"
        }
      }
    }
  }
}
""";

    private static readonly string _ScalePool_Info = """
{
  "summary": "Scale a processing pool",
  "description": "Manually adjust the size of a processing pool.\nCan scale up (add instances) or scale down (remove idle instances).\nRespects min/max constraints from pool configuration.\n",
  "tags": [],
  "deprecated": false,
  "operationId": "ScalePool"
}
""";

    /// <summary>Returns endpoint information for ScalePool</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/scale/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ScalePool_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/scale",
            _ScalePool_Info));

    /// <summary>Returns request schema for ScalePool</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/scale/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ScalePool_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/scale",
            "request-schema",
            _ScalePool_RequestSchema));

    /// <summary>Returns response schema for ScalePool</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/scale/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ScalePool_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/scale",
            "response-schema",
            _ScalePool_ResponseSchema));

    /// <summary>Returns full schema for ScalePool</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/scale/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ScalePool_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/scale",
            _ScalePool_Info,
            _ScalePool_RequestSchema,
            _ScalePool_ResponseSchema));

    #endregion

    #region Meta Endpoints for CleanupPool

    private static readonly string _CleanupPool_RequestSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CleanupPoolRequest",
  "$defs": {
    "CleanupPoolRequest": {
      "description": "Request to clean up idle processor instances from a pool",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "poolType"
      ],
      "properties": {
        "poolType": {
          "type": "string",
          "description": "Type of processing pool to cleanup"
        },
        "preserveMinimum": {
          "type": "boolean",
          "default": true,
          "description": "Keep at least minInstances running"
        }
      }
    }
  }
}
""";

    private static readonly string _CleanupPool_ResponseSchema = """
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$ref": "#/$defs/CleanupPoolResponse",
  "$defs": {
    "CleanupPoolResponse": {
      "description": "Result of a pool cleanup operation with removed instance count",
      "type": "object",
      "additionalProperties": false,
      "required": [
        "poolType",
        "instancesRemoved"
      ],
      "properties": {
        "poolType": {
          "type": "string",
          "description": "Pool type that was cleaned up"
        },
        "instancesRemoved": {
          "type": "integer",
          "description": "Number of idle instances removed"
        },
        "currentInstances": {
          "type": "integer",
          "description": "Instance count after cleanup"
        },
        "message": {
          "type": "string",
          "description": "Status message"
        }
      }
    }
  }
}
""";

    private static readonly string _CleanupPool_Info = """
{
  "summary": "Cleanup idle processing pool instances",
  "description": "Scales pool back to minimum instances by removing idle processors.\nUsed for resource reclamation during low-activity periods.\n",
  "tags": [],
  "deprecated": false,
  "operationId": "CleanupPool"
}
""";

    /// <summary>Returns endpoint information for CleanupPool</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/cleanup/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CleanupPool_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/cleanup",
            _CleanupPool_Info));

    /// <summary>Returns request schema for CleanupPool</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/cleanup/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CleanupPool_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/cleanup",
            "request-schema",
            _CleanupPool_RequestSchema));

    /// <summary>Returns response schema for CleanupPool</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/cleanup/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CleanupPool_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/cleanup",
            "response-schema",
            _CleanupPool_ResponseSchema));

    /// <summary>Returns full schema for CleanupPool</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("orchestrator/processing-pool/cleanup/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CleanupPool_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Orchestrator",
            "Post",
            "orchestrator/processing-pool/cleanup",
            _CleanupPool_Info,
            _CleanupPool_RequestSchema,
            _CleanupPool_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
