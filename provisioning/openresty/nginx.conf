# OpenResty + Lua + Redis Configuration for Bannou
# Implements dynamic service routing based on orchestrator Redis data
# Explicit path routing for security - only allowed endpoints are exposed

worker_processes auto;
error_log logs/error.log warn;
pid logs/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    # Logging format for debugging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time uct="$upstream_connect_time" '
                    'uht="$upstream_header_time" urt="$upstream_response_time" '
                    'app_id="$target_app_id" host="$target_host"';

    access_log logs/access.log main;

    # Performance optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;

    # Lua package path for our modules
    lua_package_path "/usr/local/openresty/lua/?.lua;;";

    # Redis connection pool
    lua_shared_dict redis_cluster_slot_locks 100k;

    # Service heartbeat cache
    lua_shared_dict service_heartbeat 10m;

    # Queue status cache
    lua_shared_dict queue_status 5m;

    # Service routing cache
    lua_shared_dict service_routes 5m;

    # Shared dict for asset token validation
    lua_shared_dict asset_tokens 5m;

    # Initialize Redis connections on worker start
    init_worker_by_lua_block {
        local redis_host = os.getenv("REDIS_HOST") or "routing-redis"
        local redis_port = os.getenv("REDIS_PORT") or 6379

        -- Store Redis connection info in shared memory
        ngx.shared.service_routes:set("redis_host", redis_host)
        ngx.shared.service_routes:set("redis_port", redis_port)

        -- Store Asset Redis connection info (for token validation)
        local asset_redis_host = os.getenv("ASSET_REDIS_HOST") or "bannou-redis"
        local asset_redis_port = os.getenv("ASSET_REDIS_PORT") or 6379
        ngx.shared.asset_tokens:set("redis_host", asset_redis_host)
        ngx.shared.asset_tokens:set("redis_port", asset_redis_port)

        ngx.log(ngx.INFO, "OpenResty worker initialized with Redis: ", redis_host, ":", redis_port)
        ngx.log(ngx.INFO, "OpenResty worker initialized with Asset Redis: ", asset_redis_host, ":", asset_redis_port)
    }

    # DNS resolver for dynamic upstream resolution
    resolver 127.0.0.11 valid=30s ipv6=off;

    # Default upstream (fallback only)
    upstream bannou_default {
        server bannou:80 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # MinIO upstream for asset storage
    upstream minio_backend {
        server minio:9000 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # Rate limiting zones for asset operations
    limit_req_zone $binary_remote_addr zone=asset_upload:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=asset_download:10m rate=50r/s;

    # Main server - handles all external traffic
    # EXPLICIT PATH ROUTING - only allowed endpoints are exposed
    server {
        listen 80 default_server;
        listen 8080;  # Admin interface
        server_name _;

        # Variables for dynamic routing (set by Lua)
        set $target_app_id "bannou";
        set $target_host "bannou";
        set $target_port "80";

        # Health check endpoint (no auth required)
        location = /health {
            access_log off;
            content_by_lua_block {
                ngx.status = 200
                ngx.say("OpenResty OK")
            }
        }

        # Redis health check
        location = /health/redis {
            content_by_lua_file /usr/local/openresty/lua/redis_health.lua;
        }

        # Routing health check - verify Redis routing data
        location = /health/routing {
            content_by_lua_block {
                local service_route = require "service_route"
                local ok, msg = service_route.check_health()
                if ok then
                    ngx.status = 200
                    ngx.say("Routing OK: ", msg)
                else
                    ngx.status = 503
                    ngx.say("Routing FAILED: ", msg)
                end
            }
        }

        # ============================================================
        # AUTH SERVICE ENDPOINTS
        # Explicit paths for registration, login, and OAuth
        # ============================================================

        # Registration endpoint
        location = /auth/register {
            # Set routing via Lua
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            # Rewrite to mesh invoke path using dynamic app_id
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            # Proxy to dynamic host
            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Login with credentials
        location = /auth/login {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Login with token (refresh) - legacy endpoint
        location = /auth/login/token {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Token refresh endpoint (uses current JWT + refresh token)
        location = /auth/refresh {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # OAuth callback endpoints (Discord, Google, Steam, etc.)
        location ~ ^/auth/oauth/(.+)/callback$ {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # OAuth initiate endpoints
        location ~ ^/auth/oauth/(.+)$ {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Token validation endpoint (requires Authorization header)
        location = /auth/validate {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
            proxy_set_header Authorization $http_authorization;
        }

        # Get sessions endpoint (requires Authorization header)
        location = /auth/sessions {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Authorization $http_authorization;
        }

        # Terminate specific session (requires Authorization header)
        location ~ ^/auth/sessions/([^/]+)$ {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Authorization $http_authorization;
        }

        # Logout endpoint (requires Authorization header)
        location = /auth/logout {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
            proxy_set_header Authorization $http_authorization;
        }

        # Steam Session Ticket verification
        location = /auth/steam/verify {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Password reset request
        location = /auth/password/reset {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Password reset confirmation
        location = /auth/password/confirm {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;
            rewrite ^/auth/(.*) /v1.0/invoke/$target_app_id/method/auth/$1 break;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # ============================================================
        # CONNECT SERVICE ENDPOINTS
        # WebSocket connection with optional query parameters
        # Pattern: /connect or /connect?session=xxx&token=yyy
        # ============================================================

        location ~ ^/connect(/.*)?$ {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            # Rewrite preserving the path after /connect and query string
            rewrite ^/connect(/.*)?$ /v1.0/invoke/$target_app_id/method/connect$1 break;

            # WebSocket upgrade support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket-specific timeouts
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
            proxy_connect_timeout 60s;
        }

        # ============================================================
        # ADMIN ENDPOINTS (Internal only)
        # Service heartbeat and queue status
        # ============================================================

        location /admin/heartbeats {
            # TODO: Add authentication check
            content_by_lua_file /usr/local/openresty/lua/admin_heartbeats.lua;
        }

        location /admin/queues {
            # TODO: Add authentication check
            content_by_lua_file /usr/local/openresty/lua/admin_queues.lua;
        }

        location /admin/routing {
            # Show current routing configuration
            content_by_lua_block {
                local cjson = require "cjson"
                local redis = require "resty.redis"

                local red = redis:new()
                red:set_timeouts(1000, 1000, 1000)

                local redis_host = ngx.shared.service_routes:get("redis_host") or "routing-redis"
                local redis_port = tonumber(ngx.shared.service_routes:get("redis_port")) or 6379

                local ok, err = red:connect(redis_host, redis_port)
                if not ok then
                    ngx.status = 503
                    ngx.say(cjson.encode({error = "Cannot connect to Redis", details = err}))
                    return
                end

                local keys = red:keys("service:routing:*")
                local routings = {}

                if keys then
                    for _, key in ipairs(keys) do
                        local value = red:get(key)
                        if value and value ~= ngx.null then
                            local service = string.gsub(key, "service:routing:", "")
                            local routing_ok, routing = pcall(cjson.decode, value)
                            if routing_ok then
                                routings[service] = routing
                            end
                        end
                    end
                end

                red:set_keepalive(10000, 100)

                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({
                    status = "ok",
                    redis_host = redis_host,
                    redis_port = redis_port,
                    routings = routings
                }))
            }
        }

        # ============================================================
        # QUEUE SERVICE ENDPOINTS (External access)
        # ============================================================

        location /queue/status {
            access_by_lua_file /usr/local/openresty/lua/queue_auth.lua;
            content_by_lua_file /usr/local/openresty/lua/queue_status.lua;
        }

        location /queue/join {
            access_by_lua_file /usr/local/openresty/lua/queue_auth.lua;
            content_by_lua_file /usr/local/openresty/lua/queue_join.lua;
        }

        location /queue/grant {
            access_by_lua_file /usr/local/openresty/lua/queue_auth.lua;
            content_by_lua_file /usr/local/openresty/lua/queue_grant.lua;
        }

        # ============================================================
        # ASSET SERVICE ENDPOINTS
        # Pre-signed URL proxying to MinIO with token validation
        # ============================================================

        # Asset upload endpoint
        # Validates token, then proxies PUT request to MinIO
        location /assets/upload {
            # Rate limiting
            limit_req zone=asset_upload burst=20 nodelay;

            # Validate upload token via Lua
            access_by_lua_file /usr/local/openresty/lua/validate_asset_token.lua;

            # Max upload size (500MB)
            client_max_body_size 500M;

            # Streaming upload - don't buffer request body
            proxy_request_buffering off;

            # Proxy to MinIO
            proxy_pass http://minio_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Pass through content type
            proxy_set_header Content-Type $content_type;

            # Upload timeouts (longer for large files)
            proxy_connect_timeout 60s;
            proxy_send_timeout 600s;
            proxy_read_timeout 600s;
        }

        # Asset download endpoint
        # Validates token, then proxies GET request to MinIO
        location /assets/download {
            # Rate limiting
            limit_req zone=asset_download burst=100 nodelay;

            # Validate download token via Lua
            access_by_lua_file /usr/local/openresty/lua/validate_asset_token.lua;

            # Proxy to MinIO
            proxy_pass http://minio_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Enable sendfile for efficient file serving
            sendfile on;
            tcp_nopush on;
            tcp_nodelay on;

            # Download timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 300s;
            proxy_read_timeout 300s;

            # Response buffering for better performance
            proxy_buffering on;
            proxy_buffer_size 128k;
            proxy_buffers 4 256k;
            proxy_busy_buffers_size 256k;
        }

        # Direct MinIO proxy for pre-signed URLs
        # This handles the actual S3-style requests from clients with pre-signed URLs
        location ~ ^/bannou-assets/ {
            # Rate limiting
            limit_req zone=asset_download burst=100 nodelay;

            # Max upload size
            client_max_body_size 500M;

            # Streaming for uploads
            proxy_request_buffering off;

            # Proxy to MinIO - preserve the path
            proxy_pass http://minio_backend;
            proxy_set_header Host minio:9000;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            # Timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 600s;
            proxy_read_timeout 600s;
        }

        # ============================================================
        # WEBSITE / CATCH-ALL
        # Unknown paths go to website service (or return 404)
        # ============================================================

        location / {
            # For now, proxy unknown paths to default backend
            # Website service will handle routing or return 404
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
