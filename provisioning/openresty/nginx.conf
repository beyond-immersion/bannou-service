# OpenResty + Lua + Redis Configuration for Bannou
# Implements dynamic service routing based on orchestrator Redis data
# Explicit path routing for security - only allowed endpoints are exposed

worker_processes auto;
error_log logs/error.log notice;
pid logs/nginx.pid;

# Pass environment variables to Lua (nginx clears env vars by default)
env REDIS_HOST;
env REDIS_PORT;
env ASSET_REDIS_HOST;
env ASSET_REDIS_PORT;
env AUTH_REDIS_HOST;
env AUTH_REDIS_PORT;
env BANNOU_SERVICE_DOMAIN;

events {
    worker_connections 1024;
    use epoll;
    multi_accept on;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    # Logging format for debugging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    'rt=$request_time uct="$upstream_connect_time" '
                    'uht="$upstream_header_time" urt="$upstream_response_time" '
                    'app_id="$target_app_id" host="$target_host"';

    access_log logs/access.log main;

    # Performance optimizations
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;

    # Lua package path for our modules
    lua_package_path "/usr/local/openresty/lua/?.lua;;";

    # Redis connection pool
    lua_shared_dict redis_cluster_slot_locks 100k;

    # Service heartbeat cache
    lua_shared_dict service_heartbeat 10m;

    # Queue status cache
    lua_shared_dict queue_status 5m;

    # Service routing cache
    lua_shared_dict service_routes 5m;

    # Shared dict for asset token validation
    lua_shared_dict asset_tokens 5m;

    # Shared dict for JWT revocation checking
    lua_shared_dict auth_revocation 5m;

    # Initialize Redis connections on worker start
    init_worker_by_lua_block {
        local redis_host = os.getenv("REDIS_HOST") or "routing-redis"
        local redis_port = os.getenv("REDIS_PORT") or 6379

        -- Store Redis connection info in shared memory
        ngx.shared.service_routes:set("redis_host", redis_host)
        ngx.shared.service_routes:set("redis_port", redis_port)

        -- Store Asset Redis connection info (for token validation)
        local asset_redis_host = os.getenv("ASSET_REDIS_HOST") or "bannou-redis"
        local asset_redis_port = os.getenv("ASSET_REDIS_PORT") or 6379
        ngx.shared.asset_tokens:set("redis_host", asset_redis_host)
        ngx.shared.asset_tokens:set("redis_port", asset_redis_port)

        -- Store Auth Redis connection info (for JWT revocation checking)
        local auth_redis_host = os.getenv("AUTH_REDIS_HOST") or "bannou-redis"
        local auth_redis_port = os.getenv("AUTH_REDIS_PORT") or 6379
        ngx.shared.auth_revocation:set("redis_host", auth_redis_host)
        ngx.shared.auth_revocation:set("redis_port", auth_redis_port)

        ngx.log(ngx.INFO, "OpenResty worker initialized with Redis: ", redis_host, ":", redis_port)
        ngx.log(ngx.INFO, "OpenResty worker initialized with Asset Redis: ", asset_redis_host, ":", asset_redis_port)
        ngx.log(ngx.INFO, "OpenResty worker initialized with Auth Redis: ", auth_redis_host, ":", auth_redis_port)
    }

    # DNS resolver for dynamic upstream resolution
    resolver 127.0.0.11 valid=30s ipv6=off;

    # Default upstream (fallback only)
    upstream bannou_default {
        server bannou:80 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # MinIO upstream for asset storage
    upstream minio_backend {
        server minio:9000 max_fails=3 fail_timeout=30s;
        keepalive 32;
    }

    # Rate limiting zones for asset operations
    limit_req_zone $binary_remote_addr zone=asset_upload:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=asset_download:10m rate=50r/s;

    # Main server - handles all external traffic
    # EXPLICIT PATH ROUTING - only allowed endpoints are exposed
    server {
        listen 80 default_server;
        listen 8080;  # Admin interface
        server_name _;

        # Variables for dynamic routing (set by Lua)
        set $target_app_id "bannou";
        set $target_host "bannou";
        set $target_port "80";

        # Health check endpoint (no auth required)
        location = /health {
            access_log off;
            content_by_lua_block {
                ngx.status = 200
                ngx.say("OpenResty OK")
            }
        }

        # Redis health check
        location = /health/redis {
            content_by_lua_file /usr/local/openresty/lua/redis_health.lua;
        }

        # Routing health check - verify Redis routing data
        location = /health/routing {
            content_by_lua_block {
                local service_route = require "service_route"
                local ok, msg = service_route.check_health()
                if ok then
                    ngx.status = 200
                    ngx.say("Routing OK: ", msg)
                else
                    ngx.status = 503
                    ngx.say("Routing FAILED: ", msg)
                end
            }
        }

        # ============================================================
        # INTERNAL ENDPOINTS (orchestrator use only)
        # ============================================================

        # Cache invalidation endpoint - called by orchestrator after route changes
        # Clears the shared dict cache, forcing re-read from Redis on next request
        location = /internal/cache/invalidate {
            # Only allow internal Docker network access
            allow 10.0.0.0/8;
            allow 172.16.0.0/12;
            allow 192.168.0.0/16;
            allow 127.0.0.1;
            deny all;

            content_by_lua_block {
                local shared = ngx.shared.service_routes
                if shared then
                    -- Only clear routing cache entries (prefix "route_cache:")
                    -- Preserve config entries like "redis_host" set during worker init
                    local keys = shared:get_keys(0)  -- 0 = get all keys
                    local cleared = 0
                    for _, key in ipairs(keys) do
                        if key:sub(1, 12) == "route_cache:" then
                            shared:delete(key)
                            cleared = cleared + 1
                        end
                    end
                    ngx.log(ngx.NOTICE, "[CACHE-INVALIDATE] Cleared ", cleared, " routing cache entries")
                    ngx.status = 200
                    ngx.say('{"success":true,"message":"Cleared ' .. cleared .. ' routing cache entries"}')
                else
                    ngx.status = 500
                    ngx.say('{"success":false,"message":"Shared dict not available"}')
                end
            }
        }

        # ============================================================
        # AUTH SERVICE ENDPOINTS
        # Explicit paths for registration, login, and OAuth
        # ============================================================

        # Registration endpoint
        location = /auth/register {
            # Set routing via Lua
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;


            # Proxy to dynamic host
            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Login with credentials
        location = /auth/login {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Login with token (refresh) - legacy endpoint
        location = /auth/login/token {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Token refresh endpoint (uses current JWT + refresh token)
        location = /auth/refresh {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # OAuth callback endpoints (Discord, Google, Steam, etc.)
        location ~ ^/auth/oauth/(.+)/callback$ {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # OAuth initiate endpoints
        location ~ ^/auth/oauth/(.+)$ {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Token validation endpoint (requires Authorization header)
        # Includes JWT revocation check at edge layer
        location = /auth/validate {
            access_by_lua_block {
                -- Check JWT revocation first (defense-in-depth)
                -- Use loadfile()() instead of dofile() to avoid C-call boundary
                -- that prevents cosocket yielding in OpenResty
                assert(loadfile("/usr/local/openresty/lua/validate_jwt_revocation.lua"))()
                -- Then do service routing
                assert(loadfile("/usr/local/openresty/lua/service_route.lua"))()
            }

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
            proxy_set_header Authorization $http_authorization;
        }

        # Get sessions endpoint (requires Authorization header)
        # Includes JWT revocation check at edge layer
        location = /auth/sessions {
            access_by_lua_block {
                -- Use loadfile()() instead of dofile() to avoid C-call boundary
                -- that prevents cosocket yielding in OpenResty
                assert(loadfile("/usr/local/openresty/lua/validate_jwt_revocation.lua"))()
                assert(loadfile("/usr/local/openresty/lua/service_route.lua"))()
            }

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Authorization $http_authorization;
        }

        # Terminate specific session (requires Authorization header)
        # Includes JWT revocation check at edge layer
        location ~ ^/auth/sessions/([^/]+)$ {
            access_by_lua_block {
                -- Use loadfile()() instead of dofile() to avoid C-call boundary
                -- that prevents cosocket yielding in OpenResty
                assert(loadfile("/usr/local/openresty/lua/validate_jwt_revocation.lua"))()
                assert(loadfile("/usr/local/openresty/lua/service_route.lua"))()
            }

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Authorization $http_authorization;
        }

        # Logout endpoint (requires Authorization header)
        # Includes JWT revocation check at edge layer
        location = /auth/logout {
            access_by_lua_block {
                -- Use loadfile()() instead of dofile() to avoid C-call boundary
                -- that prevents cosocket yielding in OpenResty
                assert(loadfile("/usr/local/openresty/lua/validate_jwt_revocation.lua"))()
                assert(loadfile("/usr/local/openresty/lua/service_route.lua"))()
            }

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
            proxy_set_header Authorization $http_authorization;
        }

        # Steam Session Ticket verification
        location = /auth/steam/verify {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Password reset request
        location = /auth/password/reset {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # Password reset confirmation
        location = /auth/password/confirm {
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Content-Type $content_type;
        }

        # ============================================================
        # CONNECT SERVICE ENDPOINTS
        # WebSocket connection with optional query parameters
        # Pattern: /connect or /connect?session=xxx&token=yyy
        # ============================================================

        # WebSocket connection endpoint
        # Includes JWT revocation check at edge layer (if Authorization header present)
        location ~ ^/connect(/.*)?$ {
            access_by_lua_block {
                -- Check JWT revocation if Authorization header is present
                -- Use loadfile()() instead of dofile() to avoid C-call boundary
                -- that prevents cosocket yielding in OpenResty
                assert(loadfile("/usr/local/openresty/lua/validate_jwt_revocation.lua"))()
                -- Then do service routing
                assert(loadfile("/usr/local/openresty/lua/service_route.lua"))()
            }

            # WebSocket upgrade support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # WebSocket-specific timeouts
            proxy_read_timeout 3600s;
            proxy_send_timeout 3600s;
            proxy_connect_timeout 60s;
        }

        # ============================================================
        # ADMIN ENDPOINTS (Internal only)
        # Service heartbeat and queue status
        # ============================================================

        location /admin/heartbeats {
            # TODO: Add authentication check
            content_by_lua_file /usr/local/openresty/lua/admin_heartbeats.lua;
        }

        location /admin/queues {
            # TODO: Add authentication check
            content_by_lua_file /usr/local/openresty/lua/admin_queues.lua;
        }

        location /admin/routing {
            # Show current routing configuration
            content_by_lua_block {
                local cjson = require "cjson"
                local redis = require "resty.redis"

                local red = redis:new()
                red:set_timeouts(1000, 1000, 1000)

                local redis_host = ngx.shared.service_routes:get("redis_host") or "routing-redis"
                local redis_port = tonumber(ngx.shared.service_routes:get("redis_port")) or 6379

                local ok, err = red:connect(redis_host, redis_port)
                if not ok then
                    ngx.status = 503
                    ngx.say(cjson.encode({error = "Cannot connect to Redis", details = err}))
                    return
                end

                local keys = red:keys("orch:rt:*")
                local routings = {}

                if keys then
                    for _, key in ipairs(keys) do
                        local value = red:get(key)
                        if value and value ~= ngx.null then
                            local service = string.gsub(key, "orch:rt:", "")
                            local routing_ok, routing = pcall(cjson.decode, value)
                            if routing_ok then
                                routings[service] = routing
                            end
                        end
                    end
                end

                red:set_keepalive(10000, 100)

                ngx.header["Content-Type"] = "application/json"
                ngx.say(cjson.encode({
                    status = "ok",
                    redis_host = redis_host,
                    redis_port = redis_port,
                    routings = routings
                }))
            }
        }

        # ============================================================
        # QUEUE SERVICE ENDPOINTS (External access)
        # ============================================================

        location /queue/status {
            access_by_lua_file /usr/local/openresty/lua/queue_auth.lua;
            content_by_lua_file /usr/local/openresty/lua/queue_status.lua;
        }

        location /queue/join {
            access_by_lua_file /usr/local/openresty/lua/queue_auth.lua;
            content_by_lua_file /usr/local/openresty/lua/queue_join.lua;
        }

        location /queue/grant {
            access_by_lua_file /usr/local/openresty/lua/queue_auth.lua;
            content_by_lua_file /usr/local/openresty/lua/queue_grant.lua;
        }

        # ============================================================
        # ASSET SERVICE ENDPOINTS
        # Pre-signed URL proxying to MinIO with token validation
        # ============================================================

        # Asset upload endpoint
        # Validates token, then proxies PUT request to MinIO
        location /assets/upload {
            # Rate limiting
            limit_req zone=asset_upload burst=20 nodelay;

            # Validate upload token via Lua
            access_by_lua_file /usr/local/openresty/lua/validate_asset_token.lua;

            # Max upload size (500MB)
            client_max_body_size 500M;

            # Streaming upload - don't buffer request body
            proxy_request_buffering off;

            # Proxy to MinIO
            proxy_pass http://minio_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Pass through content type
            proxy_set_header Content-Type $content_type;

            # Upload timeouts (longer for large files)
            proxy_connect_timeout 60s;
            proxy_send_timeout 600s;
            proxy_read_timeout 600s;
        }

        # Asset download endpoint
        # Validates token, then proxies GET request to MinIO
        location /assets/download {
            # Rate limiting
            limit_req zone=asset_download burst=100 nodelay;

            # Validate download token via Lua
            access_by_lua_file /usr/local/openresty/lua/validate_asset_token.lua;

            # Proxy to MinIO
            proxy_pass http://minio_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Enable sendfile for efficient file serving
            sendfile on;
            tcp_nopush on;
            tcp_nodelay on;

            # Download timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 300s;
            proxy_read_timeout 300s;

            # Response buffering for better performance
            proxy_buffering on;
            proxy_buffer_size 128k;
            proxy_buffers 4 256k;
            proxy_busy_buffers_size 256k;
        }

        # Direct MinIO proxy for pre-signed URLs
        # This handles the actual S3-style requests from clients with pre-signed URLs
        location ~ ^/bannou-assets/ {
            # Rate limiting
            limit_req zone=asset_download burst=100 nodelay;

            # Max upload size
            client_max_body_size 500M;

            # Streaming for uploads
            proxy_request_buffering off;

            # Proxy to MinIO - preserve the path
            proxy_pass http://minio_backend;
            proxy_set_header Host minio:9000;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

            # Timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 600s;
            proxy_read_timeout 600s;
        }

        # ============================================================
        # PERMISSION-GATED META ENDPOINT PROXY
        # Routes /*/meta/{type} requests to Connect's GetEndpointMeta
        # endpoint, which validates the JWT, looks up the caller's
        # active WebSocket session, checks capability mappings, and
        # proxies the internal meta GET if authorized.
        # ============================================================

        location ~ ^(.+)/meta/(info|request-schema|response-schema|schema)$ {
            set $meta_target_host "bannou";
            set $meta_target_port 80;

            access_by_lua_block {
                -- Route to the Connect service for permission-gated meta proxy.
                -- Uses the same Redis routing lookup as service_route.lua but
                -- hardcodes service name to "connect" regardless of the URI path.
                local redis = require "resty.redis"
                local cjson = require "cjson"

                local red = redis:new()
                red:set_timeouts(1000, 1000, 1000)
                local redis_host = ngx.shared.service_routes:get("redis_host") or "routing-redis"
                local redis_port = tonumber(ngx.shared.service_routes:get("redis_port")) or 6379

                local ok, err = red:connect(redis_host, redis_port)
                if ok then
                    local value = red:get("orch:rt:connect")
                    red:set_keepalive(10000, 100)
                    if value and value ~= ngx.null then
                        local parsed, routing = pcall(cjson.decode, value)
                        if parsed then
                            ngx.var.meta_target_host = routing.host or routing.Host or "bannou"
                            ngx.var.meta_target_port = routing.port or routing.Port or 80
                        end
                    end
                end

                -- Build JSON body with the original meta path
                local json_body = '{"path":"' .. ngx.var.uri .. '"}'
                ngx.req.set_body_data(json_body)
            }

            # Proxy as POST to Connect's meta proxy endpoint
            proxy_method POST;
            proxy_set_header Content-Type application/json;
            proxy_set_header Authorization $http_authorization;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            proxy_pass http://$meta_target_host:$meta_target_port/connect/get-endpoint-meta;
        }

        # ============================================================
        # WEBSITE / CATCH-ALL
        # Unknown paths go to website service (or return 404)
        # ============================================================

        location / {
            # For now, proxy unknown paths to default backend
            # Website service will handle routing or return 404
            access_by_lua_file /usr/local/openresty/lua/service_route.lua;

            proxy_pass http://$target_host:$target_port;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }

    # ============================================================
    # GENERATED CONFIGS (from templates via envsubst)
    # Run generate-configs.sh to regenerate after env changes
    # ============================================================
    include /usr/local/openresty/generated/*.conf;

    # ============================================================
    # ENVIRONMENT OVERRIDES (gitignored)
    # Place production-specific configs here
    # ============================================================
    include /usr/local/openresty/overrides/*.conf;
}
