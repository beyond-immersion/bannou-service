# Session Shortcuts

## Overview

Session Shortcuts are prebound API endpoints that allow services to push pre-configured API calls to a client's session. Instead of constructing full request payloads, clients invoke a shortcut with just a GUID and receive the response for the pre-filled request.

**Design Status**: Specification Complete (December 2025)
**Implementation Branch**: TBD (future feature branch)
**Related Systems**: Connect Service, Permissions Service, Game Session Service

## Motivation

Bannou's Connect service provides clients with a dynamic capability manifest - a list of available API endpoints mapped to client-salted GUIDs. While powerful, this can be overwhelming:

- Clients may have dozens of available endpoints
- Each endpoint requires specific request payloads
- Common operations require knowing session-specific identifiers (character ID, realm ID, etc.)

Session Shortcuts solve this by allowing services to push **pre-filled API calls** that clients can invoke with a single GUID and empty payload.

### Example Use Case

A player connects and possesses a character named "Luna" in the Omega realm. Without shortcuts:

```json
// Client must know:
// 1. The capability GUID for game-session/character/get-stats
// 2. Luna's character ID: "char-luna-001"
// 3. The request format

// Request payload:
{"character_id": "char-luna-001"}
```

With Session Shortcuts:

```json
// GameSession service pushes shortcut at session start:
// "get_my_character_stats" → bound to Luna's character ID

// Client sends: empty payload with shortcut GUID
// Connect injects the bound payload automatically
```

## Architecture

### Core Principle: Minimal Connect Processing

Session Shortcuts maintain Connect's zero-copy philosophy by:

1. Storing pre-serialized JSON payloads (no deserialization needed)
2. Performing O(1) GUID lookups
3. Swapping GUIDs and injecting payloads as raw bytes
4. Forwarding to target service unchanged

Connect never needs to understand payload structure.

### Data Flow

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         SHORTCUT CREATION                               │
└─────────────────────────────────────────────────────────────────────────┘

[GameSession Service]
    │
    │ 1. Player possesses character "Luna"
    │
    ▼
[Publishes to RabbitMQ: CONNECT_SESSION_{sessionId}]
    │
    │ Topic: session.shortcut_published
    │ Payload: {
    │   route_guid: "550e8400-...",      // Client-salted shortcut GUID
    │   target_guid: "7c9e6679-...",     // Existing capability GUID
    │   bound_payload: '{"character_id":"char-luna-001"}',
    │   metadata: { name: "get_my_character_stats", ... }
    │ }
    │
    ▼
[Connect Service - handles session {sessionId}]
    │
    │ 2. Stores shortcut in ConnectionState.SessionShortcuts
    │
    ▼
[Pushes capabilities_updated event to client WebSocket]
    │
    │ Includes both regular capabilities AND session shortcuts
    │
    ▼
[Client receives updated capability manifest]


┌─────────────────────────────────────────────────────────────────────────┐
│                         SHORTCUT INVOCATION                             │
└─────────────────────────────────────────────────────────────────────────┘

[Client sends WebSocket message]
    │
    │ Binary Header: [...][shortcut_guid: 550e8400-...][...]
    │ Payload: {} (empty or ignored)
    │
    ▼
[Connect Service receives message]
    │
    │ 1. Extract GUID from header
    │ 2. Check SessionShortcuts dictionary → MATCH
    │ 3. Get: target_guid + bound_payload
    │
    ▼
[Connect rewrites message]
    │
    │ Binary Header: [...][target_guid: 7c9e6679-...][...]
    │ Payload: '{"character_id":"char-luna-001"}'
    │
    ▼
[Forward to target service via Dapr]
    │
    ▼
[Response flows back to client normally]
```

### Session Scope via RabbitMQ

Shortcuts are published to session-specific RabbitMQ topics:

```
Topic: CONNECT_SESSION_{sessionId}
Subtopics:
  - session.shortcut_published
  - session.shortcut_revoked
```

**Benefits:**
- Only the Connect instance handling that session subscribes
- No system-wide flooding of shortcut events
- Natural cleanup when session ends (subscription removed)

## Data Models

### SessionShortcut

```yaml
SessionShortcut:
  type: object
  required: [route_guid, target_guid, bound_payload, metadata]
  properties:
    route_guid:
      type: string
      format: uuid
      description: |
        Client-salted GUID for invoking this shortcut.
        Generated by the publishing service using GuidGenerator.GenerateSessionShortcutGuid().
        Unique per session - same shortcut name produces different GUIDs for different sessions.

    target_guid:
      type: string
      format: uuid
      description: |
        The actual service capability GUID this shortcut invokes.
        Must be a valid capability in the client's current capability manifest.
        Connect uses this GUID when forwarding to the target service.

    bound_payload:
      type: string
      description: |
        Pre-serialized JSON payload passed unchanged to the target service.
        Connect treats this as opaque bytes - no deserialization or modification.
        Services are responsible for ensuring payload validity.

    metadata:
      $ref: '#/components/schemas/SessionShortcutMetadata'
```

### SessionShortcutMetadata

```yaml
SessionShortcutMetadata:
  type: object
  required: [name, source_service, created_at]
  properties:
    name:
      type: string
      minLength: 1
      maxLength: 128
      pattern: '^[a-z][a-z0-9_]*$'
      description: |
        Machine-readable identifier for this shortcut.
        Used for debugging, logging, and client-side organization.
        Examples: "get_my_character_stats", "list_nearby_npcs", "get_active_quest"

    description:
      type: string
      maxLength: 500
      description: |
        Human-readable description of what this shortcut does.
        Displayed in client UIs and debugging tools.

    source_service:
      type: string
      description: |
        The service that created this shortcut.
        Used for bulk revocation and audit logging.

    created_at:
      type: string
      format: date-time
      description: When this shortcut was created.

    expires_at:
      type: string
      format: date-time
      nullable: true
      description: |
        Optional TTL for this shortcut.
        If set, Connect automatically removes the shortcut after this time.
        Most shortcuts should NOT set this - they remain valid for session lifetime.
        Use only for time-transient operations (e.g., "accept quest within 5 minutes").

    tags:
      type: array
      items:
        type: string
      description: |
        Optional categorization tags for client-side organization.
        Examples: ["character", "combat"], ["inventory", "equipment"]

    display_name:
      type: string
      maxLength: 64
      description: |
        Optional user-friendly name for display in client UIs.
        If not provided, clients should format the 'name' field.
```

### Events

#### ShortcutPublishedEvent

Published by services to create or update a shortcut.

```yaml
ShortcutPublishedEvent:
  type: object
  required: [event_id, session_id, shortcut]
  properties:
    event_id:
      type: string
      format: uuid

    session_id:
      type: string
      description: Target session for this shortcut.

    shortcut:
      $ref: '#/components/schemas/SessionShortcut'

    replace_existing:
      type: boolean
      default: true
      description: |
        If true and a shortcut with the same route_guid exists, replace it.
        If false and shortcut exists, the event is ignored.
```

#### ShortcutRevokedEvent

Published by services to remove shortcuts.

```yaml
ShortcutRevokedEvent:
  type: object
  required: [event_id, session_id]
  properties:
    event_id:
      type: string
      format: uuid

    session_id:
      type: string
      description: Target session for revocation.

    route_guid:
      type: string
      format: uuid
      nullable: true
      description: |
        Specific shortcut to revoke.
        If provided, only this shortcut is removed.
        Mutually exclusive with revoke_by_service.

    revoke_by_service:
      type: string
      nullable: true
      description: |
        Revoke ALL shortcuts from this source service.
        Used when a service needs to clear all its shortcuts (e.g., on logout from that service).
        Mutually exclusive with route_guid.

    reason:
      type: string
      description: Optional reason for revocation (for logging/debugging).
```

### Client Capability Manifest Extension

The `ClientCapabilitiesResponse` is extended to include shortcuts:

```yaml
ClientCapabilitiesResponse:
  type: object
  properties:
    session_id:
      type: string

    capabilities:
      type: array
      items:
        $ref: '#/components/schemas/ClientCapability'
      description: Standard API capabilities (unchanged).

    shortcuts:
      type: array
      items:
        $ref: '#/components/schemas/ClientShortcut'
      description: |
        Session shortcuts - prebound API calls.
        Separate from capabilities for clear visibility.
        Clients invoke these with empty payloads.

    version:
      type: integer

    generated_at:
      type: string
      format: date-time

ClientShortcut:
  type: object
  required: [guid, target_service, target_endpoint, metadata]
  properties:
    guid:
      type: string
      format: uuid
      description: GUID to use in WebSocket message header.

    target_service:
      type: string
      description: The service this shortcut invokes (for client display).

    target_endpoint:
      type: string
      description: The endpoint this shortcut invokes (for client display).

    metadata:
      $ref: '#/components/schemas/SessionShortcutMetadata'
```

## GUID Generation

Session shortcut GUIDs use a distinct version to prevent collisions with service capability GUIDs.

### GuidGenerator Extension

```csharp
/// <summary>
/// Generates a client-salted GUID for a session shortcut.
/// Uses UUID version 7 bits to distinguish from service GUIDs (version 5).
/// </summary>
/// <param name="sessionId">Unique session identifier</param>
/// <param name="shortcutName">Shortcut name (e.g., "get_my_character_stats")</param>
/// <param name="sourceService">Service creating this shortcut</param>
/// <param name="serverSalt">Server-generated salt for security</param>
/// <returns>Deterministic, session-unique GUID for this shortcut</returns>
public static Guid GenerateSessionShortcutGuid(
    string sessionId,
    string shortcutName,
    string sourceService,
    string serverSalt)
{
    if (string.IsNullOrEmpty(sessionId))
        throw new ArgumentException("Session ID cannot be null or empty", nameof(sessionId));
    if (string.IsNullOrEmpty(shortcutName))
        throw new ArgumentException("Shortcut name cannot be null or empty", nameof(shortcutName));
    if (string.IsNullOrEmpty(sourceService))
        throw new ArgumentException("Source service cannot be null or empty", nameof(sourceService));
    if (string.IsNullOrEmpty(serverSalt))
        throw new ArgumentException("Server salt cannot be null or empty", nameof(serverSalt));

    // Distinct format prevents collision with service GUIDs
    var input = $"shortcut:{shortcutName}|session:{sessionId}|source:{sourceService}|salt:{serverSalt}";
    var hash = SHA256.HashData(Encoding.UTF8.GetBytes(input));

    var guidBytes = new byte[16];
    Array.Copy(hash, guidBytes, 16);

    // Version 7 for session shortcuts (service GUIDs use version 5)
    guidBytes[6] = (byte)((guidBytes[6] & 0x0F) | 0x70);
    guidBytes[8] = (byte)((guidBytes[8] & 0x3F) | 0x80); // Variant bits

    return new Guid(guidBytes);
}

/// <summary>
/// Validates that a GUID is a session shortcut GUID (version 7).
/// </summary>
public static bool IsSessionShortcutGuid(Guid guid)
{
    var bytes = guid.ToByteArray();
    var version = (bytes[7] >> 4) & 0x0F;  // Note: .NET GUID byte order
    return version == 7;
}
```

### GUID Version Summary

| Version | Usage | Generator Method |
|---------|-------|------------------|
| 5 | Service capability GUIDs | `GenerateServiceGuid()` |
| 6 | Client-to-client routing GUIDs | `GenerateClientGuid()` |
| 7 | Session shortcut GUIDs | `GenerateSessionShortcutGuid()` |

## Connect Service Implementation

### ConnectionState Extension

```csharp
public class ConnectionState
{
    // Existing fields...

    /// <summary>
    /// Session shortcuts indexed by route GUID.
    /// </summary>
    public Dictionary<Guid, SessionShortcutData> SessionShortcuts { get; }

    /// <summary>
    /// Index for bulk revocation by source service.
    /// </summary>
    public Dictionary<string, HashSet<Guid>> ShortcutsByService { get; }

    private readonly object _shortcutsLock = new object();

    /// <summary>
    /// Adds or updates a session shortcut (thread-safe).
    /// </summary>
    public void AddOrUpdateShortcut(SessionShortcutData shortcut)
    {
        lock (_shortcutsLock)
        {
            SessionShortcuts[shortcut.RouteGuid] = shortcut;

            if (!ShortcutsByService.TryGetValue(shortcut.SourceService, out var guids))
            {
                guids = new HashSet<Guid>();
                ShortcutsByService[shortcut.SourceService] = guids;
            }
            guids.Add(shortcut.RouteGuid);
        }
    }

    /// <summary>
    /// Removes a specific shortcut (thread-safe).
    /// </summary>
    public bool RemoveShortcut(Guid routeGuid)
    {
        lock (_shortcutsLock)
        {
            if (SessionShortcuts.TryGetValue(routeGuid, out var shortcut))
            {
                SessionShortcuts.Remove(routeGuid);
                if (ShortcutsByService.TryGetValue(shortcut.SourceService, out var guids))
                {
                    guids.Remove(routeGuid);
                    if (guids.Count == 0)
                        ShortcutsByService.Remove(shortcut.SourceService);
                }
                return true;
            }
            return false;
        }
    }

    /// <summary>
    /// Removes all shortcuts from a specific service (thread-safe).
    /// Returns the count of removed shortcuts.
    /// </summary>
    public int RemoveShortcutsByService(string sourceService)
    {
        lock (_shortcutsLock)
        {
            if (!ShortcutsByService.TryGetValue(sourceService, out var guids))
                return 0;

            var count = guids.Count;
            foreach (var guid in guids)
            {
                SessionShortcuts.Remove(guid);
            }
            ShortcutsByService.Remove(sourceService);
            return count;
        }
    }

    /// <summary>
    /// Tries to get a shortcut by route GUID (thread-safe).
    /// </summary>
    public bool TryGetShortcut(Guid routeGuid, out SessionShortcutData? shortcut)
    {
        lock (_shortcutsLock)
        {
            return SessionShortcuts.TryGetValue(routeGuid, out shortcut);
        }
    }

    /// <summary>
    /// Clears all shortcuts (used on disconnect/reconnect).
    /// </summary>
    public void ClearAllShortcuts()
    {
        lock (_shortcutsLock)
        {
            SessionShortcuts.Clear();
            ShortcutsByService.Clear();
        }
    }
}

/// <summary>
/// Internal representation of a session shortcut.
/// </summary>
public class SessionShortcutData
{
    public Guid RouteGuid { get; set; }
    public Guid TargetGuid { get; set; }
    public byte[] BoundPayload { get; set; } = Array.Empty<byte>();
    public string SourceService { get; set; } = "";
    public string Name { get; set; } = "";
    public string? Description { get; set; }
    public DateTimeOffset CreatedAt { get; set; }
    public DateTimeOffset? ExpiresAt { get; set; }
    public string[]? Tags { get; set; }
    public string? DisplayName { get; set; }
}
```

### MessageRouter Extension

```csharp
public static class MessageRouter
{
    /// <summary>
    /// Analyzes a message and determines routing, including session shortcuts.
    /// </summary>
    public static MessageRouteInfo AnalyzeMessage(
        BinaryMessage message,
        ConnectionState connectionState)
    {
        var routeInfo = new MessageRouteInfo
        {
            Message = message,
            IsValid = true
        };

        // Check for session shortcut FIRST
        if (connectionState.TryGetShortcut(message.ServiceGuid, out var shortcut) && shortcut != null)
        {
            // Validate shortcut hasn't expired
            if (shortcut.ExpiresAt.HasValue && shortcut.ExpiresAt.Value < DateTimeOffset.UtcNow)
            {
                connectionState.RemoveShortcut(message.ServiceGuid);
                routeInfo.IsValid = false;
                routeInfo.ErrorCode = ResponseCodes.ShortcutExpired;
                routeInfo.ErrorMessage = $"Session shortcut '{shortcut.Name}' has expired";
                return routeInfo;
            }

            routeInfo.RouteType = RouteType.SessionShortcut;
            routeInfo.TargetGuid = shortcut.TargetGuid;
            routeInfo.InjectedPayload = shortcut.BoundPayload;
            routeInfo.ShortcutName = shortcut.Name;

            // Look up actual service from target GUID
            if (connectionState.TryGetServiceName(shortcut.TargetGuid, out var serviceName) && serviceName != null)
            {
                routeInfo.TargetType = "service";
                routeInfo.TargetId = serviceName;
                routeInfo.ServiceName = serviceName;
            }
            else
            {
                // Target capability no longer valid
                routeInfo.IsValid = false;
                routeInfo.ErrorCode = ResponseCodes.ShortcutTargetNotFound;
                routeInfo.ErrorMessage = $"Shortcut target capability no longer available";
                return routeInfo;
            }

            routeInfo.Priority = message.IsHighPriority ? MessagePriority.High : MessagePriority.Normal;
            routeInfo.Channel = message.Channel;
            routeInfo.RequiresResponse = message.ExpectsResponse;

            return routeInfo;
        }

        // ... existing service GUID routing logic ...
    }
}

public enum RouteType
{
    Service,
    Client,
    SessionShortcut  // NEW
}

public class MessageRouteInfo
{
    // Existing fields...

    /// <summary>
    /// For SessionShortcut routes: the actual target GUID to forward to.
    /// </summary>
    public Guid? TargetGuid { get; set; }

    /// <summary>
    /// For SessionShortcut routes: the pre-bound payload to inject.
    /// </summary>
    public byte[]? InjectedPayload { get; set; }

    /// <summary>
    /// For SessionShortcut routes: the shortcut name (for logging).
    /// </summary>
    public string? ShortcutName { get; set; }
}
```

### Message Forwarding with Shortcut Injection

```csharp
// In ConnectService.HandleWebSocketMessageAsync or equivalent

var routeInfo = MessageRouter.AnalyzeMessage(message, connectionState);

if (!routeInfo.IsValid)
{
    await SendErrorResponse(routeInfo);
    return;
}

if (routeInfo.RouteType == RouteType.SessionShortcut)
{
    // Rewrite the message with target GUID and injected payload
    var rewrittenMessage = BinaryMessage.CreateWithInjectedPayload(
        flags: message.Flags,
        channel: message.Channel,
        sequenceNumber: message.SequenceNumber,
        serviceGuid: routeInfo.TargetGuid!.Value,  // Swap to target GUID
        messageId: message.MessageId,
        payload: routeInfo.InjectedPayload!        // Inject bound payload
    );

    _logger.LogDebug(
        "Shortcut '{ShortcutName}' invoked for session {SessionId}, forwarding to {Service}",
        routeInfo.ShortcutName,
        connectionState.SessionId,
        routeInfo.ServiceName);

    await ForwardToService(rewrittenMessage, routeInfo);
}
else
{
    // Normal routing
    await ForwardToService(message, routeInfo);
}
```

## Reconnection Flow

Session shortcuts are NOT persisted to Redis state store. On reconnection, they must be re-published by services.

### Disconnect

```
1. WebSocket disconnects (graceful or unexpected)
2. Connect initiates reconnection window (5 minutes default)
3. Connect clears ALL session shortcuts: connectionState.ClearAllShortcuts()
4. Connect publishes session.disconnected event
5. RabbitMQ subscription for CONNECT_SESSION_{sessionId} remains active
```

### Reconnect

```
1. Client reconnects with reconnection token
2. Connect validates token, restores session from Redis
3. Connect publishes session.reconnected event:

   SessionReconnectedEvent:
     event_id: "..."
     session_id: "session-123"
     account_id: "account-456"
     timestamp: "2025-12-16T..."
     roles: ["user", "player"]
     previous_disconnect_at: "2025-12-16T..."
     reconnection_context:
       # Any preserved context services might need
       active_character_id: "char-luna-001"  # If available
       realm: "omega"

4. Services receive session.reconnected event
5. Services re-publish their shortcuts to CONNECT_SESSION_{sessionId}
6. Connect receives shortcuts, rebuilds SessionShortcuts dictionary
7. Connect pushes capabilities_updated to client (includes new shortcuts)
```

### SessionReconnectedEvent Schema

```yaml
SessionReconnectedEvent:
  type: object
  required: [event_id, session_id, account_id, timestamp]
  properties:
    event_id:
      type: string
      format: uuid

    session_id:
      type: string

    account_id:
      type: string
      format: uuid

    timestamp:
      type: string
      format: date-time

    roles:
      type: array
      items:
        type: string
      description: User roles at time of reconnection.

    previous_disconnect_at:
      type: string
      format: date-time
      description: When the original disconnection occurred.

    reconnection_context:
      type: object
      additionalProperties: true
      description: |
        Session context preserved from before disconnect.
        Services can use this to determine which shortcuts to re-publish.
        Structure is service-dependent.
```

## Service Integration Guide

### Publishing Shortcuts

Services should publish shortcuts when session context is established:

```csharp
// In GameSessionService, when player possesses a character

public async Task OnCharacterPossessed(string sessionId, Character character)
{
    var serverSalt = _configuration.ServerSalt;

    // Generate shortcut for getting this character's stats
    var shortcut = new SessionShortcut
    {
        RouteGuid = GuidGenerator.GenerateSessionShortcutGuid(
            sessionId,
            "get_my_character_stats",
            "game-session",
            serverSalt),

        TargetGuid = GuidGenerator.GenerateServiceGuid(
            sessionId,
            "game-session/character/get-stats",  // The actual API endpoint
            serverSalt),

        BoundPayload = JsonSerializer.Serialize(new GetCharacterStatsRequest
        {
            CharacterId = character.Id
        }),

        Metadata = new SessionShortcutMetadata
        {
            Name = "get_my_character_stats",
            Description = $"Get {character.Name}'s current stats",
            SourceService = "game-session",
            CreatedAt = DateTimeOffset.UtcNow,
            DisplayName = $"My Character Stats ({character.Name})",
            Tags = new[] { "character", "stats" }
        }
    };

    await _daprClient.PublishEventAsync(
        "bannou-pubsub",
        $"CONNECT_SESSION_{sessionId}",
        new ShortcutPublishedEvent
        {
            EventId = Guid.NewGuid(),
            SessionId = sessionId,
            Shortcut = shortcut
        });
}
```

### Revoking Shortcuts

When context changes, revoke outdated shortcuts:

```csharp
// When player releases possession of a character

public async Task OnCharacterReleased(string sessionId, string characterId)
{
    // Revoke all shortcuts related to this character
    // Option 1: Revoke specific shortcut by GUID
    var shortcutGuid = GuidGenerator.GenerateSessionShortcutGuid(
        sessionId, "get_my_character_stats", "game-session", _serverSalt);

    await _daprClient.PublishEventAsync(
        "bannou-pubsub",
        $"CONNECT_SESSION_{sessionId}",
        new ShortcutRevokedEvent
        {
            EventId = Guid.NewGuid(),
            SessionId = sessionId,
            RouteGuid = shortcutGuid,
            Reason = "Character possession released"
        });
}

// When player logs out of game session entirely

public async Task OnGameSessionLogout(string sessionId)
{
    // Revoke ALL shortcuts from this service
    await _daprClient.PublishEventAsync(
        "bannou-pubsub",
        $"CONNECT_SESSION_{sessionId}",
        new ShortcutRevokedEvent
        {
            EventId = Guid.NewGuid(),
            SessionId = sessionId,
            RevokeByService = "game-session",
            Reason = "Game session ended"
        });
}
```

### Handling Reconnection

```csharp
// Subscribe to session.reconnected events

[Topic("bannou-pubsub", "session.reconnected")]
public async Task HandleSessionReconnected(SessionReconnectedEvent evt)
{
    // Check if this session has active game context
    var gameContext = await _stateStore.GetAsync<GameSessionContext>(
        $"game-context:{evt.SessionId}");

    if (gameContext == null)
        return;  // No game session for this user

    // Re-publish shortcuts based on preserved context
    if (gameContext.ActiveCharacterId != null)
    {
        var character = await _characterService.GetAsync(gameContext.ActiveCharacterId);
        await PublishCharacterShortcuts(evt.SessionId, character);
    }

    if (gameContext.ActiveQuestId != null)
    {
        var quest = await _questService.GetAsync(gameContext.ActiveQuestId);
        await PublishQuestShortcuts(evt.SessionId, quest);
    }
}
```

## Client Integration Guide

### Receiving Shortcuts

Shortcuts arrive in the same `capabilities_updated` WebSocket event as regular capabilities:

```typescript
interface CapabilitiesUpdatedEvent {
  sessionId: string;
  capabilities: ClientCapability[];
  shortcuts: ClientShortcut[];  // NEW
  version: number;
  generatedAt: string;
}

interface ClientShortcut {
  guid: string;
  targetService: string;
  targetEndpoint: string;
  metadata: {
    name: string;
    description?: string;
    displayName?: string;
    sourceService: string;
    createdAt: string;
    expiresAt?: string;
    tags?: string[];
  };
}
```

### Invoking Shortcuts

Shortcuts are invoked identically to regular capabilities - send a WebSocket message with the shortcut GUID and empty (or ignored) payload:

```typescript
class BannouClient {
  private shortcuts: Map<string, ClientShortcut> = new Map();

  onCapabilitiesUpdated(event: CapabilitiesUpdatedEvent) {
    // Store shortcuts for easy lookup
    this.shortcuts.clear();
    for (const shortcut of event.shortcuts) {
      this.shortcuts.set(shortcut.metadata.name, shortcut);
    }
  }

  async invokeShortcut(shortcutName: string): Promise<any> {
    const shortcut = this.shortcuts.get(shortcutName);
    if (!shortcut) {
      throw new Error(`Shortcut '${shortcutName}' not found`);
    }

    // Send message with shortcut GUID and empty payload
    const message = BinaryMessage.create({
      flags: MessageFlags.None,
      channel: 0,
      serviceGuid: shortcut.guid,
      payload: {}  // Empty - Connect injects the real payload
    });

    return this.sendAndAwaitResponse(message);
  }
}

// Usage
const stats = await client.invokeShortcut('get_my_character_stats');
console.log(`Health: ${stats.health}/${stats.maxHealth}`);
```

### Organizing Shortcuts

Clients can organize shortcuts by tags for UI presentation:

```typescript
function groupShortcutsByTag(shortcuts: ClientShortcut[]): Map<string, ClientShortcut[]> {
  const groups = new Map<string, ClientShortcut[]>();

  for (const shortcut of shortcuts) {
    const tags = shortcut.metadata.tags ?? ['general'];
    for (const tag of tags) {
      const group = groups.get(tag) ?? [];
      group.push(shortcut);
      groups.set(tag, group);
    }
  }

  return groups;
}

// Example UI rendering
const shortcutGroups = groupShortcutsByTag(capabilities.shortcuts);

// Character shortcuts
const characterShortcuts = shortcutGroups.get('character') ?? [];
for (const shortcut of characterShortcuts) {
  renderButton(shortcut.metadata.displayName ?? shortcut.metadata.name);
}
```

## Binding Guidelines

### DO Bind

- **Identity references**: character_id, account_id, realm_id, guild_id
- **Session context**: active_quest_id, selected_npc_id, current_area_id
- **Stable preferences**: preferred_language, display_settings_id

### DO NOT Bind

- **Live state**: position, health, inventory counts
- **Transient data**: timestamps, sequence numbers
- **Computed values**: calculated stats, derived properties

### Rationale

Shortcuts are convenience wrappers, not state snapshots. The target service should always return **current** data based on the bound identifiers.

**Example - Good:**
```json
// Bound payload
{"character_id": "char-luna-001"}

// Service returns CURRENT stats for Luna
// Position, health, etc. are live values from the service
```

**Example - Bad:**
```json
// Bound payload - DON'T DO THIS
{"character_id": "char-luna-001", "cached_health": 100, "cached_position": {"x": 50, "y": 100}}

// These values are stale immediately
```

## Security Considerations

### GUID Security

- Shortcut GUIDs are client-salted (session-specific) and cannot be reused across sessions
- Version 7 UUID bits distinguish shortcuts from service capabilities
- Server salt prevents GUID prediction or forgery

### Payload Security

- Services control bound payloads - clients cannot modify them
- Connect treats payloads as opaque bytes - no injection possible
- Target service validates payloads normally (same as direct API calls)

### Revocation Security

- Only the source service can revoke its shortcuts (via RabbitMQ topic)
- `revoke_by_service` validates against stored `source_service` metadata
- Expired shortcuts are automatically removed on access

## Performance Considerations

### Connect Overhead

- **Shortcut lookup**: O(1) dictionary access
- **Message rewriting**: Byte-level GUID swap + payload injection
- **Memory**: ~200 bytes per shortcut (GUID + metadata + payload reference)
- **Typical session**: 10-50 shortcuts = 2-10 KB overhead

### Scaling

- Shortcuts are session-scoped, not global
- RabbitMQ routing ensures only relevant Connect instance processes events
- No cross-instance synchronization required

### TTL Cleanup

- Expired shortcuts are lazily removed on access
- Optional: Background timer cleans up expired shortcuts every 60 seconds

## Monitoring & Debugging

### Logging

```
[INF] Shortcut 'get_my_character_stats' published for session session-123 by game-session
[DBG] Shortcut 'get_my_character_stats' invoked for session session-123, forwarding to game-session
[INF] Revoked 5 shortcuts from 'game-session' for session session-123 (reason: Game session ended)
[WRN] Shortcut 'accept_quest_offer' expired for session session-123
```

### Metrics

- `bannou_shortcuts_total{service, action}` - Counter: published, invoked, revoked, expired
- `bannou_shortcuts_active{service}` - Gauge: currently active shortcuts per service
- `bannou_shortcut_invoke_duration_seconds` - Histogram: time to process shortcut invocation

### Debugging Endpoints

```yaml
# Internal endpoint for debugging session shortcuts (admin only)
/internal/debug/session/{sessionId}/shortcuts:
  get:
    summary: List all shortcuts for a session
    responses:
      '200':
        content:
          application/json:
            schema:
              type: array
              items:
                $ref: '#/components/schemas/SessionShortcut'
```

## Future Considerations

The following features are explicitly **out of scope** for the initial implementation but may be considered in the future:

### Parameterized Shortcuts

Templates with runtime-resolved variables:
```yaml
template_payload: '{"character_id":"$ACTIVE_CHARACTER"}'
```
**Reason for deferral**: Requires Connect to understand session context structure and perform deserialization.

### Subscription Shortcuts

Shortcuts that initiate streaming data:
```yaml
type: "subscription"
target_topic: "character.{id}.position"
```
**Reason for deferral**: Significant Connect architecture changes required.

### Batch Shortcuts

Single shortcut invoking multiple parallel requests:
```yaml
type: "batch"
requests: [...]
```
**Reason for deferral**: Response aggregation complexity.

---

## Appendix: Response Codes

New response codes for shortcut-specific errors:

| Code | Name | Description |
|------|------|-------------|
| 480 | ShortcutExpired | Shortcut TTL has passed |
| 481 | ShortcutTargetNotFound | Target capability no longer in session |
| 482 | ShortcutRevoked | Shortcut was explicitly revoked |

---

## Revision History

| Date | Version | Changes |
|------|---------|---------|
| 2025-12-16 | 1.0.0 | Initial specification |
