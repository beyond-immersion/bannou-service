//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
//
//     WARNING: DO NOT EDIT THIS FILE (TENETS T1/T2)
//     This file is auto-generated from OpenAPI schemas in /schemas/.
//     Any manual changes will be overwritten on next generation.
//
//     To modify behavior:
//     1. Edit the source schema (schemas/*-api.yaml or schemas/*-events.yaml)
//     2. Run: scripts/generate-all-services.sh
//     3. Implement business logic in the service class (e.g., *Service.cs)
//
//     See: docs/reference/tenets/FOUNDATION.md (T1: Schema-First, T2: Code Generation)
// </auto-generated>
//----------------------

#nullable enable


namespace BeyondImmersion.BannouService.Mapping;

using System = global::System;

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
public interface IMappingController : BeyondImmersion.BannouService.Controllers.IBannouController
{

    /// <summary>
    /// Create a new map channel and become its authority
    /// </summary>

    /// <remarks>
    /// Creates a new region+kind channel and grants authority to caller.
    /// <br/>Returns ingestTopic for high-throughput event publishing.
    /// <br/>If channel already exists with active authority, returns Conflict.
    /// </remarks>

    /// <returns>Channel created, authority granted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthorityGrant>> CreateChannelAsync(CreateChannelRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Release authority over a channel
    /// </summary>

    /// <remarks>
    /// Voluntarily releases authority. Channel becomes unassigned.
    /// <br/>Only the current authority can release.
    /// </remarks>

    /// <returns>Authority released successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseAuthorityResponse>> ReleaseAuthorityAsync(ReleaseAuthorityRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Maintain authority over channel
    /// </summary>

    /// <remarks>
    /// Keep-alive for authority. Must be called periodically (default every 30s).
    /// <br/>Failure to heartbeat results in authority expiration.
    /// </remarks>

    /// <returns>Heartbeat acknowledged</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthorityHeartbeatResponse>> AuthorityHeartbeatAsync(AuthorityHeartbeatRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Publish map data update (RPC path)
    /// </summary>

    /// <remarks>
    /// Game servers use this to push authoritative spatial updates.
    /// <br/>Validates authority token, stores update, and broadcasts to consumers.
    /// <br/>For high-throughput scenarios, use event publishing via ingestTopic instead.
    /// </remarks>

    /// <returns>Update published successfully</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PublishMapUpdateResponse>> PublishMapUpdateAsync(PublishMapUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Publish metadata object changes (batch)
    /// </summary>

    /// <remarks>
    /// Game servers use this to push object state changes.
    /// <br/>Efficiently batches multiple object changes into one event.
    /// <br/>Max 100 changes per request.
    /// </remarks>

    /// <returns>Object changes published</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PublishObjectChangesResponse>> PublishObjectChangesAsync(PublishObjectChangesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Request full snapshot for cold start
    /// </summary>

    /// <remarks>
    /// Consumers use this when starting up to get initial state.
    /// <br/>Returns current snapshot of requested region/kinds.
    /// <br/>For very large maps, payloadRef points to lib-asset storage.
    /// </remarks>

    /// <returns>Snapshot returned</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RequestSnapshotResponse>> RequestSnapshotAsync(RequestSnapshotRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query map data at a specific point
    /// </summary>

    /// <remarks>
    /// Returns all map data at a point across requested kinds.
    /// <br/>Used by behavior stacks for contextual decisions.
    /// <br/>Optionally includes objects within radius.
    /// </remarks>

    /// <returns>Query results</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryPointResponse>> QueryPointAsync(QueryPointRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Query map data within bounds
    /// </summary>

    /// <remarks>
    /// Returns map data within a bounding box.
    /// <br/>For event actors needing region overview.
    /// <br/>Limited to maxObjects per kind.
    /// </remarks>

    /// <returns>Query results</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryBoundsResponse>> QueryBoundsAsync(QueryBoundsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Find all objects of a type in region
    /// </summary>

    /// <remarks>
    /// Returns all objects matching an objectType filter.
    /// <br/>For event actors asking "where are all the boulder clusters?"
    /// </remarks>

    /// <returns>Matching objects</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryObjectsByTypeResponse>> QueryObjectsByTypeAsync(QueryObjectsByTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Find locations that afford a specific action or scene type
    /// </summary>

    /// <remarks>
    /// Affordance queries answer "where can I do X?" by combining
    /// <br/>multiple map kinds and applying game-specific scoring logic.
    /// <br/>
    /// <br/>Used by Event Brain for procedural scene orchestration:
    /// <br/>- "Find ambush locations"
    /// <br/>- "Find dramatic reveal spots"
    /// <br/>- "Find sheltered rest areas"
    /// <br/>
    /// <br/>Well-known types have predefined scoring; use affordanceType=custom
    /// <br/>with customAffordance for novel scenarios.
    /// </remarks>

    /// <returns>Scored locations</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AffordanceQueryResponse>> QueryAffordanceAsync(AffordanceQueryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Acquire exclusive edit lock for design-time editing
    /// </summary>

    /// <remarks>
    /// For level editors and design tools only.
    /// <br/>Game servers do NOT use this - they use create-channel for implicit authority.
    /// <br/>Returns authority token for publishing edits.
    /// </remarks>

    /// <returns>Checkout successful</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthoringCheckoutResponse>> CheckoutForAuthoringAsync(AuthoringCheckoutRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Commit design-time changes
    /// </summary>

    /// <remarks>
    /// Commits pending changes and releases the checkout lock.
    /// <br/>Optionally includes a commit message for history.
    /// </remarks>

    /// <returns>Changes committed</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthoringCommitResponse>> CommitAuthoringAsync(AuthoringCommitRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Release authoring checkout without committing
    /// </summary>

    /// <remarks>
    /// Discards pending changes and releases the checkout lock.
    /// <br/>Use when abandoning edits.
    /// </remarks>

    /// <returns>Checkout released</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthoringReleaseResponse>> ReleaseAuthoringAsync(AuthoringReleaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Create a map definition template
    /// </summary>

    /// <remarks>
    /// Creates a new map definition (template) that describes the structure
    /// <br/>of a region. Definitions are templates that can be used to bootstrap
    /// <br/>channels with predefined layer configurations.
    /// </remarks>

    /// <returns>Definition created</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MapDefinition>> CreateDefinitionAsync(CreateDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Get a map definition by ID
    /// </summary>

    /// <remarks>
    /// Returns the full map definition including all layer configurations.
    /// </remarks>

    /// <returns>Definition found</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MapDefinition>> GetDefinitionAsync(GetDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// List map definitions with optional filters
    /// </summary>

    /// <remarks>
    /// Returns a paginated list of map definitions.
    /// </remarks>

    /// <returns>Definitions list</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListDefinitionsResponse>> ListDefinitionsAsync(ListDefinitionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Update a map definition
    /// </summary>

    /// <remarks>
    /// Updates an existing map definition. Cannot change the definition ID.
    /// <br/>Layer configurations can be modified.
    /// </remarks>

    /// <returns>Definition updated</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MapDefinition>> UpdateDefinitionAsync(UpdateDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

    /// <summary>
    /// Delete a map definition
    /// </summary>

    /// <remarks>
    /// Deletes a map definition. Cannot delete if active channels reference it.
    /// </remarks>

    /// <returns>Definition deleted</returns>

    System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteDefinitionResponse>> DeleteDefinitionAsync(DeleteDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

}

[System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]

public partial class MappingController : Microsoft.AspNetCore.Mvc.ControllerBase
{
    private IMappingService _implementation;

    public MappingController(IMappingService implementation)
    {
        _implementation = implementation;
    }

    /// <summary>
    /// Converts service tuple response to ActionResult format
    /// </summary>
    private Microsoft.AspNetCore.Mvc.ActionResult<T> ConvertToActionResult<T>(BeyondImmersion.BannouService.StatusCodes statusCode, T? result)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => Ok(result),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => BadRequest(result),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => Unauthorized(result),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => NotFound(result),
            BeyondImmersion.BannouService.StatusCodes.Conflict => Conflict(result),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Converts service tuple response to IActionResult format (for void-like responses)
    /// </summary>
    private Microsoft.AspNetCore.Mvc.IActionResult ConvertToActionResult(BeyondImmersion.BannouService.StatusCodes statusCode, object? result = null)
    {
        return statusCode switch
        {
            BeyondImmersion.BannouService.StatusCodes.OK => result != null ? Ok(result) : Ok(),
            BeyondImmersion.BannouService.StatusCodes.BadRequest => result != null ? BadRequest(result) : BadRequest(),
            BeyondImmersion.BannouService.StatusCodes.Unauthorized => result != null ? Unauthorized(result) : Unauthorized(),
            BeyondImmersion.BannouService.StatusCodes.Forbidden => Forbid(),
            BeyondImmersion.BannouService.StatusCodes.NotFound => result != null ? NotFound(result) : NotFound(),
            BeyondImmersion.BannouService.StatusCodes.Conflict => result != null ? Conflict(result) : Conflict(),
            BeyondImmersion.BannouService.StatusCodes.InternalServerError => StatusCode(500, result),
            _ => StatusCode(500, result)
        };
    }

    /// <summary>
    /// Create a new map channel and become its authority
    /// </summary>
    /// <remarks>
    /// Creates a new region+kind channel and grants authority to caller.
    /// <br/>Returns ingestTopic for high-throughput event publishing.
    /// <br/>If channel already exists with active authority, returns Conflict.
    /// </remarks>
    /// <returns>Channel created, authority granted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/create-channel")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthorityGrant>> CreateChannel([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateChannelRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateChannelAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Release authority over a channel
    /// </summary>
    /// <remarks>
    /// Voluntarily releases authority. Channel becomes unassigned.
    /// <br/>Only the current authority can release.
    /// </remarks>
    /// <returns>Authority released successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/release-authority")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ReleaseAuthorityResponse>> ReleaseAuthority([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ReleaseAuthorityRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ReleaseAuthorityAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Maintain authority over channel
    /// </summary>
    /// <remarks>
    /// Keep-alive for authority. Must be called periodically (default every 30s).
    /// <br/>Failure to heartbeat results in authority expiration.
    /// </remarks>
    /// <returns>Heartbeat acknowledged</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/authority-heartbeat")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthorityHeartbeatResponse>> AuthorityHeartbeat([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AuthorityHeartbeatRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.AuthorityHeartbeatAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Publish map data update (RPC path)
    /// </summary>
    /// <remarks>
    /// Game servers use this to push authoritative spatial updates.
    /// <br/>Validates authority token, stores update, and broadcasts to consumers.
    /// <br/>For high-throughput scenarios, use event publishing via ingestTopic instead.
    /// </remarks>
    /// <returns>Update published successfully</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/publish")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PublishMapUpdateResponse>> PublishMapUpdate([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PublishMapUpdateRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.PublishMapUpdateAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Publish metadata object changes (batch)
    /// </summary>
    /// <remarks>
    /// Game servers use this to push object state changes.
    /// <br/>Efficiently batches multiple object changes into one event.
    /// <br/>Max 100 changes per request.
    /// </remarks>
    /// <returns>Object changes published</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/publish-objects")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<PublishObjectChangesResponse>> PublishObjectChanges([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] PublishObjectChangesRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.PublishObjectChangesAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Request full snapshot for cold start
    /// </summary>
    /// <remarks>
    /// Consumers use this when starting up to get initial state.
    /// <br/>Returns current snapshot of requested region/kinds.
    /// <br/>For very large maps, payloadRef points to lib-asset storage.
    /// </remarks>
    /// <returns>Snapshot returned</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/request-snapshot")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<RequestSnapshotResponse>> RequestSnapshot([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] RequestSnapshotRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.RequestSnapshotAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Query map data at a specific point
    /// </summary>
    /// <remarks>
    /// Returns all map data at a point across requested kinds.
    /// <br/>Used by behavior stacks for contextual decisions.
    /// <br/>Optionally includes objects within radius.
    /// </remarks>
    /// <returns>Query results</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/query/point")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryPointResponse>> QueryPoint([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryPointRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryPointAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Query map data within bounds
    /// </summary>
    /// <remarks>
    /// Returns map data within a bounding box.
    /// <br/>For event actors needing region overview.
    /// <br/>Limited to maxObjects per kind.
    /// </remarks>
    /// <returns>Query results</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/query/bounds")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryBoundsResponse>> QueryBounds([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryBoundsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryBoundsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Find all objects of a type in region
    /// </summary>
    /// <remarks>
    /// Returns all objects matching an objectType filter.
    /// <br/>For event actors asking "where are all the boulder clusters?"
    /// </remarks>
    /// <returns>Matching objects</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/query/objects-by-type")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<QueryObjectsByTypeResponse>> QueryObjectsByType([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] QueryObjectsByTypeRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryObjectsByTypeAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Find locations that afford a specific action or scene type
    /// </summary>
    /// <remarks>
    /// Affordance queries answer "where can I do X?" by combining
    /// <br/>multiple map kinds and applying game-specific scoring logic.
    /// <br/>
    /// <br/>Used by Event Brain for procedural scene orchestration:
    /// <br/>- "Find ambush locations"
    /// <br/>- "Find dramatic reveal spots"
    /// <br/>- "Find sheltered rest areas"
    /// <br/>
    /// <br/>Well-known types have predefined scoring; use affordanceType=custom
    /// <br/>with customAffordance for novel scenarios.
    /// </remarks>
    /// <returns>Scored locations</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/query/affordance")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AffordanceQueryResponse>> QueryAffordance([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AffordanceQueryRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.QueryAffordanceAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Acquire exclusive edit lock for design-time editing
    /// </summary>
    /// <remarks>
    /// For level editors and design tools only.
    /// <br/>Game servers do NOT use this - they use create-channel for implicit authority.
    /// <br/>Returns authority token for publishing edits.
    /// </remarks>
    /// <returns>Checkout successful</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/checkout")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthoringCheckoutResponse>> CheckoutForAuthoring([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AuthoringCheckoutRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CheckoutForAuthoringAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Commit design-time changes
    /// </summary>
    /// <remarks>
    /// Commits pending changes and releases the checkout lock.
    /// <br/>Optionally includes a commit message for history.
    /// </remarks>
    /// <returns>Changes committed</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/commit")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthoringCommitResponse>> CommitAuthoring([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AuthoringCommitRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CommitAuthoringAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Release authoring checkout without committing
    /// </summary>
    /// <remarks>
    /// Discards pending changes and releases the checkout lock.
    /// <br/>Use when abandoning edits.
    /// </remarks>
    /// <returns>Checkout released</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/release")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<AuthoringReleaseResponse>> ReleaseAuthoring([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] AuthoringReleaseRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ReleaseAuthoringAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Create a map definition template
    /// </summary>
    /// <remarks>
    /// Creates a new map definition (template) that describes the structure
    /// <br/>of a region. Definitions are templates that can be used to bootstrap
    /// <br/>channels with predefined layer configurations.
    /// </remarks>
    /// <returns>Definition created</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/definition/create")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MapDefinition>> CreateDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] CreateDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.CreateDefinitionAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Get a map definition by ID
    /// </summary>
    /// <remarks>
    /// Returns the full map definition including all layer configurations.
    /// </remarks>
    /// <returns>Definition found</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/definition/get")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MapDefinition>> GetDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] GetDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.GetDefinitionAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// List map definitions with optional filters
    /// </summary>
    /// <remarks>
    /// Returns a paginated list of map definitions.
    /// </remarks>
    /// <returns>Definitions list</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/definition/list")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<ListDefinitionsResponse>> ListDefinitions([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] ListDefinitionsRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.ListDefinitionsAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Update a map definition
    /// </summary>
    /// <remarks>
    /// Updates an existing map definition. Cannot change the definition ID.
    /// <br/>Layer configurations can be modified.
    /// </remarks>
    /// <returns>Definition updated</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/definition/update")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<MapDefinition>> UpdateDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] UpdateDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.UpdateDefinitionAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }

    /// <summary>
    /// Delete a map definition
    /// </summary>
    /// <remarks>
    /// Deletes a map definition. Cannot delete if active channels reference it.
    /// </remarks>
    /// <returns>Definition deleted</returns>
    [Microsoft.AspNetCore.Mvc.HttpPost, Microsoft.AspNetCore.Mvc.Route("mapping/definition/delete")]

    public async System.Threading.Tasks.Task<Microsoft.AspNetCore.Mvc.ActionResult<DeleteDefinitionResponse>> DeleteDefinition([Microsoft.AspNetCore.Mvc.FromBody] [Microsoft.AspNetCore.Mvc.ModelBinding.BindRequired] DeleteDefinitionRequest body, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
    {

        var (statusCode, result) = await _implementation.DeleteDefinitionAsync(body, cancellationToken);
        return ConvertToActionResult(statusCode, result);
    }



    #region Meta Endpoints for CreateChannel

    private static readonly string _CreateChannel_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateChannelRequest",
    "$defs": {
        "CreateChannelRequest": {
            "type": "object",
            "description": "Request to create a new map channel",
            "required": [
                "regionId",
                "kind",
                "sourceAppId"
            ],
            "properties": {
                "sourceAppId": {
                    "type": "string",
                    "description": "App-id of the caller taking authority (used for event metadata)"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region for this channel"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind for this channel"
                },
                "nonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "How to handle non-authority publishes"
                },
                "takeoverMode": {
                    "$ref": "#/$defs/AuthorityTakeoverMode",
                    "description": "Policy for authority takeover when channel exists with expired authority.\npreserve_and_diff (default): Keep existing data, new authority sends updates.\nreset: Clear all channel data before new authority takes over.\nrequire_consume: New authority must call RequestSnapshot before publishing.\n"
                },
                "alertConfig": {
                    "$ref": "#/$defs/NonAuthorityAlertConfig",
                    "description": "Configuration for non-authority publish alerts",
                    "nullable": true
                },
                "initialSnapshot": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapPayload"
                    },
                    "description": "Optional initial data to populate channel",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "AuthorityTakeoverMode": {
            "type": "string",
            "description": "Policy for handling authority takeover when creating a channel that\nalready has expired authority. Controls what happens to existing data.\n",
            "enum": [
                "preserve_and_diff",
                "reset",
                "require_consume"
            ],
            "default": "preserve_and_diff"
        },
        "NonAuthorityAlertConfig": {
            "type": "object",
            "description": "Configuration for non-authority publish alerts",
            "properties": {
                "enabled": {
                    "type": "boolean",
                    "default": true,
                    "description": "Whether to emit warning events"
                },
                "alertTopic": {
                    "type": "string",
                    "description": "Custom topic for warnings (default map.warnings.unauthorized_publish)",
                    "nullable": true
                },
                "includePayloadSummary": {
                    "type": "boolean",
                    "default": false,
                    "description": "Include truncated payload in warning for debugging"
                }
            }
        },
        "MapPayload": {
            "type": "object",
            "description": "Schema-less payload. Only envelope fields are validated.\nThe 'data' field can contain ANYTHING the publisher wants.\nlib-mapping does not validate contents - only publisher and consumer care.\n",
            "required": [
                "objectType"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique ID for this object (generated if not provided)"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type (used for indexing and filtering)"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounds for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "SCHEMA-LESS. Can contain anything.\nlib-mapping does not validate this.\nExamples: cover_rating, health, respawn_delay, etc.\n",
                    "nullable": true
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateChannel_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthorityGrant",
    "$defs": {
        "AuthorityGrant": {
            "type": "object",
            "description": "Granted authority over a map channel",
            "required": [
                "channelId",
                "authorityToken",
                "ingestTopic",
                "expiresAt",
                "regionId",
                "kind"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "The channel (region+kind) you have authority over"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Opaque token proving your authority (include in publishes)"
                },
                "ingestTopic": {
                    "type": "string",
                    "description": "Topic for direct lib-messaging publishes (map.ingest.{channelId})"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When authority expires (must heartbeat to extend)"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region ID for this channel"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind for this channel"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _CreateChannel_Info = """
{
    "summary": "Create a new map channel and become its authority",
    "description": "Creates a new region+kind channel and grants authority to caller.\nReturns ingestTopic for high-throughput event publishing.\nIf channel already exists with active authority, returns Conflict.\n",
    "tags": [
        "Authority"
    ],
    "deprecated": false,
    "operationId": "createChannel"
}
""";

    /// <summary>Returns endpoint information for CreateChannel</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/create-channel/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateChannel_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/create-channel",
            _CreateChannel_Info));

    /// <summary>Returns request schema for CreateChannel</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/create-channel/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateChannel_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/create-channel",
            "request-schema",
            _CreateChannel_RequestSchema));

    /// <summary>Returns response schema for CreateChannel</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/create-channel/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateChannel_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/create-channel",
            "response-schema",
            _CreateChannel_ResponseSchema));

    /// <summary>Returns full schema for CreateChannel</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/create-channel/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateChannel_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/create-channel",
            _CreateChannel_Info,
            _CreateChannel_RequestSchema,
            _CreateChannel_ResponseSchema));

    #endregion

    #region Meta Endpoints for ReleaseAuthority

    private static readonly string _ReleaseAuthority_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ReleaseAuthorityRequest",
    "$defs": {
        "ReleaseAuthorityRequest": {
            "type": "object",
            "description": "Request to release authority over a channel",
            "required": [
                "channelId",
                "authorityToken"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Channel to release"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Current authority token"
                }
            }
        }
    }
}
""";

    private static readonly string _ReleaseAuthority_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ReleaseAuthorityResponse",
    "$defs": {
        "ReleaseAuthorityResponse": {
            "type": "object",
            "description": "Response to authority release",
            "properties": {
                "released": {
                    "type": "boolean",
                    "description": "Whether authority was successfully released"
                }
            }
        }
    }
}
""";

    private static readonly string _ReleaseAuthority_Info = """
{
    "summary": "Release authority over a channel",
    "description": "Voluntarily releases authority. Channel becomes unassigned.\nOnly the current authority can release.\n",
    "tags": [
        "Authority"
    ],
    "deprecated": false,
    "operationId": "releaseAuthority"
}
""";

    /// <summary>Returns endpoint information for ReleaseAuthority</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/release-authority/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthority_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/release-authority",
            _ReleaseAuthority_Info));

    /// <summary>Returns request schema for ReleaseAuthority</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/release-authority/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthority_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/release-authority",
            "request-schema",
            _ReleaseAuthority_RequestSchema));

    /// <summary>Returns response schema for ReleaseAuthority</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/release-authority/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthority_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/release-authority",
            "response-schema",
            _ReleaseAuthority_ResponseSchema));

    /// <summary>Returns full schema for ReleaseAuthority</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/release-authority/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthority_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/release-authority",
            _ReleaseAuthority_Info,
            _ReleaseAuthority_RequestSchema,
            _ReleaseAuthority_ResponseSchema));

    #endregion

    #region Meta Endpoints for AuthorityHeartbeat

    private static readonly string _AuthorityHeartbeat_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthorityHeartbeatRequest",
    "$defs": {
        "AuthorityHeartbeatRequest": {
            "type": "object",
            "description": "Request to maintain authority",
            "required": [
                "channelId",
                "authorityToken"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Channel to heartbeat"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Current authority token"
                }
            }
        }
    }
}
""";

    private static readonly string _AuthorityHeartbeat_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthorityHeartbeatResponse",
    "$defs": {
        "AuthorityHeartbeatResponse": {
            "type": "object",
            "description": "Response to authority heartbeat",
            "properties": {
                "valid": {
                    "type": "boolean",
                    "description": "Whether your authority is still valid"
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "Updated expiration time"
                },
                "warning": {
                    "type": "string",
                    "description": "Optional warning (e.g., \"authority expiring soon\")",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _AuthorityHeartbeat_Info = """
{
    "summary": "Maintain authority over channel",
    "description": "Keep-alive for authority. Must be called periodically (default every 30s).\nFailure to heartbeat results in authority expiration.\n",
    "tags": [
        "Authority"
    ],
    "deprecated": false,
    "operationId": "authorityHeartbeat"
}
""";

    /// <summary>Returns endpoint information for AuthorityHeartbeat</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authority-heartbeat/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AuthorityHeartbeat_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/authority-heartbeat",
            _AuthorityHeartbeat_Info));

    /// <summary>Returns request schema for AuthorityHeartbeat</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authority-heartbeat/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AuthorityHeartbeat_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authority-heartbeat",
            "request-schema",
            _AuthorityHeartbeat_RequestSchema));

    /// <summary>Returns response schema for AuthorityHeartbeat</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authority-heartbeat/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AuthorityHeartbeat_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authority-heartbeat",
            "response-schema",
            _AuthorityHeartbeat_ResponseSchema));

    /// <summary>Returns full schema for AuthorityHeartbeat</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authority-heartbeat/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> AuthorityHeartbeat_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authority-heartbeat",
            _AuthorityHeartbeat_Info,
            _AuthorityHeartbeat_RequestSchema,
            _AuthorityHeartbeat_ResponseSchema));

    #endregion

    #region Meta Endpoints for PublishMapUpdate

    private static readonly string _PublishMapUpdate_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PublishMapUpdateRequest",
    "$defs": {
        "PublishMapUpdateRequest": {
            "type": "object",
            "description": "Request to publish map data update",
            "required": [
                "channelId",
                "authorityToken",
                "payload"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Channel to publish to"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Authority token for validation"
                },
                "sourceAppId": {
                    "type": "string",
                    "description": "App-id of caller (for warnings on non-authority attempts)",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Affected area (null means entire region)",
                    "nullable": true
                },
                "deltaType": {
                    "$ref": "#/$defs/DeltaType",
                    "description": "Whether this is incremental or full"
                },
                "payload": {
                    "$ref": "#/$defs/MapPayload",
                    "description": "The payload to publish"
                },
                "payloadAssetRef": {
                    "type": "string",
                    "description": "For large payloads, lib-asset reference instead of inline",
                    "nullable": true
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "DeltaType": {
            "type": "string",
            "description": "Whether an update is incremental or a full snapshot",
            "enum": [
                "delta",
                "snapshot"
            ],
            "default": "delta"
        },
        "MapPayload": {
            "type": "object",
            "description": "Schema-less payload. Only envelope fields are validated.\nThe 'data' field can contain ANYTHING the publisher wants.\nlib-mapping does not validate contents - only publisher and consumer care.\n",
            "required": [
                "objectType"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique ID for this object (generated if not provided)"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type (used for indexing and filtering)"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounds for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "SCHEMA-LESS. Can contain anything.\nlib-mapping does not validate this.\nExamples: cover_rating, health, respawn_delay, etc.\n",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _PublishMapUpdate_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PublishMapUpdateResponse",
    "$defs": {
        "PublishMapUpdateResponse": {
            "type": "object",
            "description": "Response to publish request",
            "properties": {
                "accepted": {
                    "type": "boolean",
                    "description": "Whether the update was accepted"
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Assigned version number"
                },
                "warning": {
                    "type": "string",
                    "description": "Optional warning message",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _PublishMapUpdate_Info = """
{
    "summary": "Publish map data update (RPC path)",
    "description": "Game servers use this to push authoritative spatial updates.\nValidates authority token, stores update, and broadcasts to consumers.\ nFor high-throughput scenarios, use event publishing via ingestTopic instead.\n",
    "tags": [
        "Runtime"
    ],
    "deprecated": false,
    "operationId": "publishMapUpdate"
}
""";

    /// <summary>Returns endpoint information for PublishMapUpdate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/publish/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishMapUpdate_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/publish",
            _PublishMapUpdate_Info));

    /// <summary>Returns request schema for PublishMapUpdate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/publish/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishMapUpdate_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/publish",
            "request-schema",
            _PublishMapUpdate_RequestSchema));

    /// <summary>Returns response schema for PublishMapUpdate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/publish/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishMapUpdate_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/publish",
            "response-schema",
            _PublishMapUpdate_ResponseSchema));

    /// <summary>Returns full schema for PublishMapUpdate</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/publish/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishMapUpdate_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/publish",
            _PublishMapUpdate_Info,
            _PublishMapUpdate_RequestSchema,
            _PublishMapUpdate_ResponseSchema));

    #endregion

    #region Meta Endpoints for PublishObjectChanges

    private static readonly string _PublishObjectChanges_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PublishObjectChangesRequest",
    "$defs": {
        "PublishObjectChangesRequest": {
            "type": "object",
            "description": "Request to publish object changes (batch)",
            "required": [
                "channelId",
                "authorityToken",
                "changes"
            ],
            "properties": {
                "channelId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Channel to publish to"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Authority token for validation"
                },
                "sourceAppId": {
                    "type": "string",
                    "description": "App-id of caller (for warnings on non-authority attempts)",
                    "nullable": true
                },
                "changes": {
                    "type": "array",
                    "maxItems": 100,
                    "items": {
                        "$ref": "#/$defs/ObjectChange"
                    },
                    "description": "Object changes to publish"
                }
            }
        },
        "ObjectChange": {
            "type": "object",
            "description": "A single change to a map object",
            "required": [
                "objectId",
                "action"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "ID of the object being changed"
                },
                "action": {
                    "$ref": "#/$defs/ObjectAction",
                    "description": "Type of change"
                },
                "objectType": {
                    "type": "string",
                    "description": "Object type (required for created)",
                    "nullable": true
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Object position (for create/update)",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Object bounds (for create/update)",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Object state (for created/updated)",
                    "nullable": true
                }
            }
        },
        "ObjectAction": {
            "type": "string",
            "description": "Type of change to a map object",
            "enum": [
                "created",
                "updated",
                "deleted"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _PublishObjectChanges_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/PublishObjectChangesResponse",
    "$defs": {
        "PublishObjectChangesResponse": {
            "type": "object",
            "description": "Response to object changes publish",
            "properties": {
                "accepted": {
                    "type": "boolean",
                    "description": "Whether the changes were accepted"
                },
                "acceptedCount": {
                    "type": "integer",
                    "description": "Number of changes accepted"
                },
                "rejectedCount": {
                    "type": "integer",
                    "description": "Number of changes rejected"
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Assigned version number"
                }
            }
        }
    }
}
""";

    private static readonly string _PublishObjectChanges_Info = """
{
    "summary": "Publish metadata object changes (batch)",
    "description": "Game servers use this to push object state changes.\nEfficiently batches multiple object changes into one event.\nMax 100 changes per request.\n",
    "tags": [
        "Runtime"
    ],
    "deprecated": false,
    "operationId": "publishObjectChanges"
}
""";

    /// <summary>Returns endpoint information for PublishObjectChanges</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/publish-objects/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishObjectChanges_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/publish-objects",
            _PublishObjectChanges_Info));

    /// <summary>Returns request schema for PublishObjectChanges</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/publish-objects/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishObjectChanges_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/publish-objects",
            "request-schema",
            _PublishObjectChanges_RequestSchema));

    /// <summary>Returns response schema for PublishObjectChanges</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/publish-objects/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishObjectChanges_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/publish-objects",
            "response-schema",
            _PublishObjectChanges_ResponseSchema));

    /// <summary>Returns full schema for PublishObjectChanges</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/publish-objects/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> PublishObjectChanges_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/publish-objects",
            _PublishObjectChanges_Info,
            _PublishObjectChanges_RequestSchema,
            _PublishObjectChanges_ResponseSchema));

    #endregion

    #region Meta Endpoints for RequestSnapshot

    private static readonly string _RequestSnapshot_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RequestSnapshotRequest",
    "$defs": {
        "RequestSnapshotRequest": {
            "type": "object",
            "description": "Request for full snapshot",
            "required": [
                "regionId"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to snapshot"
                },
                "kinds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapKind"
                    },
                    "description": "Which kinds to include (default all)",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Optional bounds filter",
                    "nullable": true
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Optional authority token. If provided and valid, clears the\nRequiresConsumeBeforePublish flag for require_consume takeover mode.\n",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestSnapshot_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/RequestSnapshotResponse",
    "$defs": {
        "RequestSnapshotResponse": {
            "type": "object",
            "description": "Snapshot response",
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region ID"
                },
                "objects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapObject"
                    },
                    "description": "All objects in snapshot"
                },
                "payloadRef": {
                    "type": "string",
                    "description": "For large snapshots, lib-asset reference",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Snapshot version"
                }
            }
        },
        "MapObject": {
            "type": "object",
            "description": "A stored map object with full metadata",
            "required": [
                "objectId",
                "regionId",
                "kind",
                "objectType",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this object"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region this object belongs to"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind this object is stored under"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Schema-less object data (publisher-defined)",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Monotonic version for ordering"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was last updated"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _RequestSnapshot_Info = """
{
    "summary": "Request full snapshot for cold start",
    "description": "Consumers use this when starting up to get initial state.\nReturns current snapshot of requested region/kinds.\nFor very large maps, payloadRef points to lib-asset storage.\n",
    "tags": [
        "Runtime"
    ],
    "deprecated": false,
    "operationId": "requestSnapshot"
}
""";

    /// <summary>Returns endpoint information for RequestSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/request-snapshot/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestSnapshot_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/request-snapshot",
            _RequestSnapshot_Info));

    /// <summary>Returns request schema for RequestSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/request-snapshot/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestSnapshot_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/request-snapshot",
            "request-schema",
            _RequestSnapshot_RequestSchema));

    /// <summary>Returns response schema for RequestSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/request-snapshot/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestSnapshot_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/request-snapshot",
            "response-schema",
            _RequestSnapshot_ResponseSchema));

    /// <summary>Returns full schema for RequestSnapshot</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/request-snapshot/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> RequestSnapshot_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/request-snapshot",
            _RequestSnapshot_Info,
            _RequestSnapshot_RequestSchema,
            _RequestSnapshot_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryPoint

    private static readonly string _QueryPoint_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryPointRequest",
    "$defs": {
        "QueryPointRequest": {
            "type": "object",
            "description": "Query map data at a point",
            "required": [
                "regionId",
                "position"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to query"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Point to query at"
                },
                "kinds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapKind"
                    },
                    "description": "Kinds to query (default all)",
                    "nullable": true
                },
                "radius": {
                    "type": "number",
                    "description": "Include objects within this radius",
                    "nullable": true
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _QueryPoint_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryPointResponse",
    "$defs": {
        "QueryPointResponse": {
            "type": "object",
            "description": "Point query results",
            "properties": {
                "objects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapObject"
                    },
                    "description": "Objects at/near the point"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Queried position"
                },
                "radius": {
                    "type": "number",
                    "description": "Applied radius filter",
                    "nullable": true
                }
            }
        },
        "MapObject": {
            "type": "object",
            "description": "A stored map object with full metadata",
            "required": [
                "objectId",
                "regionId",
                "kind",
                "objectType",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this object"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region this object belongs to"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind this object is stored under"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Schema-less object data (publisher-defined)",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Monotonic version for ordering"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was last updated"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryPoint_Info = """
{
    "summary": "Query map data at a specific point",
    "description": "Returns all map data at a point across requested kinds.\nUsed by behavior stacks for contextual decisions.\nOptionally includes objects within radius.\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "queryPoint"
}
""";

    /// <summary>Returns endpoint information for QueryPoint</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/point/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryPoint_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/query/point",
            _QueryPoint_Info));

    /// <summary>Returns request schema for QueryPoint</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/point/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryPoint_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/point",
            "request-schema",
            _QueryPoint_RequestSchema));

    /// <summary>Returns response schema for QueryPoint</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/point/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryPoint_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/point",
            "response-schema",
            _QueryPoint_ResponseSchema));

    /// <summary>Returns full schema for QueryPoint</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/point/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryPoint_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/point",
            _QueryPoint_Info,
            _QueryPoint_RequestSchema,
            _QueryPoint_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryBounds

    private static readonly string _QueryBounds_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBoundsRequest",
    "$defs": {
        "QueryBoundsRequest": {
            "type": "object",
            "description": "Query map data within bounds",
            "required": [
                "regionId",
                "bounds"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to query"
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box to query"
                },
                "kinds": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapKind"
                    },
                    "description": "Kinds to query (default all)",
                    "nullable": true
                },
                "maxObjects": {
                    "type": "integer",
                    "default": 500,
                    "maximum": 5000,
                    "description": "Maximum objects to return"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _QueryBounds_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryBoundsResponse",
    "$defs": {
        "QueryBoundsResponse": {
            "type": "object",
            "description": "Bounds query results",
            "properties": {
                "objects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapObject"
                    },
                    "description": "Objects within bounds"
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Queried bounds"
                },
                "truncated": {
                    "type": "boolean",
                    "description": "Whether results were truncated"
                }
            }
        },
        "MapObject": {
            "type": "object",
            "description": "A stored map object with full metadata",
            "required": [
                "objectId",
                "regionId",
                "kind",
                "objectType",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this object"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region this object belongs to"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind this object is stored under"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Schema-less object data (publisher-defined)",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Monotonic version for ordering"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was last updated"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryBounds_Info = """
{
    "summary": "Query map data within bounds",
    "description": "Returns map data within a bounding box.\nFor event actors needing region overview.\nLimited to maxObjects per kind.\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "queryBounds"
}
""";

    /// <summary>Returns endpoint information for QueryBounds</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/bounds/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBounds_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/query/bounds",
            _QueryBounds_Info));

    /// <summary>Returns request schema for QueryBounds</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/bounds/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBounds_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/bounds",
            "request-schema",
            _QueryBounds_RequestSchema));

    /// <summary>Returns response schema for QueryBounds</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/bounds/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBounds_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/bounds",
            "response-schema",
            _QueryBounds_ResponseSchema));

    /// <summary>Returns full schema for QueryBounds</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/bounds/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryBounds_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/bounds",
            _QueryBounds_Info,
            _QueryBounds_RequestSchema,
            _QueryBounds_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryObjectsByType

    private static readonly string _QueryObjectsByType_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryObjectsByTypeRequest",
    "$defs": {
        "QueryObjectsByTypeRequest": {
            "type": "object",
            "description": "Query objects by type",
            "required": [
                "regionId",
                "objectType"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to query"
                },
                "objectType": {
                    "type": "string",
                    "description": "Object type to filter by"
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Optional bounds filter",
                    "nullable": true
                },
                "maxObjects": {
                    "type": "integer",
                    "default": 500,
                    "maximum": 5000,
                    "description": "Maximum objects to return"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryObjectsByType_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/QueryObjectsByTypeResponse",
    "$defs": {
        "QueryObjectsByTypeResponse": {
            "type": "object",
            "description": "Object type query results",
            "properties": {
                "objects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapObject"
                    },
                    "description": "Matching objects"
                },
                "objectType": {
                    "type": "string",
                    "description": "Queried object type"
                },
                "truncated": {
                    "type": "boolean",
                    "description": "Whether results were truncated"
                }
            }
        },
        "MapObject": {
            "type": "object",
            "description": "A stored map object with full metadata",
            "required": [
                "objectId",
                "regionId",
                "kind",
                "objectType",
                "createdAt",
                "updatedAt"
            ],
            "properties": {
                "objectId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this object"
                },
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region this object belongs to"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind this object is stored under"
                },
                "objectType": {
                    "type": "string",
                    "description": "Publisher-defined type"
                },
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Position for point objects",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Bounding box for area objects",
                    "nullable": true
                },
                "data": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Schema-less object data (publisher-defined)",
                    "nullable": true
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Monotonic version for ordering"
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was first created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the object was last updated"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryObjectsByType_Info = """
{
    "summary": "Find all objects of a type in region",
    "description": "Returns all objects matching an objectType filter.\nFor event actors asking \"where are all the boulder clusters?\"\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "queryObjectsByType"
}
""";

    /// <summary>Returns endpoint information for QueryObjectsByType</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/objects-by-type/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryObjectsByType_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/query/objects-by-type",
            _QueryObjectsByType_Info));

    /// <summary>Returns request schema for QueryObjectsByType</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/objects-by-type/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryObjectsByType_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/objects-by-type",
            "request-schema",
            _QueryObjectsByType_RequestSchema));

    /// <summary>Returns response schema for QueryObjectsByType</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/objects-by-type/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryObjectsByType_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/objects-by-type",
            "response-schema",
            _QueryObjectsByType_ResponseSchema));

    /// <summary>Returns full schema for QueryObjectsByType</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/objects-by-type/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryObjectsByType_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/objects-by-type",
            _QueryObjectsByType_Info,
            _QueryObjectsByType_RequestSchema,
            _QueryObjectsByType_ResponseSchema));

    #endregion

    #region Meta Endpoints for QueryAffordance

    private static readonly string _QueryAffordance_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AffordanceQueryRequest",
    "$defs": {
        "AffordanceQueryRequest": {
            "type": "object",
            "description": "Query for locations that afford a specific action",
            "required": [
                "regionId",
                "affordanceType"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to search"
                },
                "affordanceType": {
                    "$ref": "#/$defs/AffordanceType",
                    "description": "Type of affordance to search for"
                },
                "customAffordance": {
                    "$ref": "#/$defs/CustomAffordance",
                    "description": "Custom affordance definition (when affordanceType=custom)",
                    "nullable": true
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Optional bounds to search within",
                    "nullable": true
                },
                "maxResults": {
                    "type": "integer",
                    "default": 10,
                    "maximum": 100,
                    "description": "Maximum locations to return"
                },
                "minScore": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.5,
                    "description": "Minimum affordance score to include"
                },
                "participantCount": {
                    "type": "integer",
                    "description": "Expected participants (affects space requirements)",
                    "nullable": true
                },
                "excludePositions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/Position3D"
                    },
                    "description": "Positions to exclude (e.g., player's current location)",
                    "nullable": true
                },
                "actorCapabilities": {
                    "$ref": "#/$defs/ActorCapabilities",
                    "description": "Actor capabilities affecting evaluation",
                    "nullable": true
                },
                "freshness": {
                    "$ref": "#/$defs/AffordanceFreshness",
                    "description": "Cache freshness level"
                },
                "maxAgeSeconds": {
                    "type": "integer",
                    "minimum": 0,
                    "maximum": 3600,
                    "description": "Max age of cached results (for cached/aggressive_cache)",
                    "nullable": true
                }
            }
        },
        "AffordanceType": {
            "type": "string",
            "description": "Well-known affordance types with predefined scoring logic.\nUse 'custom' for novel affordance definitions.\n",
            "enum": [
                "ambush",
                "shelter",
                "vista",
                "choke_point",
                "gathering_spot",
                "dramatic_reveal",
                "hidden_path",
                "defensible_position",
                "custom"
            ]
        },
        "CustomAffordance": {
            "type": "object",
            "description": "Custom affordance definition for novel scenarios",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Human-readable description of this affordance",
                    "nullable": true
                },
                "requires": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Required criteria. Object types, property constraints.\nExample: { \"objectTypes\": [\"boulder\"], \"cover_rating\": { \"min\": 0.5 } }\n",
                    "nullable": true
                },
                "prefers": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Preferred criteria (boost score but not required).\nExample: { \"elevation\": { \"prefer_higher\": true } }\n",
                    "nullable": true
                },
                "excludes": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Exclusion criteria. Reject candidates matching these.\nExample: { \"hazards\": true, \"contested\": true }\n",
                    "nullable": true
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "ActorCapabilities": {
            "type": "object",
            "description": "Actor-specific capabilities that affect affordance evaluation.\nSame location may afford different actions to different actor types.\n",
            "properties": {
                "size": {
                    "$ref": "#/$defs/ActorSize",
                    "description": "Affects cover requirements and passage width"
                },
                "height": {
                    "type": "number",
                    "description": "Actor height in meters (affects cover, sightlines)",
                    "nullable": true
                },
                "canClimb": {
                    "type": "boolean",
                    "default": false,
                    "description": "Can reach elevated positions"
                },
                "canSwim": {
                    "type": "boolean",
                    "default": false,
                    "description": "Includes water-based positions"
                },
                "canFly": {
                    "type": "boolean",
                    "default": false,
                    "description": "Includes aerial positions"
                },
                "perceptionRange": {
                    "type": "number",
                    "description": "Affects sightline distance requirements",
                    "nullable": true
                },
                "movementSpeed": {
                    "type": "number",
                    "description": "Affects escape route viability calculations",
                    "nullable": true
                },
                "stealthRating": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "Affects ambush/hidden_path affordance scoring",
                    "nullable": true
                }
            }
        },
        "ActorSize": {
            "type": "string",
            "description": "Size classification affecting cover requirements and passage width",
            "enum": [
                "tiny",
                "small",
                "medium",
                "large",
                "huge"
            ],
            "default": "medium"
        },
        "AffordanceFreshness": {
            "type": "string",
            "description": "Controls caching behavior for affordance queries",
            "enum": [
                "fresh",
                "cached",
                "aggressive_cache"
            ],
            "default": "cached"
        }
    }
}
""";

    private static readonly string _QueryAffordance_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AffordanceQueryResponse",
    "$defs": {
        "AffordanceQueryResponse": {
            "type": "object",
            "description": "Affordance query results",
            "properties": {
                "locations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/AffordanceLocation"
                    },
                    "description": "Scored locations (highest score first)"
                },
                "queryMetadata": {
                    "$ref": "#/$defs/AffordanceQueryMetadata",
                    "description": "Metadata about query execution (optional)",
                    "nullable": true
                }
            }
        },
        "AffordanceLocation": {
            "type": "object",
            "description": "A location that affords the requested action",
            "properties": {
                "position": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Location position"
                },
                "bounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Area bounds if affordance spans an area",
                    "nullable": true
                },
                "score": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "description": "How well this location affords the action (0-1)"
                },
                "features": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "What makes this location suitable.\nExample: { \"cover_rating\": 0.8, \"sightlines\": [\"north\"], \"terrain\": \"rocky\" }\n",
                    "nullable": true
                },
                "objectIds": {
                    "type": "array",
                    "items": {
                        "type": "string",
                        "format": "uuid"
                    },
                    "description": "Map objects contributing to this affordance",
                    "nullable": true
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "AffordanceQueryMetadata": {
            "type": "object",
            "description": "Metadata about the affordance query execution",
            "properties": {
                "kindsSearched": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Map kinds that were queried",
                    "nullable": true
                },
                "objectsEvaluated": {
                    "type": "integer",
                    "description": "Number of candidate objects evaluated"
                },
                "candidatesGenerated": {
                    "type": "integer",
                    "description": "Number of candidate positions generated"
                },
                "searchDurationMs": {
                    "type": "integer",
                    "description": "Query execution time in milliseconds"
                },
                "cacheHit": {
                    "type": "boolean",
                    "description": "Whether results came from cache"
                }
            }
        }
    }
}
""";

    private static readonly string _QueryAffordance_Info = """
{
    "summary": "Find locations that afford a specific action or scene type",
    "description": "Affordance queries answer \"where can I do X?\" by combining\nmultiple map kinds and applying game-specific scoring logic.\n\nUsed by Event Brain for procedural scene orchestration:\n- \"Find ambush locations\"\n- \"Find dramatic reveal spots\"\n- \"Find sheltered rest areas\"\n\nWell-known types have predefined scoring; use affordanceType=custom\nwith customAffordance for novel scenarios.\n",
    "tags": [
        "Query"
    ],
    "deprecated": false,
    "operationId": "queryAffordance"
}
""";

    /// <summary>Returns endpoint information for QueryAffordance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/affordance/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryAffordance_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/query/affordance",
            _QueryAffordance_Info));

    /// <summary>Returns request schema for QueryAffordance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/affordance/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryAffordance_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/affordance",
            "request-schema",
            _QueryAffordance_RequestSchema));

    /// <summary>Returns response schema for QueryAffordance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/affordance/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryAffordance_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/affordance",
            "response-schema",
            _QueryAffordance_ResponseSchema));

    /// <summary>Returns full schema for QueryAffordance</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/query/affordance/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> QueryAffordance_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/query/affordance",
            _QueryAffordance_Info,
            _QueryAffordance_RequestSchema,
            _QueryAffordance_ResponseSchema));

    #endregion

    #region Meta Endpoints for CheckoutForAuthoring

    private static readonly string _CheckoutForAuthoring_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringCheckoutRequest",
    "$defs": {
        "AuthoringCheckoutRequest": {
            "type": "object",
            "description": "Request to checkout for authoring",
            "required": [
                "regionId",
                "kind",
                "editorId"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region to checkout"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind to checkout"
                },
                "editorId": {
                    "type": "string",
                    "description": "Identifier for the editor/user"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _CheckoutForAuthoring_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringCheckoutResponse",
    "$defs": {
        "AuthoringCheckoutResponse": {
            "type": "object",
            "description": "Checkout response",
            "properties": {
                "success": {
                    "type": "boolean",
                    "description": "Whether checkout was successful"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Token for publishing changes (if successful)",
                    "nullable": true
                },
                "expiresAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the checkout expires",
                    "nullable": true
                },
                "lockedBy": {
                    "type": "string",
                    "description": "Who has the lock (if checkout failed)",
                    "nullable": true
                },
                "lockedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the lock was acquired (if checkout failed)",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _CheckoutForAuthoring_Info = """
{
    "summary": "Acquire exclusive edit lock for design-time editing",
    "description": "For level editors and design tools only.\nGame servers do NOT use this - they use create-channel for implicit authority.\nReturns authority token for publishing edits.\n",
    "tags": [
        "Authoring"
    ],
    "deprecated": false,
    "operationId": "checkoutForAuthoring"
}
""";

    /// <summary>Returns endpoint information for CheckoutForAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/checkout/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutForAuthoring_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/authoring/checkout",
            _CheckoutForAuthoring_Info));

    /// <summary>Returns request schema for CheckoutForAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/checkout/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutForAuthoring_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authoring/checkout",
            "request-schema",
            _CheckoutForAuthoring_RequestSchema));

    /// <summary>Returns response schema for CheckoutForAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/checkout/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutForAuthoring_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authoring/checkout",
            "response-schema",
            _CheckoutForAuthoring_ResponseSchema));

    /// <summary>Returns full schema for CheckoutForAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/checkout/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CheckoutForAuthoring_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authoring/checkout",
            _CheckoutForAuthoring_Info,
            _CheckoutForAuthoring_RequestSchema,
            _CheckoutForAuthoring_ResponseSchema));

    #endregion

    #region Meta Endpoints for CommitAuthoring

    private static readonly string _CommitAuthoring_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringCommitRequest",
    "$defs": {
        "AuthoringCommitRequest": {
            "type": "object",
            "description": "Request to commit authoring changes",
            "required": [
                "regionId",
                "kind",
                "authorityToken"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region being edited"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind being edited"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Checkout authority token"
                },
                "commitMessage": {
                    "type": "string",
                    "description": "Optional commit message for history",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _CommitAuthoring_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringCommitResponse",
    "$defs": {
        "AuthoringCommitResponse": {
            "type": "object",
            "description": "Commit response",
            "properties": {
                "success": {
                    "type": "boolean",
                    "description": "Whether commit was successful"
                },
                "version": {
                    "type": "integer",
                    "format": "int64",
                    "description": "Committed version number",
                    "nullable": true
                }
            }
        }
    }
}
""";

    private static readonly string _CommitAuthoring_Info = """
{
    "summary": "Commit design-time changes",
    "description": "Commits pending changes and releases the checkout lock.\nOptionally includes a commit message for history.\n",
    "tags": [
        "Authoring"
    ],
    "deprecated": false,
    "operationId": "commitAuthoring"
}
""";

    /// <summary>Returns endpoint information for CommitAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/commit/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitAuthoring_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/authoring/commit",
            _CommitAuthoring_Info));

    /// <summary>Returns request schema for CommitAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/commit/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitAuthoring_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authoring/commit",
            "request-schema",
            _CommitAuthoring_RequestSchema));

    /// <summary>Returns response schema for CommitAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/commit/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitAuthoring_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authoring/commit",
            "response-schema",
            _CommitAuthoring_ResponseSchema));

    /// <summary>Returns full schema for CommitAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/commit/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CommitAuthoring_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authoring/commit",
            _CommitAuthoring_Info,
            _CommitAuthoring_RequestSchema,
            _CommitAuthoring_ResponseSchema));

    #endregion

    #region Meta Endpoints for ReleaseAuthoring

    private static readonly string _ReleaseAuthoring_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringReleaseRequest",
    "$defs": {
        "AuthoringReleaseRequest": {
            "type": "object",
            "description": "Request to release authoring checkout",
            "required": [
                "regionId",
                "kind",
                "authorityToken"
            ],
            "properties": {
                "regionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Region being edited"
                },
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "Map kind being edited"
                },
                "authorityToken": {
                    "type": "string",
                    "description": "Checkout authority token"
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        }
    }
}
""";

    private static readonly string _ReleaseAuthoring_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/AuthoringReleaseResponse",
    "$defs": {
        "AuthoringReleaseResponse": {
            "type": "object",
            "description": "Release response",
            "properties": {
                "released": {
                    "type": "boolean",
                    "description": "Whether checkout was released"
                }
            }
        }
    }
}
""";

    private static readonly string _ReleaseAuthoring_Info = """
{
    "summary": "Release authoring checkout without committing",
    "description": "Discards pending changes and releases the checkout lock.\nUse when abandoning edits.\n",
    "tags": [
        "Authoring"
    ],
    "deprecated": false,
    "operationId": "releaseAuthoring"
}
""";

    /// <summary>Returns endpoint information for ReleaseAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/release/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthoring_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/authoring/release",
            _ReleaseAuthoring_Info));

    /// <summary>Returns request schema for ReleaseAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/release/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthoring_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authoring/release",
            "request-schema",
            _ReleaseAuthoring_RequestSchema));

    /// <summary>Returns response schema for ReleaseAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/release/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthoring_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authoring/release",
            "response-schema",
            _ReleaseAuthoring_ResponseSchema));

    /// <summary>Returns full schema for ReleaseAuthoring</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/authoring/release/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ReleaseAuthoring_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/authoring/release",
            _ReleaseAuthoring_Info,
            _ReleaseAuthoring_RequestSchema,
            _ReleaseAuthoring_ResponseSchema));

    #endregion

    #region Meta Endpoints for CreateDefinition

    private static readonly string _CreateDefinition_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/CreateDefinitionRequest",
    "$defs": {
        "CreateDefinitionRequest": {
            "type": "object",
            "description": "Request to create a map definition",
            "required": [
                "name"
            ],
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Additional metadata",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateDefinition_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/MapDefinition",
    "$defs": {
        "MapDefinition": {
            "type": "object",
            "description": "A map definition template that describes the structure of a region",
            "required": [
                "definitionId",
                "name",
                "createdAt"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this definition"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations for this map",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Additional metadata (schema-less)",
                    "nullable": true
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was last updated",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _CreateDefinition_Info = """
{
    "summary": "Create a map definition template",
    "description": "Creates a new map definition (template) that describes the structure\nof a region. Definitions are templates that can be used to bootstrap\nchannels with predefined layer configurations.\n",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "createDefinition"
}
""";

    /// <summary>Returns endpoint information for CreateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/create/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDefinition_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/definition/create",
            _CreateDefinition_Info));

    /// <summary>Returns request schema for CreateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/create/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDefinition_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/create",
            "request-schema",
            _CreateDefinition_RequestSchema));

    /// <summary>Returns response schema for CreateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/create/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDefinition_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/create",
            "response-schema",
            _CreateDefinition_ResponseSchema));

    /// <summary>Returns full schema for CreateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/create/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> CreateDefinition_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/create",
            _CreateDefinition_Info,
            _CreateDefinition_RequestSchema,
            _CreateDefinition_ResponseSchema));

    #endregion

    #region Meta Endpoints for GetDefinition

    private static readonly string _GetDefinition_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/GetDefinitionRequest",
    "$defs": {
        "GetDefinitionRequest": {
            "type": "object",
            "description": "Request to get a map definition",
            "required": [
                "definitionId"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Definition ID to retrieve"
                }
            }
        }
    }
}
""";

    private static readonly string _GetDefinition_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/MapDefinition",
    "$defs": {
        "MapDefinition": {
            "type": "object",
            "description": "A map definition template that describes the structure of a region",
            "required": [
                "definitionId",
                "name",
                "createdAt"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this definition"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations for this map",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Additional metadata (schema-less)",
                    "nullable": true
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was last updated",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _GetDefinition_Info = """
{
    "summary": "Get a map definition by ID",
    "description": "Returns the full map definition including all layer configurations.",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "getDefinition"
}
""";

    /// <summary>Returns endpoint information for GetDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/get/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDefinition_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/definition/get",
            _GetDefinition_Info));

    /// <summary>Returns request schema for GetDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/get/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDefinition_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/get",
            "request-schema",
            _GetDefinition_RequestSchema));

    /// <summary>Returns response schema for GetDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/get/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDefinition_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/get",
            "response-schema",
            _GetDefinition_ResponseSchema));

    /// <summary>Returns full schema for GetDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/get/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> GetDefinition_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/get",
            _GetDefinition_Info,
            _GetDefinition_RequestSchema,
            _GetDefinition_ResponseSchema));

    #endregion

    #region Meta Endpoints for ListDefinitions

    private static readonly string _ListDefinitions_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListDefinitionsRequest",
    "$defs": {
        "ListDefinitionsRequest": {
            "type": "object",
            "description": "Request to list map definitions",
            "properties": {
                "nameFilter": {
                    "type": "string",
                    "description": "Filter by name (partial match)",
                    "nullable": true
                },
                "offset": {
                    "type": "integer",
                    "default": 0,
                    "description": "Pagination offset"
                },
                "limit": {
                    "type": "integer",
                    "default": 50,
                    "description": "Max results to return"
                }
            }
        }
    }
}
""";

    private static readonly string _ListDefinitions_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/ListDefinitionsResponse",
    "$defs": {
        "ListDefinitionsResponse": {
            "type": "object",
            "description": "Response containing list of map definitions",
            "properties": {
                "definitions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/MapDefinition"
                    },
                    "description": "List of definitions"
                },
                "total": {
                    "type": "integer",
                    "description": "Total count matching filter"
                },
                "offset": {
                    "type": "integer",
                    "description": "Current offset"
                },
                "limit": {
                    "type": "integer",
                    "description": "Results limit used"
                }
            }
        },
        "MapDefinition": {
            "type": "object",
            "description": "A map definition template that describes the structure of a region",
            "required": [
                "definitionId",
                "name",
                "createdAt"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this definition"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations for this map",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Additional metadata (schema-less)",
                    "nullable": true
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was last updated",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _ListDefinitions_Info = """
{
    "summary": "List map definitions with optional filters",
    "description": "Returns a paginated list of map definitions.",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "listDefinitions"
}
""";

    /// <summary>Returns endpoint information for ListDefinitions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/list/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDefinitions_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/definition/list",
            _ListDefinitions_Info));

    /// <summary>Returns request schema for ListDefinitions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/list/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDefinitions_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/list",
            "request-schema",
            _ListDefinitions_RequestSchema));

    /// <summary>Returns response schema for ListDefinitions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/list/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDefinitions_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/list",
            "response-schema",
            _ListDefinitions_ResponseSchema));

    /// <summary>Returns full schema for ListDefinitions</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/list/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> ListDefinitions_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/list",
            _ListDefinitions_Info,
            _ListDefinitions_RequestSchema,
            _ListDefinitions_ResponseSchema));

    #endregion

    #region Meta Endpoints for UpdateDefinition

    private static readonly string _UpdateDefinition_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/UpdateDefinitionRequest",
    "$defs": {
        "UpdateDefinitionRequest": {
            "type": "object",
            "description": "Request to update a map definition",
            "required": [
                "definitionId"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Definition ID to update"
                },
                "name": {
                    "type": "string",
                    "description": "New name (optional)",
                    "nullable": true
                },
                "description": {
                    "type": "string",
                    "description": "New description (optional)",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "New layer configurations (replaces existing)",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "New default bounds",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "New metadata (replaces existing)",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateDefinition_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/MapDefinition",
    "$defs": {
        "MapDefinition": {
            "type": "object",
            "description": "A map definition template that describes the structure of a region",
            "required": [
                "definitionId",
                "name",
                "createdAt"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Unique identifier for this definition"
                },
                "name": {
                    "type": "string",
                    "description": "Human-readable name"
                },
                "description": {
                    "type": "string",
                    "description": "Description of the map template",
                    "nullable": true
                },
                "layers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/LayerDefinition"
                    },
                    "description": "Layer configurations for this map",
                    "nullable": true
                },
                "defaultBounds": {
                    "$ref": "#/$defs/Bounds",
                    "description": "Default bounds for regions using this definition",
                    "nullable": true
                },
                "metadata": {
                    "type": "object",
                    "additionalProperties": true,
                    "description": "Additional metadata (schema-less)",
                    "nullable": true
                },
                "createdAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was created"
                },
                "updatedAt": {
                    "type": "string",
                    "format": "date-time",
                    "description": "When the definition was last updated",
                    "nullable": true
                }
            }
        },
        "LayerDefinition": {
            "type": "object",
            "description": "Configuration for a specific layer within a map definition",
            "required": [
                "kind"
            ],
            "properties": {
                "kind": {
                    "$ref": "#/$defs/MapKind",
                    "description": "The layer kind"
                },
                "storageMode": {
                    "type": "string",
                    "enum": [
                        "durable",
                        "cached",
                        "ephemeral"
                    ],
                    "default": "cached",
                    "description": "How this layer's data should be stored"
                },
                "ttlSeconds": {
                    "type": "integer",
                    "description": "TTL for cached/ephemeral data (0 = no TTL)",
                    "nullable": true
                },
                "defaultNonAuthorityHandling": {
                    "$ref": "#/$defs/NonAuthorityHandlingMode",
                    "description": "Default non-authority handling for channels using this layer"
                },
                "cellSize": {
                    "type": "number",
                    "format": "double",
                    "description": "Spatial cell size for indexing (default from config if not set)",
                    "nullable": true
                }
            }
        },
        "MapKind": {
            "type": "string",
            "description": "The category of spatial data this map contains.\ nDifferent kinds have different update frequencies, storage models, and TTLs.\n",
            "enum": [
                "terrain",
                "static_geometry",
                "navigation",
                "resources",
                "spawn_points",
                "points_of_interest",
                "dynamic_objects",
                "hazards",
                "weather_effects",
                "ownership",
                "combat_effects",
                "visual_effects"
            ]
        },
        "NonAuthorityHandlingMode": {
            "type": "string",
            "description": "How to handle publish attempts from non-authority sources",
            "enum": [
                "reject_and_alert",
                "accept_and_alert",
                "reject_silent"
            ],
            "default": "reject_and_alert"
        },
        "Bounds": {
            "type": "object",
            "description": "An axis-aligned bounding box in 3D space",
            "required": [
                "min",
                "max"
            ],
            "properties": {
                "min": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Minimum corner (lowest x, y, z values)"
                },
                "max": {
                    "$ref": "#/$defs/Position3D",
                    "description": "Maximum corner (highest x, y, z values)"
                }
            }
        },
        "Position3D": {
            "type": "object",
            "description": "A point in 3D space",
            "required": [
                "x",
                "y",
                "z"
            ],
            "properties": {
                "x": {
                    "type": "number",
                    "format": "double",
                    "description": "X coordinate (typically east-west)"
                },
                "y": {
                    "type": "number",
                    "format": "double",
                    "description": "Y coordinate (typically up-down / elevation)"
                },
                "z": {
                    "type": "number",
                    "format": "double",
                    "description": "Z coordinate (typically north-south)"
                }
            }
        }
    }
}
""";

    private static readonly string _UpdateDefinition_Info = """
{
    "summary": "Update a map definition",
    "description": "Updates an existing map definition. Cannot change the definition ID.\nLayer configurations can be modified.\n",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "updateDefinition"
}
""";

    /// <summary>Returns endpoint information for UpdateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/update/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDefinition_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/definition/update",
            _UpdateDefinition_Info));

    /// <summary>Returns request schema for UpdateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/update/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDefinition_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/update",
            "request-schema",
            _UpdateDefinition_RequestSchema));

    /// <summary>Returns response schema for UpdateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/update/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDefinition_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/update",
            "response-schema",
            _UpdateDefinition_ResponseSchema));

    /// <summary>Returns full schema for UpdateDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/update/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> UpdateDefinition_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/update",
            _UpdateDefinition_Info,
            _UpdateDefinition_RequestSchema,
            _UpdateDefinition_ResponseSchema));

    #endregion

    #region Meta Endpoints for DeleteDefinition

    private static readonly string _DeleteDefinition_RequestSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteDefinitionRequest",
    "$defs": {
        "DeleteDefinitionRequest": {
            "type": "object",
            "description": "Request to delete a map definition",
            "required": [
                "definitionId"
            ],
            "properties": {
                "definitionId": {
                    "type": "string",
                    "format": "uuid",
                    "description": "Definition ID to delete"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteDefinition_ResponseSchema = """
{
    "$schema": "http://json-schema.org/draft-07/schema#",
    "$ref": "#/$defs/DeleteDefinitionResponse",
    "$defs": {
        "DeleteDefinitionResponse": {
            "type": "object",
            "description": "Response to delete request",
            "properties": {
                "deleted": {
                    "type": "boolean",
                    "description": "Whether the definition was deleted"
                }
            }
        }
    }
}
""";

    private static readonly string _DeleteDefinition_Info = """
{
    "summary": "Delete a map definition",
    "description": "Deletes a map definition. Cannot delete if active channels reference it.",
    "tags": [
        "Definition"
    ],
    "deprecated": false,
    "operationId": "deleteDefinition"
}
""";

    /// <summary>Returns endpoint information for DeleteDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/delete/meta/info")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDefinition_MetaInfo()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildInfoResponse(
            "Mapping",
            "Post",
            "mapping/definition/delete",
            _DeleteDefinition_Info));

    /// <summary>Returns request schema for DeleteDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/delete/meta/request-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDefinition_MetaRequestSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/delete",
            "request-schema",
            _DeleteDefinition_RequestSchema));

    /// <summary>Returns response schema for DeleteDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/delete/meta/response-schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDefinition_MetaResponseSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/delete",
            "response-schema",
            _DeleteDefinition_ResponseSchema));

    /// <summary>Returns full schema for DeleteDefinition</summary>
    [Microsoft.AspNetCore.Mvc.HttpGet, Microsoft.AspNetCore.Mvc.Route("mapping/definition/delete/meta/schema")]
    public Microsoft.AspNetCore.Mvc.ActionResult<BeyondImmersion.BannouService.Meta.MetaResponse> DeleteDefinition_MetaFullSchema()
        => Ok(BeyondImmersion.BannouService.Meta.MetaResponseBuilder.BuildFullSchemaResponse(
            "Mapping",
            "Post",
            "mapping/definition/delete",
            _DeleteDefinition_Info,
            _DeleteDefinition_RequestSchema,
            _DeleteDefinition_ResponseSchema));

    #endregion

}



#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765
